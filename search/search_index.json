{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solana.py \ud83d\udc0d The Solana Python SDK \ud83d\udc0d Solana.py is the base Python library for interacting with Solana. You can use it to build transactions and interact with the Solana JSON RPC API , much like you would do with solana-web3.js It also covers the SPL Token Program . Latest Documentation . Note: This library uses many core types from the Solders package which used to be provided by solana-py itself. If you are upgrading from an old version and you're looking for something that was deleted, it's probably in solders now. \u2693\ufe0e See also: AnchorPy , a Python client for Anchor -based programs on Solana. \u2693\ufe0e \u26a1 Quickstart Installation Install Python bindings for the solana-sdk . pip install solders Install this package to interact with the Solana JSON RPC API . pip install solana General Usage Python Cookbook Solana Cookbook API Client from solana.rpc.api import Client http_client = Client ( \"https://api.devnet.solana.com\" ) Async API Client import asyncio from solana.rpc.async_api import AsyncClient async def main (): async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : res = await client . is_connected () print ( res ) # True # Alternatively, close the client explicitly instead of using a context manager: client = AsyncClient ( \"https://api.devnet.solana.com\" ) res = await client . is_connected () print ( res ) # True await client . close () asyncio . run ( main ()) Websockets Client import asyncio from asyncstdlib import enumerate from solana.rpc.websocket_api import connect async def main (): async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp [ 0 ] . result next_resp = await websocket . recv () print ( next_resp ) await websocket . logs_unsubscribe ( subscription_id ) # Alternatively, use the client as an infinite asynchronous iterator: async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp [ 0 ] . result async for idx , msg in enumerate ( websocket ): if idx == 3 : break print ( msg ) await websocket . logs_unsubscribe ( subscription_id ) asyncio . run ( main ()) \ud83d\udd28 Development Setup Install poetry Install dev dependencies: poetry install Activate the poetry shell. poetry shell Lint make lint Tests # All tests make tests # Unit tests only make unit-tests # Integration tests only make int-tests","title":"Home"},{"location":"#solanapy","text":"\ud83d\udc0d The Solana Python SDK \ud83d\udc0d Solana.py is the base Python library for interacting with Solana. You can use it to build transactions and interact with the Solana JSON RPC API , much like you would do with solana-web3.js It also covers the SPL Token Program . Latest Documentation . Note: This library uses many core types from the Solders package which used to be provided by solana-py itself. If you are upgrading from an old version and you're looking for something that was deleted, it's probably in solders now. \u2693\ufe0e See also: AnchorPy , a Python client for Anchor -based programs on Solana. \u2693\ufe0e","title":"Solana.py"},{"location":"#quickstart","text":"","title":"\u26a1 Quickstart"},{"location":"#installation","text":"Install Python bindings for the solana-sdk . pip install solders Install this package to interact with the Solana JSON RPC API . pip install solana","title":"Installation"},{"location":"#general-usage","text":"Python Cookbook Solana Cookbook","title":"General Usage"},{"location":"#api-client","text":"from solana.rpc.api import Client http_client = Client ( \"https://api.devnet.solana.com\" )","title":"API Client"},{"location":"#async-api-client","text":"import asyncio from solana.rpc.async_api import AsyncClient async def main (): async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : res = await client . is_connected () print ( res ) # True # Alternatively, close the client explicitly instead of using a context manager: client = AsyncClient ( \"https://api.devnet.solana.com\" ) res = await client . is_connected () print ( res ) # True await client . close () asyncio . run ( main ())","title":"Async API Client"},{"location":"#websockets-client","text":"import asyncio from asyncstdlib import enumerate from solana.rpc.websocket_api import connect async def main (): async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp [ 0 ] . result next_resp = await websocket . recv () print ( next_resp ) await websocket . logs_unsubscribe ( subscription_id ) # Alternatively, use the client as an infinite asynchronous iterator: async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp [ 0 ] . result async for idx , msg in enumerate ( websocket ): if idx == 3 : break print ( msg ) await websocket . logs_unsubscribe ( subscription_id ) asyncio . run ( main ())","title":"Websockets Client"},{"location":"#development","text":"","title":"\ud83d\udd28 Development"},{"location":"#setup","text":"Install poetry Install dev dependencies: poetry install Activate the poetry shell. poetry shell","title":"Setup"},{"location":"#lint","text":"make lint","title":"Lint"},{"location":"#tests","text":"# All tests make tests # Unit tests only make unit-tests # Integration tests only make int-tests","title":"Tests"},{"location":"cookbook/","text":"Cookbook The Solana Cookbook is a developer resource that provides examples and references for building applications on Solana. Each example and reference will focus on specific aspects of Solana development while providing additional details and usage examples. Development Guides Development guides help developers set up and interact with the Solana ecosystem using various tools and clients. Guide Client Description Connecting to Solana Python How to connect to Solana clusters and verify connection Getting Test SOL Python How to get test SOL for development Subscribing to Events Python How to subscribe to account and program events Create Account Python How to create a new account on Solana Account Management Learn how to manage Solana accounts effectively. Guide Client Description Calculate Account Creation Cost Python Calculate minimum balance for rent exemption Create PDA Account Python Create Program Derived Address accounts Get Account Balance Python Retrieve account balance information Token Operations Comprehensive guides for working with tokens on Solana. Guide Client Description Create Token Python Create a new SPL token Get Token Mint Python Retrieve token mint information Create Token Account Python Create an associated token account Get Token Account Python Retrieve token account information Get Token Balance Python Check token balance in an account Mint Tokens Python Mint tokens to an account Burn Tokens Python Burn tokens from an account Transfer Tokens Python Transfer tokens between accounts Close Token Account Python Close and reclaim SOL from token account Get All Token Accounts Python Get all token accounts by owner Set Authority Python Change token mint or account authority Delegate Token Account Python Delegate token account authority Revoke Delegate Python Revoke delegated authority Wrapped SOL Python Work with wrapped SOL tokens Transaction Operations Explore various transaction-related operations on the Solana blockchain. Guide Client Description Send SOL Python Send SOL between accounts Send Tokens Python Send tokens between accounts Calculate Transaction Cost Python Calculate transaction fees Add Memo to Transaction Python Add memo instruction to transactions Add Priority Fees Python Add priority fees to transactions Optimize Compute Requested Python Optimize compute units for transactions Offline Transactions Python Create and sign transactions offline Wallet Management Learn how to create, restore, and manage Solana wallets using various tools and libraries. Guide Client Description Create Keypair Python Generate new keypairs Restore Keypair Python Restore keypair from seed phrase Verify Keypair Python Verify keypair validity Validate Public Key Python Validate public key format Sign and Verify Message Python Sign and verify messages Codebase Solana Cookbook Examples","title":"Cookbook"},{"location":"cookbook/#cookbook","text":"The Solana Cookbook is a developer resource that provides examples and references for building applications on Solana. Each example and reference will focus on specific aspects of Solana development while providing additional details and usage examples.","title":"Cookbook"},{"location":"cookbook/#development-guides","text":"Development guides help developers set up and interact with the Solana ecosystem using various tools and clients. Guide Client Description Connecting to Solana Python How to connect to Solana clusters and verify connection Getting Test SOL Python How to get test SOL for development Subscribing to Events Python How to subscribe to account and program events Create Account Python How to create a new account on Solana","title":"Development Guides"},{"location":"cookbook/#account-management","text":"Learn how to manage Solana accounts effectively. Guide Client Description Calculate Account Creation Cost Python Calculate minimum balance for rent exemption Create PDA Account Python Create Program Derived Address accounts Get Account Balance Python Retrieve account balance information","title":"Account Management"},{"location":"cookbook/#token-operations","text":"Comprehensive guides for working with tokens on Solana. Guide Client Description Create Token Python Create a new SPL token Get Token Mint Python Retrieve token mint information Create Token Account Python Create an associated token account Get Token Account Python Retrieve token account information Get Token Balance Python Check token balance in an account Mint Tokens Python Mint tokens to an account Burn Tokens Python Burn tokens from an account Transfer Tokens Python Transfer tokens between accounts Close Token Account Python Close and reclaim SOL from token account Get All Token Accounts Python Get all token accounts by owner Set Authority Python Change token mint or account authority Delegate Token Account Python Delegate token account authority Revoke Delegate Python Revoke delegated authority Wrapped SOL Python Work with wrapped SOL tokens","title":"Token Operations"},{"location":"cookbook/#transaction-operations","text":"Explore various transaction-related operations on the Solana blockchain. Guide Client Description Send SOL Python Send SOL between accounts Send Tokens Python Send tokens between accounts Calculate Transaction Cost Python Calculate transaction fees Add Memo to Transaction Python Add memo instruction to transactions Add Priority Fees Python Add priority fees to transactions Optimize Compute Requested Python Optimize compute units for transactions Offline Transactions Python Create and sign transactions offline","title":"Transaction Operations"},{"location":"cookbook/#wallet-management","text":"Learn how to create, restore, and manage Solana wallets using various tools and libraries. Guide Client Description Create Keypair Python Generate new keypairs Restore Keypair Python Restore keypair from seed phrase Verify Keypair Python Verify keypair validity Validate Public Key Python Validate public key format Sign and Verify Message Python Sign and verify messages","title":"Wallet Management"},{"location":"cookbook/#codebase","text":"Solana Cookbook Examples","title":"Codebase"},{"location":"cookbook/account-management/calculate-account-creation-cost/","text":"Calculate Account Creation Cost This example demonstrates how to calculate the minimum balance required for rent exemption for a Solana account. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Calculate Account Creation Cost \"\"\" import asyncio from solana.rpc.async_api import AsyncClient async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) space = 1500 # bytes async with rpc : lamports = await rpc . get_minimum_balance_for_rent_exemption ( space ) print ( f \"Minimum balance for rent exemption: { lamports . value } \" ) print ( f \"For account size: { space } bytes\" ) print ( f \"Cost in SOL: { lamports . value / 1_000_000_000 } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Set account size : Define the account size in bytes (1500 bytes in this example) Get minimum balance : Use get_minimum_balance_for_rent_exemption() to calculate the required lamports Display results : Show the cost in lamports and convert to SOL for easier understanding Key Concepts Rent exemption : Accounts with sufficient balance are exempt from rent payments Lamports : The smallest unit of SOL (1 SOL = 1,000,000,000 lamports) Account size : Determines the minimum balance required for rent exemption Usage python calculate_account_creation_cost.py This will output something like: Minimum balance for rent exemption: 10616160 For account size: 1500 bytes Cost in SOL: 0.01061616","title":"Calculate Account Creation Cost"},{"location":"cookbook/account-management/calculate-account-creation-cost/#calculate-account-creation-cost","text":"This example demonstrates how to calculate the minimum balance required for rent exemption for a Solana account.","title":"Calculate Account Creation Cost"},{"location":"cookbook/account-management/calculate-account-creation-cost/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Calculate Account Creation Cost \"\"\" import asyncio from solana.rpc.async_api import AsyncClient async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) space = 1500 # bytes async with rpc : lamports = await rpc . get_minimum_balance_for_rent_exemption ( space ) print ( f \"Minimum balance for rent exemption: { lamports . value } \" ) print ( f \"For account size: { space } bytes\" ) print ( f \"Cost in SOL: { lamports . value / 1_000_000_000 } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/account-management/calculate-account-creation-cost/#explanation","text":"Set account size : Define the account size in bytes (1500 bytes in this example) Get minimum balance : Use get_minimum_balance_for_rent_exemption() to calculate the required lamports Display results : Show the cost in lamports and convert to SOL for easier understanding","title":"Explanation"},{"location":"cookbook/account-management/calculate-account-creation-cost/#key-concepts","text":"Rent exemption : Accounts with sufficient balance are exempt from rent payments Lamports : The smallest unit of SOL (1 SOL = 1,000,000,000 lamports) Account size : Determines the minimum balance required for rent exemption","title":"Key Concepts"},{"location":"cookbook/account-management/calculate-account-creation-cost/#usage","text":"python calculate_account_creation_cost.py This will output something like: Minimum balance for rent exemption: 10616160 For account size: 1500 bytes Cost in SOL: 0.01061616","title":"Usage"},{"location":"cookbook/account-management/create-pda-account/","text":"Create PDA Account This example shows how to create a Program Derived Address (PDA) account on Solana. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create a PDA's Account \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.system_program import create_account_with_seed , CreateAccountWithSeedParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) payer = Keypair () program_id = Pubkey . from_string ( \"11111111111111111111111111111111\" ) # Create PDA (Program Derived Address) seed = \"hello\" pda , bump = Pubkey . find_program_address ([ seed . encode ()], program_id ) space = 100 # Account data space async with rpc : # Get minimum balance for rent exemption rent_lamports = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Use the payer as base for seed derivation create_account_instruction = create_account_with_seed ( CreateAccountWithSeedParams ( from_pubkey = payer . pubkey (), to_pubkey = pda , base = payer . pubkey (), seed = seed , lamports = rent_lamports . value , space = space , owner = program_id ) ) # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ create_account_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer ]) print ( f \"Payer: { payer . pubkey () } \" ) print ( f \"PDA: { pda } \" ) print ( f \"Seed: { seed } \" ) print ( f \"Bump: { bump } \" ) print ( f \"Space: { space } bytes\" ) print ( f \"Rent Lamports: { rent_lamports . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Find PDA : Use find_program_address() to derive the PDA from a seed and program ID Calculate rent : Get the minimum balance required for the account size Create instruction : Build the account creation instruction using the PDA Build transaction : Compile the instruction into a transaction Key Concepts PDA : Program Derived Address - a deterministic address derived from seeds Seed : A string used to derive the PDA address Bump : A value that ensures the PDA is not on the ed25519 curve Program ID : The program that will own the PDA account Deterministic : The same seed always produces the same PDA Usage python create_pda_account.py This will output: Payer: 5J8...abc PDA: 3Kd...def Seed: hello Bump: 254 Space: 100 bytes Rent Lamports: 1461600 Use Cases Program state : Store program-specific data Token accounts : Create token accounts owned by programs Cross-program invocation : Allow programs to sign transactions","title":"Create PDA Account"},{"location":"cookbook/account-management/create-pda-account/#create-pda-account","text":"This example shows how to create a Program Derived Address (PDA) account on Solana.","title":"Create PDA Account"},{"location":"cookbook/account-management/create-pda-account/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create a PDA's Account \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.system_program import create_account_with_seed , CreateAccountWithSeedParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) payer = Keypair () program_id = Pubkey . from_string ( \"11111111111111111111111111111111\" ) # Create PDA (Program Derived Address) seed = \"hello\" pda , bump = Pubkey . find_program_address ([ seed . encode ()], program_id ) space = 100 # Account data space async with rpc : # Get minimum balance for rent exemption rent_lamports = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Use the payer as base for seed derivation create_account_instruction = create_account_with_seed ( CreateAccountWithSeedParams ( from_pubkey = payer . pubkey (), to_pubkey = pda , base = payer . pubkey (), seed = seed , lamports = rent_lamports . value , space = space , owner = program_id ) ) # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ create_account_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer ]) print ( f \"Payer: { payer . pubkey () } \" ) print ( f \"PDA: { pda } \" ) print ( f \"Seed: { seed } \" ) print ( f \"Bump: { bump } \" ) print ( f \"Space: { space } bytes\" ) print ( f \"Rent Lamports: { rent_lamports . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/account-management/create-pda-account/#explanation","text":"Find PDA : Use find_program_address() to derive the PDA from a seed and program ID Calculate rent : Get the minimum balance required for the account size Create instruction : Build the account creation instruction using the PDA Build transaction : Compile the instruction into a transaction","title":"Explanation"},{"location":"cookbook/account-management/create-pda-account/#key-concepts","text":"PDA : Program Derived Address - a deterministic address derived from seeds Seed : A string used to derive the PDA address Bump : A value that ensures the PDA is not on the ed25519 curve Program ID : The program that will own the PDA account Deterministic : The same seed always produces the same PDA","title":"Key Concepts"},{"location":"cookbook/account-management/create-pda-account/#usage","text":"python create_pda_account.py This will output: Payer: 5J8...abc PDA: 3Kd...def Seed: hello Bump: 254 Space: 100 bytes Rent Lamports: 1461600","title":"Usage"},{"location":"cookbook/account-management/create-pda-account/#use-cases","text":"Program state : Store program-specific data Token accounts : Create token accounts owned by programs Cross-program invocation : Allow programs to sign transactions","title":"Use Cases"},{"location":"cookbook/account-management/get-account-balance/","text":"Get Account Balance This example shows how to retrieve an account's balance on the Solana blockchain. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get Account Balance \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example public key (you can replace with any valid public key) account_pubkey = Pubkey . from_string ( \"11111111111111111111111111111111\" ) async with rpc : # Get account balance balance = await rpc . get_balance ( account_pubkey ) print ( f \"Account: { account_pubkey } \" ) print ( f \"Balance: { balance . value } lamports\" ) print ( f \"Balance: { balance . value / 1_000_000_000 } SOL\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Create RPC client : Connect to the Solana devnet Parse public key : Convert string representation to Pubkey object Get balance : Use get_balance() to retrieve the account balance Display results : Show balance in both lamports and SOL Key Concepts Lamports : The smallest unit of SOL (1 SOL = 1,000,000,000 lamports) Account balance : The amount of SOL held by an account Public key : The account's address on the blockchain Usage python get_account_balance.py This will output: Account: 11111111111111111111111111111111 Balance: 1000000000 lamports Balance: 1.0 SOL Error Handling If the account doesn't exist, the balance will be 0: async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Non-existent account account_pubkey = Pubkey . from_string ( \"22222222222222222222222222222222\" ) async with rpc : try : balance = await rpc . get_balance ( account_pubkey ) print ( f \"Balance: { balance . value } lamports\" ) except Exception as e : print ( f \"Error: { e } \" ) Network Endpoints Devnet : https://api.devnet.solana.com Testnet : https://api.testnet.solana.com Mainnet : https://api.mainnet-beta.solana.com","title":"Get Account Balance"},{"location":"cookbook/account-management/get-account-balance/#get-account-balance","text":"This example shows how to retrieve an account's balance on the Solana blockchain.","title":"Get Account Balance"},{"location":"cookbook/account-management/get-account-balance/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get Account Balance \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example public key (you can replace with any valid public key) account_pubkey = Pubkey . from_string ( \"11111111111111111111111111111111\" ) async with rpc : # Get account balance balance = await rpc . get_balance ( account_pubkey ) print ( f \"Account: { account_pubkey } \" ) print ( f \"Balance: { balance . value } lamports\" ) print ( f \"Balance: { balance . value / 1_000_000_000 } SOL\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/account-management/get-account-balance/#explanation","text":"Create RPC client : Connect to the Solana devnet Parse public key : Convert string representation to Pubkey object Get balance : Use get_balance() to retrieve the account balance Display results : Show balance in both lamports and SOL","title":"Explanation"},{"location":"cookbook/account-management/get-account-balance/#key-concepts","text":"Lamports : The smallest unit of SOL (1 SOL = 1,000,000,000 lamports) Account balance : The amount of SOL held by an account Public key : The account's address on the blockchain","title":"Key Concepts"},{"location":"cookbook/account-management/get-account-balance/#usage","text":"python get_account_balance.py This will output: Account: 11111111111111111111111111111111 Balance: 1000000000 lamports Balance: 1.0 SOL","title":"Usage"},{"location":"cookbook/account-management/get-account-balance/#error-handling","text":"If the account doesn't exist, the balance will be 0: async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Non-existent account account_pubkey = Pubkey . from_string ( \"22222222222222222222222222222222\" ) async with rpc : try : balance = await rpc . get_balance ( account_pubkey ) print ( f \"Balance: { balance . value } lamports\" ) except Exception as e : print ( f \"Error: { e } \" )","title":"Error Handling"},{"location":"cookbook/account-management/get-account-balance/#network-endpoints","text":"Devnet : https://api.devnet.solana.com Testnet : https://api.testnet.solana.com Mainnet : https://api.mainnet-beta.solana.com","title":"Network Endpoints"},{"location":"cookbook/development-guides/connecting-to-solana/","text":"Connecting to Solana This example shows how to connect to a Solana environment and check the connection status. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - Connecting to a Solana Environment \"\"\" import asyncio from solana.rpc.async_api import AsyncClient async def main (): async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : res = await client . is_connected () print ( res ) # True asyncio . run ( main ()) Explanation Import required modules : We import asyncio for async operations and AsyncClient from solana.rpc.async_api Create async client : Initialize an async client with the Solana devnet RPC endpoint Check connection : Use is_connected() to verify the connection status Print result : The result should be True if connected successfully Usage Run this script to test your connection to the Solana devnet: python connecting_to_solana.py Network Endpoints Devnet : https://api.devnet.solana.com Testnet : https://api.testnet.solana.com Mainnet : https://api.mainnet-beta.solana.com","title":"Connecting to Solana"},{"location":"cookbook/development-guides/connecting-to-solana/#connecting-to-solana","text":"This example shows how to connect to a Solana environment and check the connection status.","title":"Connecting to Solana"},{"location":"cookbook/development-guides/connecting-to-solana/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - Connecting to a Solana Environment \"\"\" import asyncio from solana.rpc.async_api import AsyncClient async def main (): async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : res = await client . is_connected () print ( res ) # True asyncio . run ( main ())","title":"Code"},{"location":"cookbook/development-guides/connecting-to-solana/#explanation","text":"Import required modules : We import asyncio for async operations and AsyncClient from solana.rpc.async_api Create async client : Initialize an async client with the Solana devnet RPC endpoint Check connection : Use is_connected() to verify the connection status Print result : The result should be True if connected successfully","title":"Explanation"},{"location":"cookbook/development-guides/connecting-to-solana/#usage","text":"Run this script to test your connection to the Solana devnet: python connecting_to_solana.py","title":"Usage"},{"location":"cookbook/development-guides/connecting-to-solana/#network-endpoints","text":"Devnet : https://api.devnet.solana.com Testnet : https://api.testnet.solana.com Mainnet : https://api.mainnet-beta.solana.com","title":"Network Endpoints"},{"location":"cookbook/development-guides/create-account/","text":"Create Account This example shows how to create a new account on the Solana blockchain. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create an Account \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import create_account , CreateAccountParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () new_account = Keypair () space = 0 # Account data space async with rpc : # Get minimum balance for rent exemption rent_lamports = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create account instruction create_account_instruction = create_account ( CreateAccountParams ( from_pubkey = sender . pubkey (), to_pubkey = new_account . pubkey (), lamports = rent_lamports . value , space = space , owner = sender . pubkey () # System program owns the account ) ) # Create message message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ create_account_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender , new_account ]) print ( f \"Payer: { sender . pubkey () } \" ) print ( f \"New Account: { new_account . pubkey () } \" ) print ( f \"Rent Lamports: { rent_lamports . value } \" ) print ( f \"Space: { space } bytes\" ) print ( f \"Account creation transaction created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Set up keypairs : Create keypairs for the payer and new account Calculate rent : Get the minimum balance required for rent exemption Create instruction : Build the account creation instruction Build transaction : Compile the instruction into a transaction Sign transaction : Sign with both the payer and new account keypairs Key Concepts Rent exemption : Accounts must hold enough SOL to be exempt from rent Account space : Define how much data storage the account needs Owner : The program that owns and can modify the account Payer : The account that pays for the transaction and rent Usage python create_account.py This will output: Payer: 5J8...abc New Account: 3Kd...def Rent Lamports: 890880 Space: 0 bytes Account creation transaction created successfully Prerequisites The payer account must have enough SOL to cover transaction fees and rent Both keypairs must sign the transaction","title":"Create Account"},{"location":"cookbook/development-guides/create-account/#create-account","text":"This example shows how to create a new account on the Solana blockchain.","title":"Create Account"},{"location":"cookbook/development-guides/create-account/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create an Account \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import create_account , CreateAccountParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () new_account = Keypair () space = 0 # Account data space async with rpc : # Get minimum balance for rent exemption rent_lamports = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create account instruction create_account_instruction = create_account ( CreateAccountParams ( from_pubkey = sender . pubkey (), to_pubkey = new_account . pubkey (), lamports = rent_lamports . value , space = space , owner = sender . pubkey () # System program owns the account ) ) # Create message message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ create_account_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender , new_account ]) print ( f \"Payer: { sender . pubkey () } \" ) print ( f \"New Account: { new_account . pubkey () } \" ) print ( f \"Rent Lamports: { rent_lamports . value } \" ) print ( f \"Space: { space } bytes\" ) print ( f \"Account creation transaction created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/development-guides/create-account/#explanation","text":"Set up keypairs : Create keypairs for the payer and new account Calculate rent : Get the minimum balance required for rent exemption Create instruction : Build the account creation instruction Build transaction : Compile the instruction into a transaction Sign transaction : Sign with both the payer and new account keypairs","title":"Explanation"},{"location":"cookbook/development-guides/create-account/#key-concepts","text":"Rent exemption : Accounts must hold enough SOL to be exempt from rent Account space : Define how much data storage the account needs Owner : The program that owns and can modify the account Payer : The account that pays for the transaction and rent","title":"Key Concepts"},{"location":"cookbook/development-guides/create-account/#usage","text":"python create_account.py This will output: Payer: 5J8...abc New Account: 3Kd...def Rent Lamports: 890880 Space: 0 bytes Account creation transaction created successfully","title":"Usage"},{"location":"cookbook/development-guides/create-account/#prerequisites","text":"The payer account must have enough SOL to cover transaction fees and rent Both keypairs must sign the transaction","title":"Prerequisites"},{"location":"cookbook/development-guides/getting-test-sol/","text":"Getting Test SOL This example shows how to request an airdrop of SOL on the Solana devnet for testing purposes. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - Getting Test SOL \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair async def main (): keypair = Keypair () async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : # Request airdrop (1 SOL = 1_000_000_000 lamports) res = await client . request_airdrop ( keypair . pubkey (), 1_000_000_000 ) print ( f \"Airdrop signature: { res . value } \" ) # Check balance balance = await client . get_balance ( keypair . pubkey ()) print ( f \"Balance: { balance . value } lamports\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Create a keypair : Generate a new keypair for testing Request airdrop : Use request_airdrop() to get 1 SOL from the devnet faucet Check balance : Verify the airdrop was successful by checking the account balance Key Points Devnet only : Airdrops are only available on devnet and testnet, not mainnet Amount limits : Each airdrop request is limited to 1 SOL Rate limits : There are rate limits on airdrop requests per account Lamports : 1 SOL = 1,000,000,000 lamports Usage python getting_test_sol.py This will output: Airdrop signature: 5J8...abc Balance: 1000000000 lamports Alternative Methods You can also get test SOL from: - Solana Faucet - Web interface - solana airdrop CLI command","title":"Getting Test SOL"},{"location":"cookbook/development-guides/getting-test-sol/#getting-test-sol","text":"This example shows how to request an airdrop of SOL on the Solana devnet for testing purposes.","title":"Getting Test SOL"},{"location":"cookbook/development-guides/getting-test-sol/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - Getting Test SOL \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair async def main (): keypair = Keypair () async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : # Request airdrop (1 SOL = 1_000_000_000 lamports) res = await client . request_airdrop ( keypair . pubkey (), 1_000_000_000 ) print ( f \"Airdrop signature: { res . value } \" ) # Check balance balance = await client . get_balance ( keypair . pubkey ()) print ( f \"Balance: { balance . value } lamports\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/development-guides/getting-test-sol/#explanation","text":"Create a keypair : Generate a new keypair for testing Request airdrop : Use request_airdrop() to get 1 SOL from the devnet faucet Check balance : Verify the airdrop was successful by checking the account balance","title":"Explanation"},{"location":"cookbook/development-guides/getting-test-sol/#key-points","text":"Devnet only : Airdrops are only available on devnet and testnet, not mainnet Amount limits : Each airdrop request is limited to 1 SOL Rate limits : There are rate limits on airdrop requests per account Lamports : 1 SOL = 1,000,000,000 lamports","title":"Key Points"},{"location":"cookbook/development-guides/getting-test-sol/#usage","text":"python getting_test_sol.py This will output: Airdrop signature: 5J8...abc Balance: 1000000000 lamports","title":"Usage"},{"location":"cookbook/development-guides/getting-test-sol/#alternative-methods","text":"You can also get test SOL from: - Solana Faucet - Web interface - solana airdrop CLI command","title":"Alternative Methods"},{"location":"cookbook/development-guides/subscribing-to-events/","text":"Subscribing to Events This example demonstrates how to subscribe to Solana blockchain events using WebSocket connections. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - Subscribing to Events \"\"\" import asyncio from solana.rpc.websocket_api import connect from solders.keypair import Keypair async def main (): keypair = Keypair () async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : # Subscribe to account changes await websocket . account_subscribe ( keypair . pubkey ()) # Subscribe to logs await websocket . logs_subscribe () # Listen for messages async for message in websocket : print ( f \"Received: { message } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Create WebSocket connection : Connect to the Solana WebSocket endpoint Subscribe to account changes : Monitor changes to a specific account Subscribe to logs : Listen to transaction logs Process messages : Handle incoming event messages Subscription Types account_subscribe : Monitor account data changes logs_subscribe : Listen to transaction logs program_subscribe : Monitor program account changes signature_subscribe : Track transaction confirmations slot_subscribe : Monitor slot changes Key Concepts Real-time updates : WebSocket provides real-time blockchain data Event-driven : React to blockchain events as they happen Asynchronous : Use async/await for non-blocking operations Usage python subscribing_to_events.py The script will run continuously, printing events as they occur. Network Endpoints Devnet : wss://api.devnet.solana.com Testnet : wss://api.testnet.solana.com Mainnet : wss://api.mainnet-beta.solana.com","title":"Subscribing to Events"},{"location":"cookbook/development-guides/subscribing-to-events/#subscribing-to-events","text":"This example demonstrates how to subscribe to Solana blockchain events using WebSocket connections.","title":"Subscribing to Events"},{"location":"cookbook/development-guides/subscribing-to-events/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - Subscribing to Events \"\"\" import asyncio from solana.rpc.websocket_api import connect from solders.keypair import Keypair async def main (): keypair = Keypair () async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : # Subscribe to account changes await websocket . account_subscribe ( keypair . pubkey ()) # Subscribe to logs await websocket . logs_subscribe () # Listen for messages async for message in websocket : print ( f \"Received: { message } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/development-guides/subscribing-to-events/#explanation","text":"Create WebSocket connection : Connect to the Solana WebSocket endpoint Subscribe to account changes : Monitor changes to a specific account Subscribe to logs : Listen to transaction logs Process messages : Handle incoming event messages","title":"Explanation"},{"location":"cookbook/development-guides/subscribing-to-events/#subscription-types","text":"account_subscribe : Monitor account data changes logs_subscribe : Listen to transaction logs program_subscribe : Monitor program account changes signature_subscribe : Track transaction confirmations slot_subscribe : Monitor slot changes","title":"Subscription Types"},{"location":"cookbook/development-guides/subscribing-to-events/#key-concepts","text":"Real-time updates : WebSocket provides real-time blockchain data Event-driven : React to blockchain events as they happen Asynchronous : Use async/await for non-blocking operations","title":"Key Concepts"},{"location":"cookbook/development-guides/subscribing-to-events/#usage","text":"python subscribing_to_events.py The script will run continuously, printing events as they occur.","title":"Usage"},{"location":"cookbook/development-guides/subscribing-to-events/#network-endpoints","text":"Devnet : wss://api.devnet.solana.com Testnet : wss://api.testnet.solana.com Mainnet : wss://api.mainnet-beta.solana.com","title":"Network Endpoints"},{"location":"cookbook/token-operations/burn-tokens/","text":"Burn Tokens Burn a specified amount of SPL tokens, reducing the total supply. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Burn Tokens \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import burn , BurnParams from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () owner = Keypair () mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) token_account = Pubkey . from_string ( \"GfVPzUxMDvhFJ1Xs6C9i47XQRSapTd8LHw5grGuTquyQ\" ) # Amount to burn (in smallest unit) amount_to_burn = 500000000 # 0.5 tokens with 9 decimals async with rpc : # Create burn instruction burn_instruction = burn ( BurnParams ( program_id = TOKEN_PROGRAM_ID , account = token_account , mint = mint_address , owner = owner . pubkey (), amount = amount_to_burn ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ burn_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash , ) # Create and sign transaction transaction = VersionedTransaction ( message , [ payer , owner ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to burn SPL tokens: Set Parameters : Define the payer, token owner, mint address, and token account Create Burn Instruction : Use the burn() function to create a burn instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution Key Concepts Token Owner : The owner of the token account, only the owner can burn their tokens Token Account : The account containing the tokens to be burned Mint Address : The mint address of the token, used to identify the token type Burn Amount : The amount of tokens to burn, calculated in the smallest unit Usage Set the token account owner as owner Specify the token_account containing tokens to burn Specify the token's mint_address Set the amount of tokens to burn (pay attention to decimal places) Run the script to execute the burn operation Important Notes Only the token account owner can burn tokens The burn operation is irreversible, tokens are permanently removed from the total supply The burn amount cannot exceed the token balance in the account Sufficient SOL is required to pay transaction fees Burned tokens cannot be recovered","title":"Burn Tokens"},{"location":"cookbook/token-operations/burn-tokens/#burn-tokens","text":"Burn a specified amount of SPL tokens, reducing the total supply.","title":"Burn Tokens"},{"location":"cookbook/token-operations/burn-tokens/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Burn Tokens \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import burn , BurnParams from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () owner = Keypair () mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) token_account = Pubkey . from_string ( \"GfVPzUxMDvhFJ1Xs6C9i47XQRSapTd8LHw5grGuTquyQ\" ) # Amount to burn (in smallest unit) amount_to_burn = 500000000 # 0.5 tokens with 9 decimals async with rpc : # Create burn instruction burn_instruction = burn ( BurnParams ( program_id = TOKEN_PROGRAM_ID , account = token_account , mint = mint_address , owner = owner . pubkey (), amount = amount_to_burn ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ burn_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash , ) # Create and sign transaction transaction = VersionedTransaction ( message , [ payer , owner ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/burn-tokens/#code-explanation","text":"This example shows how to burn SPL tokens: Set Parameters : Define the payer, token owner, mint address, and token account Create Burn Instruction : Use the burn() function to create a burn instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution","title":"Code Explanation"},{"location":"cookbook/token-operations/burn-tokens/#key-concepts","text":"Token Owner : The owner of the token account, only the owner can burn their tokens Token Account : The account containing the tokens to be burned Mint Address : The mint address of the token, used to identify the token type Burn Amount : The amount of tokens to burn, calculated in the smallest unit","title":"Key Concepts"},{"location":"cookbook/token-operations/burn-tokens/#usage","text":"Set the token account owner as owner Specify the token_account containing tokens to burn Specify the token's mint_address Set the amount of tokens to burn (pay attention to decimal places) Run the script to execute the burn operation","title":"Usage"},{"location":"cookbook/token-operations/burn-tokens/#important-notes","text":"Only the token account owner can burn tokens The burn operation is irreversible, tokens are permanently removed from the total supply The burn amount cannot exceed the token balance in the account Sufficient SOL is required to pay transaction fees Burned tokens cannot be recovered","title":"Important Notes"},{"location":"cookbook/token-operations/close-token-account/","text":"Close Token Account Close a token account and recover the rent. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Close Token Accounts \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import close_account , CloseAccountParams from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () owner = Keypair () token_account = Pubkey . from_string ( \"GfVPzUxMDvhFJ1Xs6C9i47XQRSapTd8LHw5grGuTquyQ\" ) # Account to receive the remaining lamports (usually the owner) destination = owner . pubkey () async with rpc : # Create close account instruction close_instruction = close_account ( CloseAccountParams ( program_id = TOKEN_PROGRAM_ID , account = token_account , dest = destination , owner = owner . pubkey () ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ close_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer , owner ]) print ( f \"Token Account: { token_account } \" ) print ( f \"Owner: { owner . pubkey () } \" ) print ( f \"Destination: { destination } \" ) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to close a token account: Set Parameters : Define the payer, token account owner, and token account to close Specify Destination : Set the destination account to receive the rent (usually the owner) Create Close Instruction : Use close_account() to create the close account instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution Key Concepts Token Account : The token account to be closed Owner : The owner of the token account, only the owner can close the account Destination : The destination account to receive the account rent Rent : The rent paid when creating the account, which can be recovered when closing the account Usage Ensure the token account has zero balance (transfer any balance first if needed) Set the token account owner as owner Specify the token_account to close Set the destination account to receive the rent Run the script to execute the close operation Important Notes Only the token account owner can close the account The token account must have zero balance to be closed After closing the account, the rent stored in the account is returned to the specified destination account The closed account address can be reused Sufficient SOL is required to pay transaction fees","title":"Close Token Account"},{"location":"cookbook/token-operations/close-token-account/#close-token-account","text":"Close a token account and recover the rent.","title":"Close Token Account"},{"location":"cookbook/token-operations/close-token-account/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Close Token Accounts \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import close_account , CloseAccountParams from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () owner = Keypair () token_account = Pubkey . from_string ( \"GfVPzUxMDvhFJ1Xs6C9i47XQRSapTd8LHw5grGuTquyQ\" ) # Account to receive the remaining lamports (usually the owner) destination = owner . pubkey () async with rpc : # Create close account instruction close_instruction = close_account ( CloseAccountParams ( program_id = TOKEN_PROGRAM_ID , account = token_account , dest = destination , owner = owner . pubkey () ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ close_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer , owner ]) print ( f \"Token Account: { token_account } \" ) print ( f \"Owner: { owner . pubkey () } \" ) print ( f \"Destination: { destination } \" ) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/close-token-account/#code-explanation","text":"This example shows how to close a token account: Set Parameters : Define the payer, token account owner, and token account to close Specify Destination : Set the destination account to receive the rent (usually the owner) Create Close Instruction : Use close_account() to create the close account instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution","title":"Code Explanation"},{"location":"cookbook/token-operations/close-token-account/#key-concepts","text":"Token Account : The token account to be closed Owner : The owner of the token account, only the owner can close the account Destination : The destination account to receive the account rent Rent : The rent paid when creating the account, which can be recovered when closing the account","title":"Key Concepts"},{"location":"cookbook/token-operations/close-token-account/#usage","text":"Ensure the token account has zero balance (transfer any balance first if needed) Set the token account owner as owner Specify the token_account to close Set the destination account to receive the rent Run the script to execute the close operation","title":"Usage"},{"location":"cookbook/token-operations/close-token-account/#important-notes","text":"Only the token account owner can close the account The token account must have zero balance to be closed After closing the account, the rent stored in the account is returned to the specified destination account The closed account address can be reused Sufficient SOL is required to pay transaction fees","title":"Important Notes"},{"location":"cookbook/token-operations/create-token-account/","text":"Create Token Account This example shows how to create an associated token account for a specific token mint. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create a Token Account \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import create_associated_token_account , get_associated_token_address from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) payer = Keypair () owner = Keypair () # Example mint address mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) # Get associated token account address associated_token_account = get_associated_token_address ( owner . pubkey (), mint_address ) async with rpc : # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create associated token account instruction create_token_account_instruction = create_associated_token_account ( payer = payer . pubkey (), owner = owner . pubkey (), mint = mint_address , token_program_id = TOKEN_PROGRAM_ID ) # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ create_token_account_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer ]) print ( f \"Payer: { payer . pubkey () } \" ) print ( f \"Owner: { owner . pubkey () } \" ) print ( f \"Mint: { mint_address } \" ) print ( f \"Associated Token Account: { associated_token_account } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Get ATA address : Use get_associated_token_address() to find the associated token account address Create instruction : Build the instruction to create the associated token account Build transaction : Compile the instruction into a transaction Sign transaction : Sign with the payer keypair Key Concepts Associated Token Account (ATA) : A deterministic token account address for each owner-mint pair Payer : The account that pays for the transaction and rent Owner : The account that owns the token account Mint : The token type this account will hold Usage python create_token_account.py This will output: Payer: 5J8...abc Owner: 3Kd...def Mint: 4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU Associated Token Account: 7Nm...xyz","title":"Create Token Account"},{"location":"cookbook/token-operations/create-token-account/#create-token-account","text":"This example shows how to create an associated token account for a specific token mint.","title":"Create Token Account"},{"location":"cookbook/token-operations/create-token-account/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create a Token Account \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import create_associated_token_account , get_associated_token_address from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) payer = Keypair () owner = Keypair () # Example mint address mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) # Get associated token account address associated_token_account = get_associated_token_address ( owner . pubkey (), mint_address ) async with rpc : # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create associated token account instruction create_token_account_instruction = create_associated_token_account ( payer = payer . pubkey (), owner = owner . pubkey (), mint = mint_address , token_program_id = TOKEN_PROGRAM_ID ) # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ create_token_account_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer ]) print ( f \"Payer: { payer . pubkey () } \" ) print ( f \"Owner: { owner . pubkey () } \" ) print ( f \"Mint: { mint_address } \" ) print ( f \"Associated Token Account: { associated_token_account } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/token-operations/create-token-account/#explanation","text":"Get ATA address : Use get_associated_token_address() to find the associated token account address Create instruction : Build the instruction to create the associated token account Build transaction : Compile the instruction into a transaction Sign transaction : Sign with the payer keypair","title":"Explanation"},{"location":"cookbook/token-operations/create-token-account/#key-concepts","text":"Associated Token Account (ATA) : A deterministic token account address for each owner-mint pair Payer : The account that pays for the transaction and rent Owner : The account that owns the token account Mint : The token type this account will hold","title":"Key Concepts"},{"location":"cookbook/token-operations/create-token-account/#usage","text":"python create_token_account.py This will output: Payer: 5J8...abc Owner: 3Kd...def Mint: 4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU Associated Token Account: 7Nm...xyz","title":"Usage"},{"location":"cookbook/token-operations/create-token/","text":"Create Token This example demonstrates how to create a new SPL token on the Solana blockchain. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create a Token \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import initialize_mint , InitializeMintParams from spl.token.constants import TOKEN_PROGRAM_ID from solders.system_program import create_account , CreateAccountParams async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) fee_payer = Keypair () mint = Keypair () space = 82 # getMintSize() equivalent decimals = 9 async with rpc : # Get minimum balance for rent exemption rent = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Create account instruction create_account_instruction = create_account ( CreateAccountParams ( from_pubkey = fee_payer . pubkey (), to_pubkey = mint . pubkey (), lamports = rent . value , space = space , owner = TOKEN_PROGRAM_ID ) ) # Initialize mint instruction initialize_mint_instruction = initialize_mint ( InitializeMintParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), decimals = decimals , mint_authority = fee_payer . pubkey (), freeze_authority = None # No freeze authority ) ) instructions = [ create_account_instruction , initialize_mint_instruction ] # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create message transaction_message = MessageV0 . try_compile ( payer = fee_payer . pubkey (), instructions = instructions , address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash , ) # Create versioned transaction transaction = VersionedTransaction ( transaction_message , [ fee_payer , mint ]) print ( f \"Mint address: { mint . pubkey () } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Set up keypairs : Create keypairs for the fee payer and the mint account Define parameters : Set the account space (82 bytes for a mint) and decimals (9 for standard tokens) Calculate rent : Get the minimum balance required for rent exemption Create account : Create the account instruction to allocate space for the mint Initialize mint : Initialize the mint with the specified parameters Build transaction : Compile the instructions into a versioned transaction Sign transaction : Sign with both the fee payer and mint keypairs Key Concepts Mint Account : The account that defines a token type and controls token supply Decimals : Number of decimal places for the token (9 is standard for most tokens) Rent Exemption : Accounts must hold enough SOL to be exempt from rent collection Authority : The account that has permission to mint tokens Usage python create_token.py This will output the mint address of your newly created token. Prerequisites You'll need SOL in your fee payer account to pay for transaction fees Make sure you're connected to devnet for testing","title":"Create Token"},{"location":"cookbook/token-operations/create-token/#create-token","text":"This example demonstrates how to create a new SPL token on the Solana blockchain.","title":"Create Token"},{"location":"cookbook/token-operations/create-token/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create a Token \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import initialize_mint , InitializeMintParams from spl.token.constants import TOKEN_PROGRAM_ID from solders.system_program import create_account , CreateAccountParams async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) fee_payer = Keypair () mint = Keypair () space = 82 # getMintSize() equivalent decimals = 9 async with rpc : # Get minimum balance for rent exemption rent = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Create account instruction create_account_instruction = create_account ( CreateAccountParams ( from_pubkey = fee_payer . pubkey (), to_pubkey = mint . pubkey (), lamports = rent . value , space = space , owner = TOKEN_PROGRAM_ID ) ) # Initialize mint instruction initialize_mint_instruction = initialize_mint ( InitializeMintParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), decimals = decimals , mint_authority = fee_payer . pubkey (), freeze_authority = None # No freeze authority ) ) instructions = [ create_account_instruction , initialize_mint_instruction ] # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create message transaction_message = MessageV0 . try_compile ( payer = fee_payer . pubkey (), instructions = instructions , address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash , ) # Create versioned transaction transaction = VersionedTransaction ( transaction_message , [ fee_payer , mint ]) print ( f \"Mint address: { mint . pubkey () } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/token-operations/create-token/#explanation","text":"Set up keypairs : Create keypairs for the fee payer and the mint account Define parameters : Set the account space (82 bytes for a mint) and decimals (9 for standard tokens) Calculate rent : Get the minimum balance required for rent exemption Create account : Create the account instruction to allocate space for the mint Initialize mint : Initialize the mint with the specified parameters Build transaction : Compile the instructions into a versioned transaction Sign transaction : Sign with both the fee payer and mint keypairs","title":"Explanation"},{"location":"cookbook/token-operations/create-token/#key-concepts","text":"Mint Account : The account that defines a token type and controls token supply Decimals : Number of decimal places for the token (9 is standard for most tokens) Rent Exemption : Accounts must hold enough SOL to be exempt from rent collection Authority : The account that has permission to mint tokens","title":"Key Concepts"},{"location":"cookbook/token-operations/create-token/#usage","text":"python create_token.py This will output the mint address of your newly created token.","title":"Usage"},{"location":"cookbook/token-operations/create-token/#prerequisites","text":"You'll need SOL in your fee payer account to pay for transaction fees Make sure you're connected to devnet for testing","title":"Prerequisites"},{"location":"cookbook/token-operations/delegate-token-account/","text":"Delegate Token Account Delegate a token account to another account, allowing it to operate tokens within a specified amount range. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Delegate Token Accounts \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.system_program import create_account , CreateAccountParams from spl.token.instructions import ( initialize_mint , InitializeMintParams , create_associated_token_account , mint_to_checked , MintToCheckedParams , approve_checked , ApproveCheckedParams , get_associated_token_address ) from spl.token.constants import TOKEN_PROGRAM_ID , ASSOCIATED_TOKEN_PROGRAM_ID # Constants DECIMALS = 9 async def setup ( rpc , mint_authority ): \"\"\" The setup function initializes the mint and associated token accounts, and mints tokens to said associated token account \"\"\" mint = Keypair () space = 82 # getMintSize() equivalent for SPL Token # Get minimum balance for rent exemption rent = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Create & initialize mint account create_account_instruction = create_account ( CreateAccountParams ( from_pubkey = mint_authority . pubkey (), to_pubkey = mint . pubkey (), lamports = rent . value , space = space , owner = TOKEN_PROGRAM_ID ) ) initialize_mint_instruction = initialize_mint ( InitializeMintParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), decimals = DECIMALS , mint_authority = mint_authority . pubkey (), freeze_authority = None ) ) # Create associated token account authority_ata = get_associated_token_address ( owner = mint_authority . pubkey (), mint = mint . pubkey (), token_program_id = TOKEN_PROGRAM_ID ) create_ata_instruction = create_associated_token_account ( payer = mint_authority . pubkey (), owner = mint_authority . pubkey (), mint = mint . pubkey (), token_program_id = TOKEN_PROGRAM_ID , associated_token_program_id = ASSOCIATED_TOKEN_PROGRAM_ID ) # Mint tokens to ATA mint_to_instruction = mint_to_checked ( MintToCheckedParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), dest = authority_ata , mint_authority = mint_authority . pubkey (), amount = 100 * ( 10 ** DECIMALS ), # 100 tokens decimals = DECIMALS ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = mint_authority . pubkey (), instructions = [ create_account_instruction , initialize_mint_instruction , create_ata_instruction , mint_to_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ mint_authority , mint ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Setup transaction signature: { result . value } \" ) return mint . pubkey (), authority_ata async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Create keypairs payer = Keypair () mint_authority = Keypair () delegate = Keypair () async with rpc : # Setup mint and token account mint_pubkey , token_account = await setup ( rpc , mint_authority ) # Delegate amount (50 tokens) delegate_amount = 50 * ( 10 ** DECIMALS ) # Create approval instruction approve_instruction = approve_checked ( ApproveCheckedParams ( program_id = TOKEN_PROGRAM_ID , source = token_account , mint = mint_pubkey , delegate = delegate . pubkey (), owner = mint_authority . pubkey (), amount = delegate_amount , decimals = DECIMALS ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ approve_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer , mint_authority ]) print ( f \"Token Account: { token_account } \" ) print ( f \"Delegate: { delegate . pubkey () } \" ) print ( f \"Delegated Amount: { delegate_amount / ( 10 ** DECIMALS ) } tokens\" ) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Delegate transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to delegate a token account: Setup Phase : Create token mint, associated token account, and mint tokens Delegation Operation : Use approve_checked() to delegate permissions to a specified account Permission Scope : Delegate token operation permissions for a specified amount Send Transaction : Send the delegation instruction to the network for execution Key Concepts Token Delegation : Allows other accounts to operate tokens within a specified amount range Delegate : The delegated account that can transfer or operate the delegated tokens Approved Amount : The upper limit of delegated token amount Approve Checked : A safer delegation method that verifies token type and decimal places Usage Set the token account owner as the delegator Specify the delegate account to receive permissions Set the token amount limit for delegation Use approve_checked() to create the delegation instruction Run the script to execute the delegation operation Important Notes Delegation does not transfer token ownership, it only authorizes operations Delegation has amount limits, operations exceeding the limit will fail Delegation can be revoked or reset The delegated account can perform operations like transfers Sufficient SOL is required to pay transaction fees Use Cases for Delegation DeFi Protocols : Allow protocols to operate tokens under user authorization Automated Trading : Delegate to trading bots for automatic trading Payment Gateways : Allow third parties to process payments Multi-signature : Use in multi-signature schemes Security Considerations Only delegate to trusted accounts or programs Set appropriate delegation amount limits Regularly check and manage delegation permissions Revoke delegation promptly when no longer needed","title":"Delegate Token Account"},{"location":"cookbook/token-operations/delegate-token-account/#delegate-token-account","text":"Delegate a token account to another account, allowing it to operate tokens within a specified amount range.","title":"Delegate Token Account"},{"location":"cookbook/token-operations/delegate-token-account/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Delegate Token Accounts \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.system_program import create_account , CreateAccountParams from spl.token.instructions import ( initialize_mint , InitializeMintParams , create_associated_token_account , mint_to_checked , MintToCheckedParams , approve_checked , ApproveCheckedParams , get_associated_token_address ) from spl.token.constants import TOKEN_PROGRAM_ID , ASSOCIATED_TOKEN_PROGRAM_ID # Constants DECIMALS = 9 async def setup ( rpc , mint_authority ): \"\"\" The setup function initializes the mint and associated token accounts, and mints tokens to said associated token account \"\"\" mint = Keypair () space = 82 # getMintSize() equivalent for SPL Token # Get minimum balance for rent exemption rent = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Create & initialize mint account create_account_instruction = create_account ( CreateAccountParams ( from_pubkey = mint_authority . pubkey (), to_pubkey = mint . pubkey (), lamports = rent . value , space = space , owner = TOKEN_PROGRAM_ID ) ) initialize_mint_instruction = initialize_mint ( InitializeMintParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), decimals = DECIMALS , mint_authority = mint_authority . pubkey (), freeze_authority = None ) ) # Create associated token account authority_ata = get_associated_token_address ( owner = mint_authority . pubkey (), mint = mint . pubkey (), token_program_id = TOKEN_PROGRAM_ID ) create_ata_instruction = create_associated_token_account ( payer = mint_authority . pubkey (), owner = mint_authority . pubkey (), mint = mint . pubkey (), token_program_id = TOKEN_PROGRAM_ID , associated_token_program_id = ASSOCIATED_TOKEN_PROGRAM_ID ) # Mint tokens to ATA mint_to_instruction = mint_to_checked ( MintToCheckedParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), dest = authority_ata , mint_authority = mint_authority . pubkey (), amount = 100 * ( 10 ** DECIMALS ), # 100 tokens decimals = DECIMALS ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = mint_authority . pubkey (), instructions = [ create_account_instruction , initialize_mint_instruction , create_ata_instruction , mint_to_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ mint_authority , mint ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Setup transaction signature: { result . value } \" ) return mint . pubkey (), authority_ata async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Create keypairs payer = Keypair () mint_authority = Keypair () delegate = Keypair () async with rpc : # Setup mint and token account mint_pubkey , token_account = await setup ( rpc , mint_authority ) # Delegate amount (50 tokens) delegate_amount = 50 * ( 10 ** DECIMALS ) # Create approval instruction approve_instruction = approve_checked ( ApproveCheckedParams ( program_id = TOKEN_PROGRAM_ID , source = token_account , mint = mint_pubkey , delegate = delegate . pubkey (), owner = mint_authority . pubkey (), amount = delegate_amount , decimals = DECIMALS ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ approve_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer , mint_authority ]) print ( f \"Token Account: { token_account } \" ) print ( f \"Delegate: { delegate . pubkey () } \" ) print ( f \"Delegated Amount: { delegate_amount / ( 10 ** DECIMALS ) } tokens\" ) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Delegate transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/delegate-token-account/#code-explanation","text":"This example shows how to delegate a token account: Setup Phase : Create token mint, associated token account, and mint tokens Delegation Operation : Use approve_checked() to delegate permissions to a specified account Permission Scope : Delegate token operation permissions for a specified amount Send Transaction : Send the delegation instruction to the network for execution","title":"Code Explanation"},{"location":"cookbook/token-operations/delegate-token-account/#key-concepts","text":"Token Delegation : Allows other accounts to operate tokens within a specified amount range Delegate : The delegated account that can transfer or operate the delegated tokens Approved Amount : The upper limit of delegated token amount Approve Checked : A safer delegation method that verifies token type and decimal places","title":"Key Concepts"},{"location":"cookbook/token-operations/delegate-token-account/#usage","text":"Set the token account owner as the delegator Specify the delegate account to receive permissions Set the token amount limit for delegation Use approve_checked() to create the delegation instruction Run the script to execute the delegation operation","title":"Usage"},{"location":"cookbook/token-operations/delegate-token-account/#important-notes","text":"Delegation does not transfer token ownership, it only authorizes operations Delegation has amount limits, operations exceeding the limit will fail Delegation can be revoked or reset The delegated account can perform operations like transfers Sufficient SOL is required to pay transaction fees","title":"Important Notes"},{"location":"cookbook/token-operations/delegate-token-account/#use-cases-for-delegation","text":"DeFi Protocols : Allow protocols to operate tokens under user authorization Automated Trading : Delegate to trading bots for automatic trading Payment Gateways : Allow third parties to process payments Multi-signature : Use in multi-signature schemes","title":"Use Cases for Delegation"},{"location":"cookbook/token-operations/delegate-token-account/#security-considerations","text":"Only delegate to trusted accounts or programs Set appropriate delegation amount limits Regularly check and manage delegation permissions Revoke delegation promptly when no longer needed","title":"Security Considerations"},{"location":"cookbook/token-operations/get-all-token-accounts-by-owner/","text":"Get All Token Accounts by Owner Get all token accounts for a specified owner. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get All Token Accounts by Owner \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey from spl.token.constants import TOKEN_PROGRAM_ID from solana.rpc.types import TokenAccountOpts async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example owner address owner = Pubkey . from_string ( \"4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF\" ) async with rpc : try : # Get all token accounts by owner response = await rpc . get_token_accounts_by_owner ( owner , TokenAccountOpts ( program_id = TOKEN_PROGRAM_ID ) ) print ( f \"Owner: { owner } \" ) print ( f \"Found { len ( response . value ) } token accounts: \\n \" ) for account_info in response . value : print ( f \"Pubkey: { account_info . pubkey } \" ) print ( f \"Owner: { account_info . account . owner } \" ) print ( f \"Lamports: { account_info . account . lamports } \" ) print ( f \"Data Length: { len ( account_info . account . data ) } bytes\" ) print ( \"=\" * 50 ) except Exception as e : print ( f \"Error getting token accounts: { e } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to get all token accounts for a specified owner: Set Owner : Specify the wallet address to query Configure Query Parameters : Use TokenAccountOpts to specify the Token program ID Execute Query : Call the get_token_accounts_by_owner() method Process Results : Iterate through and display information for each token account Key Concepts Token Account Owner : The owner of the token account, usually the user's wallet address Token Program ID : The identifier for the SPL Token program Account Info : Contains account public key, owner, balance, and other information Lamports : The SOL balance in the account (calculated in smallest units) Usage Replace owner with the wallet address you want to query Run the script to get all token accounts for that address View the returned account information, including public key, owner, and balance Important Notes Returns all token accounts, regardless of token type The data length of each account can help determine the account type Empty token accounts are also included in the results Network connection exceptions will throw corresponding errors Extended Functionality You can further parse account data to get more detailed information: # Parse token account data from spl.token.layouts import ACCOUNT_LAYOUT def parse_token_account ( account_data ): decoded = ACCOUNT_LAYOUT . parse ( account_data ) return { 'mint' : decoded . mint , 'owner' : decoded . owner , 'amount' : decoded . amount , 'delegate' : decoded . delegate , 'state' : decoded . state , 'is_native' : decoded . is_native , 'delegated_amount' : decoded . delegated_amount , 'close_authority' : decoded . close_authority }","title":"Get All Token Accounts by Owner"},{"location":"cookbook/token-operations/get-all-token-accounts-by-owner/#get-all-token-accounts-by-owner","text":"Get all token accounts for a specified owner.","title":"Get All Token Accounts by Owner"},{"location":"cookbook/token-operations/get-all-token-accounts-by-owner/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get All Token Accounts by Owner \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey from spl.token.constants import TOKEN_PROGRAM_ID from solana.rpc.types import TokenAccountOpts async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example owner address owner = Pubkey . from_string ( \"4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF\" ) async with rpc : try : # Get all token accounts by owner response = await rpc . get_token_accounts_by_owner ( owner , TokenAccountOpts ( program_id = TOKEN_PROGRAM_ID ) ) print ( f \"Owner: { owner } \" ) print ( f \"Found { len ( response . value ) } token accounts: \\n \" ) for account_info in response . value : print ( f \"Pubkey: { account_info . pubkey } \" ) print ( f \"Owner: { account_info . account . owner } \" ) print ( f \"Lamports: { account_info . account . lamports } \" ) print ( f \"Data Length: { len ( account_info . account . data ) } bytes\" ) print ( \"=\" * 50 ) except Exception as e : print ( f \"Error getting token accounts: { e } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/get-all-token-accounts-by-owner/#code-explanation","text":"This example shows how to get all token accounts for a specified owner: Set Owner : Specify the wallet address to query Configure Query Parameters : Use TokenAccountOpts to specify the Token program ID Execute Query : Call the get_token_accounts_by_owner() method Process Results : Iterate through and display information for each token account","title":"Code Explanation"},{"location":"cookbook/token-operations/get-all-token-accounts-by-owner/#key-concepts","text":"Token Account Owner : The owner of the token account, usually the user's wallet address Token Program ID : The identifier for the SPL Token program Account Info : Contains account public key, owner, balance, and other information Lamports : The SOL balance in the account (calculated in smallest units)","title":"Key Concepts"},{"location":"cookbook/token-operations/get-all-token-accounts-by-owner/#usage","text":"Replace owner with the wallet address you want to query Run the script to get all token accounts for that address View the returned account information, including public key, owner, and balance","title":"Usage"},{"location":"cookbook/token-operations/get-all-token-accounts-by-owner/#important-notes","text":"Returns all token accounts, regardless of token type The data length of each account can help determine the account type Empty token accounts are also included in the results Network connection exceptions will throw corresponding errors","title":"Important Notes"},{"location":"cookbook/token-operations/get-all-token-accounts-by-owner/#extended-functionality","text":"You can further parse account data to get more detailed information: # Parse token account data from spl.token.layouts import ACCOUNT_LAYOUT def parse_token_account ( account_data ): decoded = ACCOUNT_LAYOUT . parse ( account_data ) return { 'mint' : decoded . mint , 'owner' : decoded . owner , 'amount' : decoded . amount , 'delegate' : decoded . delegate , 'state' : decoded . state , 'is_native' : decoded . is_native , 'delegated_amount' : decoded . delegated_amount , 'close_authority' : decoded . close_authority }","title":"Extended Functionality"},{"location":"cookbook/token-operations/get-token-account/","text":"Get Token Account This example shows how to retrieve information about a token account. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get a Token Account \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey from spl.token.instructions import get_associated_token_address from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example mint and authority addresses mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) authority = Pubkey . from_string ( \"AC5RDfQFmDS1deWZos921JfqscXdByf8BKHs5ACWjtW2\" ) # Find associated token address associated_token_address = get_associated_token_address ( owner = authority , mint = mint_address , token_program_id = TOKEN_PROGRAM_ID ) async with rpc : try : # Get token account info account_info = await rpc . get_account_info ( associated_token_address ) print ( f \"Associated Token Address: { associated_token_address } \" ) if account_info . value : print ( f \"Owner: { account_info . value . owner } \" ) print ( f \"Lamports: { account_info . value . lamports } \" ) print ( f \"Data Length: { len ( account_info . value . data ) } bytes\" ) print ( f \"Executable: { account_info . value . executable } \" ) else : print ( \"Token account not found\" ) except Exception as e : print ( f \"Error getting token account info: { e } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Calculate ATA address : Use get_associated_token_address() to find the token account address Get account info : Retrieve the account information from the blockchain Display information : Show the account details if it exists Key Concepts Associated Token Account : A deterministic account address for holding tokens Account info : Contains owner, lamports, data, and executable flag Token account existence : Accounts must be created before they can hold tokens Usage python get_token_account.py This will output: Associated Token Address: 7Nm...xyz Owner: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA Lamports: 2039280 Data Length: 165 bytes Executable: False Error Handling If the token account doesn't exist, you'll see: Associated Token Address: 7Nm...xyz Token account not found","title":"Get Token Account"},{"location":"cookbook/token-operations/get-token-account/#get-token-account","text":"This example shows how to retrieve information about a token account.","title":"Get Token Account"},{"location":"cookbook/token-operations/get-token-account/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get a Token Account \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey from spl.token.instructions import get_associated_token_address from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example mint and authority addresses mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) authority = Pubkey . from_string ( \"AC5RDfQFmDS1deWZos921JfqscXdByf8BKHs5ACWjtW2\" ) # Find associated token address associated_token_address = get_associated_token_address ( owner = authority , mint = mint_address , token_program_id = TOKEN_PROGRAM_ID ) async with rpc : try : # Get token account info account_info = await rpc . get_account_info ( associated_token_address ) print ( f \"Associated Token Address: { associated_token_address } \" ) if account_info . value : print ( f \"Owner: { account_info . value . owner } \" ) print ( f \"Lamports: { account_info . value . lamports } \" ) print ( f \"Data Length: { len ( account_info . value . data ) } bytes\" ) print ( f \"Executable: { account_info . value . executable } \" ) else : print ( \"Token account not found\" ) except Exception as e : print ( f \"Error getting token account info: { e } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/token-operations/get-token-account/#explanation","text":"Calculate ATA address : Use get_associated_token_address() to find the token account address Get account info : Retrieve the account information from the blockchain Display information : Show the account details if it exists","title":"Explanation"},{"location":"cookbook/token-operations/get-token-account/#key-concepts","text":"Associated Token Account : A deterministic account address for holding tokens Account info : Contains owner, lamports, data, and executable flag Token account existence : Accounts must be created before they can hold tokens","title":"Key Concepts"},{"location":"cookbook/token-operations/get-token-account/#usage","text":"python get_token_account.py This will output: Associated Token Address: 7Nm...xyz Owner: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA Lamports: 2039280 Data Length: 165 bytes Executable: False","title":"Usage"},{"location":"cookbook/token-operations/get-token-account/#error-handling","text":"If the token account doesn't exist, you'll see: Associated Token Address: 7Nm...xyz Token account not found","title":"Error Handling"},{"location":"cookbook/token-operations/get-token-balance/","text":"Get Token Balance Get the balance information for a specified token account. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get a Token Account's Balance \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey async def main (): rpc = AsyncClient ( \"https://api.mainnet-beta.solana.com\" ) # Use a real token account address from mainnet token_account_address = Pubkey . from_string ( \"GfVPzUxMDvhFJ1Xs6C9i47XQRSapTd8LHw5grGuTquyQ\" ) async with rpc : try : balance = await rpc . get_token_account_balance ( token_account_address ) print ( balance ) except Exception as e : print ( f \"Error getting token balance: { e } \" ) print ( \"This might be because the account doesn't exist or isn't a token account\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to get the balance of a token account: Connect to RPC : Use AsyncClient to connect to the Solana network Specify Token Account : Use Pubkey.from_string() to create the token account public key Get Balance : Call the get_token_account_balance() method to get balance information Error Handling : Catch possible exceptions, such as account not existing or not being a token account Key Concepts Token Account : An account that stores a specific SPL token Balance : Contains information such as token amount and decimal places RPC Method : get_token_account_balance is used to query token account balance Usage Replace token_account_address with the token account address you want to query Run the script to get the balance information for that account The returned result contains detailed information such as token amount and decimal places Important Notes Ensure the provided address is a valid token account address The account must exist and contain token data Network connection exceptions will throw corresponding errors","title":"Get Token Balance"},{"location":"cookbook/token-operations/get-token-balance/#get-token-balance","text":"Get the balance information for a specified token account.","title":"Get Token Balance"},{"location":"cookbook/token-operations/get-token-balance/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get a Token Account's Balance \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey async def main (): rpc = AsyncClient ( \"https://api.mainnet-beta.solana.com\" ) # Use a real token account address from mainnet token_account_address = Pubkey . from_string ( \"GfVPzUxMDvhFJ1Xs6C9i47XQRSapTd8LHw5grGuTquyQ\" ) async with rpc : try : balance = await rpc . get_token_account_balance ( token_account_address ) print ( balance ) except Exception as e : print ( f \"Error getting token balance: { e } \" ) print ( \"This might be because the account doesn't exist or isn't a token account\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/get-token-balance/#code-explanation","text":"This example shows how to get the balance of a token account: Connect to RPC : Use AsyncClient to connect to the Solana network Specify Token Account : Use Pubkey.from_string() to create the token account public key Get Balance : Call the get_token_account_balance() method to get balance information Error Handling : Catch possible exceptions, such as account not existing or not being a token account","title":"Code Explanation"},{"location":"cookbook/token-operations/get-token-balance/#key-concepts","text":"Token Account : An account that stores a specific SPL token Balance : Contains information such as token amount and decimal places RPC Method : get_token_account_balance is used to query token account balance","title":"Key Concepts"},{"location":"cookbook/token-operations/get-token-balance/#usage","text":"Replace token_account_address with the token account address you want to query Run the script to get the balance information for that account The returned result contains detailed information such as token amount and decimal places","title":"Usage"},{"location":"cookbook/token-operations/get-token-balance/#important-notes","text":"Ensure the provided address is a valid token account address The account must exist and contain token data Network connection exceptions will throw corresponding errors","title":"Important Notes"},{"location":"cookbook/token-operations/get-token-mint/","text":"Get Token Mint This example shows how to retrieve token mint information from a Solana token. Code #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get a Token Mint \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey from spl.token._layouts import MINT_LAYOUT from spl.token.core import MintInfo async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) async with rpc : # Get account info account_info = await rpc . get_account_info ( mint_address ) # Parse mint data using layout mint_data = MINT_LAYOUT . parse ( account_info . value . data ) # Create MintInfo object mint_info = MintInfo ( mint_authority = mint_data . mint_authority , supply = mint_data . supply , decimals = mint_data . decimals , is_initialized = mint_data . is_initialized , freeze_authority = mint_data . freeze_authority ) print ( f \"Mint Address: { mint_address } \" ) print ( f \"Decimals: { mint_info . decimals } \" ) print ( f \"Supply: { mint_info . supply } \" ) print ( f \"Is Initialized: { mint_info . is_initialized } \" ) print ( f \"Freeze Authority: { mint_info . freeze_authority } \" ) print ( f \"Mint Authority: { mint_info . mint_authority } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation Get account info : Retrieve the raw account data for the mint Parse mint data : Use the MINT_LAYOUT to parse the binary data Create MintInfo : Convert parsed data into a structured MintInfo object Display information : Show all the mint properties Key Concepts Mint account : Contains metadata about a token type Decimals : Number of decimal places for the token Supply : Total number of tokens in circulation Authorities : Accounts that can mint tokens or freeze accounts Initialization : Whether the mint has been properly set up Usage python get_token_mint.py This will output: Mint Address: 4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU Decimals: 6 Supply: 1000000000 Is Initialized: True Freeze Authority: None Mint Authority: AC5RDfQFmDS1deWZos921JfqscXdByf8BKHs5ACWjtW2","title":"Get Token Mint"},{"location":"cookbook/token-operations/get-token-mint/#get-token-mint","text":"This example shows how to retrieve token mint information from a Solana token.","title":"Get Token Mint"},{"location":"cookbook/token-operations/get-token-mint/#code","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Get a Token Mint \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey from spl.token._layouts import MINT_LAYOUT from spl.token.core import MintInfo async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) async with rpc : # Get account info account_info = await rpc . get_account_info ( mint_address ) # Parse mint data using layout mint_data = MINT_LAYOUT . parse ( account_info . value . data ) # Create MintInfo object mint_info = MintInfo ( mint_authority = mint_data . mint_authority , supply = mint_data . supply , decimals = mint_data . decimals , is_initialized = mint_data . is_initialized , freeze_authority = mint_data . freeze_authority ) print ( f \"Mint Address: { mint_address } \" ) print ( f \"Decimals: { mint_info . decimals } \" ) print ( f \"Supply: { mint_info . supply } \" ) print ( f \"Is Initialized: { mint_info . is_initialized } \" ) print ( f \"Freeze Authority: { mint_info . freeze_authority } \" ) print ( f \"Mint Authority: { mint_info . mint_authority } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code"},{"location":"cookbook/token-operations/get-token-mint/#explanation","text":"Get account info : Retrieve the raw account data for the mint Parse mint data : Use the MINT_LAYOUT to parse the binary data Create MintInfo : Convert parsed data into a structured MintInfo object Display information : Show all the mint properties","title":"Explanation"},{"location":"cookbook/token-operations/get-token-mint/#key-concepts","text":"Mint account : Contains metadata about a token type Decimals : Number of decimal places for the token Supply : Total number of tokens in circulation Authorities : Accounts that can mint tokens or freeze accounts Initialization : Whether the mint has been properly set up","title":"Key Concepts"},{"location":"cookbook/token-operations/get-token-mint/#usage","text":"python get_token_mint.py This will output: Mint Address: 4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU Decimals: 6 Supply: 1000000000 Is Initialized: True Freeze Authority: None Mint Authority: AC5RDfQFmDS1deWZos921JfqscXdByf8BKHs5ACWjtW2","title":"Usage"},{"location":"cookbook/token-operations/mint-tokens/","text":"Mint Tokens Mint new SPL tokens to a specified token account. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Mint Tokens \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import mint_to , MintToParams from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () mint_authority = Keypair () mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) destination_token_account = Pubkey . from_string ( \"GfVPzUxMDvhFJ1Xs6C9i47XQRSapTd8LHw5grGuTquyQ\" ) # Amount to mint (in smallest unit) amount_to_mint = 1000000000 # 1 token with 9 decimals async with rpc : # Create mint instruction mint_instruction = mint_to ( MintToParams ( program_id = TOKEN_PROGRAM_ID , mint = mint_address , dest = destination_token_account , mint_authority = mint_authority . pubkey (), amount = amount_to_mint ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ mint_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash , ) # Create and sign transaction transaction = VersionedTransaction ( message , [ payer , mint_authority ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to mint new SPL tokens: Set Parameters : Define the payer, mint authority, mint address, and destination token account Create Mint Instruction : Use the mint_to() function to create a mint instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution Key Concepts Mint Authority : The account with minting permissions, only this account can mint new tokens Mint Address : The mint address of the token, identifying a specific token type Token Account : The destination account to receive the minted tokens Amount : The mint amount, calculated in the token's smallest unit Usage Set the account with minting permissions as mint_authority Specify the mint_address of the token to be minted Specify the destination_token_account to receive the tokens Set the amount of tokens to mint (pay attention to decimal places) Run the script to execute the mint operation Important Notes Only accounts with minting permissions can execute mint operations The mint amount needs to consider the token's decimal places The destination account must be a token account for the corresponding token type Sufficient SOL is required to pay transaction fees","title":"Mint Tokens"},{"location":"cookbook/token-operations/mint-tokens/#mint-tokens","text":"Mint new SPL tokens to a specified token account.","title":"Mint Tokens"},{"location":"cookbook/token-operations/mint-tokens/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Mint Tokens \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import mint_to , MintToParams from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () mint_authority = Keypair () mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) destination_token_account = Pubkey . from_string ( \"GfVPzUxMDvhFJ1Xs6C9i47XQRSapTd8LHw5grGuTquyQ\" ) # Amount to mint (in smallest unit) amount_to_mint = 1000000000 # 1 token with 9 decimals async with rpc : # Create mint instruction mint_instruction = mint_to ( MintToParams ( program_id = TOKEN_PROGRAM_ID , mint = mint_address , dest = destination_token_account , mint_authority = mint_authority . pubkey (), amount = amount_to_mint ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ mint_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash , ) # Create and sign transaction transaction = VersionedTransaction ( message , [ payer , mint_authority ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/mint-tokens/#code-explanation","text":"This example shows how to mint new SPL tokens: Set Parameters : Define the payer, mint authority, mint address, and destination token account Create Mint Instruction : Use the mint_to() function to create a mint instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution","title":"Code Explanation"},{"location":"cookbook/token-operations/mint-tokens/#key-concepts","text":"Mint Authority : The account with minting permissions, only this account can mint new tokens Mint Address : The mint address of the token, identifying a specific token type Token Account : The destination account to receive the minted tokens Amount : The mint amount, calculated in the token's smallest unit","title":"Key Concepts"},{"location":"cookbook/token-operations/mint-tokens/#usage","text":"Set the account with minting permissions as mint_authority Specify the mint_address of the token to be minted Specify the destination_token_account to receive the tokens Set the amount of tokens to mint (pay attention to decimal places) Run the script to execute the mint operation","title":"Usage"},{"location":"cookbook/token-operations/mint-tokens/#important-notes","text":"Only accounts with minting permissions can execute mint operations The mint amount needs to consider the token's decimal places The destination account must be a token account for the corresponding token type Sufficient SOL is required to pay transaction fees","title":"Important Notes"},{"location":"cookbook/token-operations/revoke-delegate/","text":"Revoke Delegate Revoke the delegation permissions of a token account. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Revoke a Token Delegate \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.system_program import create_account , CreateAccountParams from spl.token.instructions import ( initialize_mint , InitializeMintParams , create_associated_token_account , mint_to_checked , MintToCheckedParams , revoke , RevokeParams , get_associated_token_address ) from spl.token.constants import TOKEN_PROGRAM_ID , ASSOCIATED_TOKEN_PROGRAM_ID # Constants DECIMALS = 9 async def setup ( rpc , mint_authority , latest_blockhash ): \"\"\" The setup function initializes the mint and associated token accounts, and mints tokens to said associated token account \"\"\" mint = Keypair () space = 82 # getMintSize() equivalent for SPL Token # Get minimum balance for rent exemption rent = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Create & initialize mint account create_account_instruction = create_account ( CreateAccountParams ( from_pubkey = mint_authority . pubkey (), to_pubkey = mint . pubkey (), lamports = rent . value , space = space , owner = TOKEN_PROGRAM_ID ) ) initialize_mint_instruction = initialize_mint ( InitializeMintParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), decimals = DECIMALS , mint_authority = mint_authority . pubkey (), freeze_authority = None ) ) # Create associated token account authority_ata = get_associated_token_address ( owner = mint_authority . pubkey (), mint = mint . pubkey (), token_program_id = TOKEN_PROGRAM_ID ) create_ata_instruction = create_associated_token_account ( payer = mint_authority . pubkey (), owner = mint_authority . pubkey (), mint = mint . pubkey (), token_program_id = TOKEN_PROGRAM_ID , associated_token_program_id = ASSOCIATED_TOKEN_PROGRAM_ID ) # Mint tokens to ATA mint_to_instruction = mint_to_checked ( MintToCheckedParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), dest = authority_ata , mint_authority = mint_authority . pubkey (), amount = 100 * ( 10 ** DECIMALS ), # 100 tokens decimals = DECIMALS ) ) # Create message message = MessageV0 . try_compile ( payer = mint_authority . pubkey (), instructions = [ create_account_instruction , initialize_mint_instruction , create_ata_instruction , mint_to_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ mint_authority , mint ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Setup transaction signature: { result . value } \" ) return mint . pubkey (), authority_ata async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Create keypairs payer = Keypair () mint_authority = Keypair () async with rpc : # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Setup mint and token account mint_pubkey , token_account = await setup ( rpc , mint_authority , recent_blockhash . value . blockhash ) # Create revoke instruction revoke_instruction = revoke ( RevokeParams ( program_id = TOKEN_PROGRAM_ID , source = token_account , owner = mint_authority . pubkey () ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ revoke_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer , mint_authority ]) print ( f \"Token Account: { token_account } \" ) print ( f \"Revoking delegate for account owner: { mint_authority . pubkey () } \" ) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Revoke transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to revoke the delegation permissions of a token account: Setup Phase : Create token mint, associated token account, and mint tokens Revoke Operation : Use the revoke() function to revoke previously granted delegation permissions Clear Delegation : Clear the delegation information from the token account Send Transaction : Send the revoke instruction to the network for execution Key Concepts Revoke Delegate : Revoke previously granted delegation permissions Token Account Owner : Only the token account owner can revoke delegation Delegate Clearance : After revocation, the delegated account can no longer operate tokens Permission Restoration : After revocation, all permissions return to the original owner Usage Ensure you are the owner of the token account Use the revoke() function to create a revoke instruction Specify the token account to revoke delegation from Sign and send the transaction After confirming transaction success, the delegation permissions are cleared Important Notes Only the token account owner can revoke delegation The revoke operation clears all delegation information After revocation, the previously delegated account cannot perform any operations If re-delegation is needed, a new delegation operation must be executed Sufficient SOL is required to pay transaction fees Scenarios for Revoking Delegation Security Considerations : When discovering that a delegated account may be compromised Permission Management : Regularly cleaning up unnecessary delegation permissions Protocol Upgrades : Revoking old delegations during protocol upgrades User Operations : Users actively revoking permissions given to third parties Relationship with Delegation Revoking delegation is the reverse operation of delegation: - Delegation: Grant operation permissions to other accounts - Revocation: Remove previously granted permissions Best Practices Regularly review and clean up delegation permissions Revoke delegation promptly when no longer needed Monitor the activity of delegated accounts Immediately revoke delegation when anomalies are detected","title":"Revoke Delegate"},{"location":"cookbook/token-operations/revoke-delegate/#revoke-delegate","text":"Revoke the delegation permissions of a token account.","title":"Revoke Delegate"},{"location":"cookbook/token-operations/revoke-delegate/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Revoke a Token Delegate \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.system_program import create_account , CreateAccountParams from spl.token.instructions import ( initialize_mint , InitializeMintParams , create_associated_token_account , mint_to_checked , MintToCheckedParams , revoke , RevokeParams , get_associated_token_address ) from spl.token.constants import TOKEN_PROGRAM_ID , ASSOCIATED_TOKEN_PROGRAM_ID # Constants DECIMALS = 9 async def setup ( rpc , mint_authority , latest_blockhash ): \"\"\" The setup function initializes the mint and associated token accounts, and mints tokens to said associated token account \"\"\" mint = Keypair () space = 82 # getMintSize() equivalent for SPL Token # Get minimum balance for rent exemption rent = await rpc . get_minimum_balance_for_rent_exemption ( space ) # Create & initialize mint account create_account_instruction = create_account ( CreateAccountParams ( from_pubkey = mint_authority . pubkey (), to_pubkey = mint . pubkey (), lamports = rent . value , space = space , owner = TOKEN_PROGRAM_ID ) ) initialize_mint_instruction = initialize_mint ( InitializeMintParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), decimals = DECIMALS , mint_authority = mint_authority . pubkey (), freeze_authority = None ) ) # Create associated token account authority_ata = get_associated_token_address ( owner = mint_authority . pubkey (), mint = mint . pubkey (), token_program_id = TOKEN_PROGRAM_ID ) create_ata_instruction = create_associated_token_account ( payer = mint_authority . pubkey (), owner = mint_authority . pubkey (), mint = mint . pubkey (), token_program_id = TOKEN_PROGRAM_ID , associated_token_program_id = ASSOCIATED_TOKEN_PROGRAM_ID ) # Mint tokens to ATA mint_to_instruction = mint_to_checked ( MintToCheckedParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), dest = authority_ata , mint_authority = mint_authority . pubkey (), amount = 100 * ( 10 ** DECIMALS ), # 100 tokens decimals = DECIMALS ) ) # Create message message = MessageV0 . try_compile ( payer = mint_authority . pubkey (), instructions = [ create_account_instruction , initialize_mint_instruction , create_ata_instruction , mint_to_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ mint_authority , mint ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Setup transaction signature: { result . value } \" ) return mint . pubkey (), authority_ata async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Create keypairs payer = Keypair () mint_authority = Keypair () async with rpc : # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Setup mint and token account mint_pubkey , token_account = await setup ( rpc , mint_authority , recent_blockhash . value . blockhash ) # Create revoke instruction revoke_instruction = revoke ( RevokeParams ( program_id = TOKEN_PROGRAM_ID , source = token_account , owner = mint_authority . pubkey () ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ revoke_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer , mint_authority ]) print ( f \"Token Account: { token_account } \" ) print ( f \"Revoking delegate for account owner: { mint_authority . pubkey () } \" ) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Revoke transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/revoke-delegate/#code-explanation","text":"This example shows how to revoke the delegation permissions of a token account: Setup Phase : Create token mint, associated token account, and mint tokens Revoke Operation : Use the revoke() function to revoke previously granted delegation permissions Clear Delegation : Clear the delegation information from the token account Send Transaction : Send the revoke instruction to the network for execution","title":"Code Explanation"},{"location":"cookbook/token-operations/revoke-delegate/#key-concepts","text":"Revoke Delegate : Revoke previously granted delegation permissions Token Account Owner : Only the token account owner can revoke delegation Delegate Clearance : After revocation, the delegated account can no longer operate tokens Permission Restoration : After revocation, all permissions return to the original owner","title":"Key Concepts"},{"location":"cookbook/token-operations/revoke-delegate/#usage","text":"Ensure you are the owner of the token account Use the revoke() function to create a revoke instruction Specify the token account to revoke delegation from Sign and send the transaction After confirming transaction success, the delegation permissions are cleared","title":"Usage"},{"location":"cookbook/token-operations/revoke-delegate/#important-notes","text":"Only the token account owner can revoke delegation The revoke operation clears all delegation information After revocation, the previously delegated account cannot perform any operations If re-delegation is needed, a new delegation operation must be executed Sufficient SOL is required to pay transaction fees","title":"Important Notes"},{"location":"cookbook/token-operations/revoke-delegate/#scenarios-for-revoking-delegation","text":"Security Considerations : When discovering that a delegated account may be compromised Permission Management : Regularly cleaning up unnecessary delegation permissions Protocol Upgrades : Revoking old delegations during protocol upgrades User Operations : Users actively revoking permissions given to third parties","title":"Scenarios for Revoking Delegation"},{"location":"cookbook/token-operations/revoke-delegate/#relationship-with-delegation","text":"Revoking delegation is the reverse operation of delegation: - Delegation: Grant operation permissions to other accounts - Revocation: Remove previously granted permissions","title":"Relationship with Delegation"},{"location":"cookbook/token-operations/revoke-delegate/#best-practices","text":"Regularly review and clean up delegation permissions Revoke delegation promptly when no longer needed Monitor the activity of delegated accounts Immediately revoke delegation when anomalies are detected","title":"Best Practices"},{"location":"cookbook/token-operations/set-authority/","text":"Set Authority Set the authority for token accounts or token mints. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Set Authority on Token Accounts or Mints \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import set_authority , SetAuthorityParams from spl.token.constants import TOKEN_PROGRAM_ID from spl.token.instructions import AuthorityType async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () current_authority = Keypair () new_authority = Keypair () mint_or_account = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) async with rpc : # Set new mint authority set_mint_authority_instruction = set_authority ( SetAuthorityParams ( program_id = TOKEN_PROGRAM_ID , account = mint_or_account , authority = AuthorityType . MINT_TOKENS , current_authority = current_authority . pubkey (), new_authority = new_authority . pubkey () ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ set_mint_authority_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer , current_authority ]) print ( f \"Account/Mint: { mint_or_account } \" ) print ( f \"Current Authority: { current_authority . pubkey () } \" ) print ( f \"New Authority: { new_authority . pubkey () } \" ) print ( f \"Authority Type: { AuthorityType . MINT_TOKENS } \" ) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to set the authority for token accounts or token mints: Set Parameters : Define the current authority holder, new authority holder, and target account Select Authority Type : Use AuthorityType to specify the type of authority to set Create Set Instruction : Use set_authority() to create an authority setting instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution Key Concepts Authority Types : Different types of authorities MINT_TOKENS : Permission to mint tokens FREEZE_ACCOUNT : Permission to freeze accounts ACCOUNT_OWNER : Account owner authority CLOSE_ACCOUNT : Permission to close accounts Current Authority : The current authority holder New Authority : The new authority holder Authority Types Details For Token Mint: MINT_TOKENS : Permission to mint new tokens FREEZE_ACCOUNT : Permission to freeze token accounts For Token Account: ACCOUNT_OWNER : Account owner authority CLOSE_ACCOUNT : Permission to close accounts Usage Set the current authority holder as current_authority Set the new authority holder as new_authority Specify the account or mint address to operate on Choose the appropriate authority type Run the script to execute the authority transfer Important Notes Only the current authority holder can transfer authority Authority transfer is an irreversible operation Authority can be set to None to permanently relinquish authority Different authority types apply to different account types Sufficient SOL is required to pay transaction fees Authority Management Best Practices Carefully manage mint authority, consider relinquishing it when appropriate Set up multi-signature for important operations Regularly review and update authority settings Use hardware wallets to manage authority in production environments","title":"Set Authority"},{"location":"cookbook/token-operations/set-authority/#set-authority","text":"Set the authority for token accounts or token mints.","title":"Set Authority"},{"location":"cookbook/token-operations/set-authority/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Set Authority on Token Accounts or Mints \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import set_authority , SetAuthorityParams from spl.token.constants import TOKEN_PROGRAM_ID from spl.token.instructions import AuthorityType async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () current_authority = Keypair () new_authority = Keypair () mint_or_account = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) async with rpc : # Set new mint authority set_mint_authority_instruction = set_authority ( SetAuthorityParams ( program_id = TOKEN_PROGRAM_ID , account = mint_or_account , authority = AuthorityType . MINT_TOKENS , current_authority = current_authority . pubkey (), new_authority = new_authority . pubkey () ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ set_mint_authority_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ payer , current_authority ]) print ( f \"Account/Mint: { mint_or_account } \" ) print ( f \"Current Authority: { current_authority . pubkey () } \" ) print ( f \"New Authority: { new_authority . pubkey () } \" ) print ( f \"Authority Type: { AuthorityType . MINT_TOKENS } \" ) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/set-authority/#code-explanation","text":"This example shows how to set the authority for token accounts or token mints: Set Parameters : Define the current authority holder, new authority holder, and target account Select Authority Type : Use AuthorityType to specify the type of authority to set Create Set Instruction : Use set_authority() to create an authority setting instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution","title":"Code Explanation"},{"location":"cookbook/token-operations/set-authority/#key-concepts","text":"Authority Types : Different types of authorities MINT_TOKENS : Permission to mint tokens FREEZE_ACCOUNT : Permission to freeze accounts ACCOUNT_OWNER : Account owner authority CLOSE_ACCOUNT : Permission to close accounts Current Authority : The current authority holder New Authority : The new authority holder","title":"Key Concepts"},{"location":"cookbook/token-operations/set-authority/#authority-types-details","text":"","title":"Authority Types Details"},{"location":"cookbook/token-operations/set-authority/#for-token-mint","text":"MINT_TOKENS : Permission to mint new tokens FREEZE_ACCOUNT : Permission to freeze token accounts","title":"For Token Mint:"},{"location":"cookbook/token-operations/set-authority/#for-token-account","text":"ACCOUNT_OWNER : Account owner authority CLOSE_ACCOUNT : Permission to close accounts","title":"For Token Account:"},{"location":"cookbook/token-operations/set-authority/#usage","text":"Set the current authority holder as current_authority Set the new authority holder as new_authority Specify the account or mint address to operate on Choose the appropriate authority type Run the script to execute the authority transfer","title":"Usage"},{"location":"cookbook/token-operations/set-authority/#important-notes","text":"Only the current authority holder can transfer authority Authority transfer is an irreversible operation Authority can be set to None to permanently relinquish authority Different authority types apply to different account types Sufficient SOL is required to pay transaction fees","title":"Important Notes"},{"location":"cookbook/token-operations/set-authority/#authority-management-best-practices","text":"Carefully manage mint authority, consider relinquishing it when appropriate Set up multi-signature for important operations Regularly review and update authority settings Use hardware wallets to manage authority in production environments","title":"Authority Management Best Practices"},{"location":"cookbook/token-operations/transfer-tokens/","text":"Transfer Tokens Transfer SPL tokens between two token accounts. Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Transfer Tokens (SPL Token Transfer Checked) \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import transfer_checked , TransferCheckedParams from spl.token.instructions import get_associated_token_address from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () owner = Keypair () receiver = Keypair () mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) # Token decimals (usually 9 for most tokens) decimals = 9 # Amount to transfer (in smallest unit) amount_to_transfer = 10_000_000_000 # 10 tokens with 9 decimals async with rpc : # Get associated token addresses source_token_account = get_associated_token_address ( owner = owner . pubkey (), mint = mint_address , token_program_id = TOKEN_PROGRAM_ID ) destination_token_account = get_associated_token_address ( owner = receiver . pubkey (), mint = mint_address , token_program_id = TOKEN_PROGRAM_ID ) # Create transfer checked instruction transfer_instruction = transfer_checked ( TransferCheckedParams ( program_id = TOKEN_PROGRAM_ID , source = source_token_account , mint = mint_address , dest = destination_token_account , owner = owner . pubkey (), amount = amount_to_transfer , decimals = decimals ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash , ) # Create and sign transaction transaction = VersionedTransaction ( message , [ payer , owner ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example shows how to transfer SPL tokens between two token accounts: Set Parameters : Define the payer, token owner, receiver, and mint address Get Associated Token Accounts : Use get_associated_token_address() to get source and destination token account addresses Create Transfer Instruction : Use transfer_checked() to create a secure transfer instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution Key Concepts Transfer Checked : Safer than regular transfer, verifies token type and decimal places Associated Token Account : Standard token account associated with a specific wallet and token type Source Account : The source account sending tokens Destination Account : The destination account receiving tokens Decimals : The decimal places of the token, used to verify transfer correctness Usage Set the token owner as owner Set the token receiver as receiver Specify the mint_address of the token to transfer Set the token's decimal places Set the amount of tokens to transfer (pay attention to decimal places) Run the script to execute the transfer operation Important Notes The source account must have sufficient token balance The destination account must be an account for the same token type Using transfer_checked is safer than regular transfer Sufficient SOL is required to pay transaction fees If the destination account doesn't exist, it may need to be created first","title":"Transfer Tokens"},{"location":"cookbook/token-operations/transfer-tokens/#transfer-tokens","text":"Transfer SPL tokens between two token accounts.","title":"Transfer Tokens"},{"location":"cookbook/token-operations/transfer-tokens/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Transfer Tokens (SPL Token Transfer Checked) \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import transfer_checked , TransferCheckedParams from spl.token.instructions import get_associated_token_address from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs and addresses payer = Keypair () owner = Keypair () receiver = Keypair () mint_address = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) # Token decimals (usually 9 for most tokens) decimals = 9 # Amount to transfer (in smallest unit) amount_to_transfer = 10_000_000_000 # 10 tokens with 9 decimals async with rpc : # Get associated token addresses source_token_account = get_associated_token_address ( owner = owner . pubkey (), mint = mint_address , token_program_id = TOKEN_PROGRAM_ID ) destination_token_account = get_associated_token_address ( owner = receiver . pubkey (), mint = mint_address , token_program_id = TOKEN_PROGRAM_ID ) # Create transfer checked instruction transfer_instruction = transfer_checked ( TransferCheckedParams ( program_id = TOKEN_PROGRAM_ID , source = source_token_account , mint = mint_address , dest = destination_token_account , owner = owner . pubkey (), amount = amount_to_transfer , decimals = decimals ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash , ) # Create and sign transaction transaction = VersionedTransaction ( message , [ payer , owner ]) # Send transaction result = await rpc . send_transaction ( transaction ) print ( f \"Transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/transfer-tokens/#code-explanation","text":"This example shows how to transfer SPL tokens between two token accounts: Set Parameters : Define the payer, token owner, receiver, and mint address Get Associated Token Accounts : Use get_associated_token_address() to get source and destination token account addresses Create Transfer Instruction : Use transfer_checked() to create a secure transfer instruction Build Transaction : Create a message and build a signed transaction Send Transaction : Send the transaction to the network for execution","title":"Code Explanation"},{"location":"cookbook/token-operations/transfer-tokens/#key-concepts","text":"Transfer Checked : Safer than regular transfer, verifies token type and decimal places Associated Token Account : Standard token account associated with a specific wallet and token type Source Account : The source account sending tokens Destination Account : The destination account receiving tokens Decimals : The decimal places of the token, used to verify transfer correctness","title":"Key Concepts"},{"location":"cookbook/token-operations/transfer-tokens/#usage","text":"Set the token owner as owner Set the token receiver as receiver Specify the mint_address of the token to transfer Set the token's decimal places Set the amount of tokens to transfer (pay attention to decimal places) Run the script to execute the transfer operation","title":"Usage"},{"location":"cookbook/token-operations/transfer-tokens/#important-notes","text":"The source account must have sufficient token balance The destination account must be an account for the same token type Using transfer_checked is safer than regular transfer Sufficient SOL is required to pay transaction fees If the destination account doesn't exist, it may need to be created first","title":"Important Notes"},{"location":"cookbook/token-operations/wrapped-sol/","text":"Wrapped SOL \u4f7f\u7528 Wrapped SOL (wSOL)\uff0c\u5c06\u539f\u751f SOL \u8f6c\u6362\u4e3a SPL Token \u683c\u5f0f\u3002 Code Implementation #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Use Wrapped SOL \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.system_program import transfer , TransferParams from spl.token.instructions import ( create_associated_token_account , sync_native , SyncNativeParams , close_account , CloseAccountParams , get_associated_token_address ) from spl.token.constants import TOKEN_PROGRAM_ID , ASSOCIATED_TOKEN_PROGRAM_ID from solders.pubkey import Pubkey # Native mint address for wrapped SOL NATIVE_MINT = Pubkey . from_string ( \"So11111111111111111111111111111111111111112\" ) async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs payer = Keypair () owner = Keypair () # Amount to wrap (in lamports) amount_to_wrap = 1000000000 # 1 SOL async with rpc : # Get associated token address for wrapped SOL wrapped_sol_account = get_associated_token_address ( owner = owner . pubkey (), mint = NATIVE_MINT , token_program_id = TOKEN_PROGRAM_ID ) # Create associated token account for wrapped SOL create_ata_instruction = create_associated_token_account ( payer = payer . pubkey (), owner = owner . pubkey (), mint = NATIVE_MINT , token_program_id = TOKEN_PROGRAM_ID , associated_token_program_id = ASSOCIATED_TOKEN_PROGRAM_ID ) # Transfer SOL to the wrapped SOL account transfer_instruction = transfer ( TransferParams ( from_pubkey = payer . pubkey (), to_pubkey = wrapped_sol_account , lamports = amount_to_wrap ) ) # Sync native instruction to update the wrapped SOL balance sync_native_instruction = sync_native ( SyncNativeParams ( program_id = TOKEN_PROGRAM_ID , account = wrapped_sol_account ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message for wrapping SOL wrap_message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ create_ata_instruction , transfer_instruction , sync_native_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction wrap_transaction = VersionedTransaction ( wrap_message , [ payer , owner ]) print ( f \"Wrapped SOL Account: { wrapped_sol_account } \" ) print ( f \"Amount to wrap: { amount_to_wrap / 1000000000 } SOL\" ) # Send wrapping transaction result = await rpc . send_transaction ( wrap_transaction ) print ( f \"Wrap transaction signature: { result . value } \" ) # Unwrap SOL by closing the account print ( \" \\n Unwrapping SOL...\" ) # Close account instruction to unwrap SOL close_instruction = close_account ( CloseAccountParams ( program_id = TOKEN_PROGRAM_ID , account = wrapped_sol_account , dest = owner . pubkey (), owner = owner . pubkey () ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message for unwrapping SOL unwrap_message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ close_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction unwrap_transaction = VersionedTransaction ( unwrap_message , [ payer , owner ]) # Send unwrapping transaction result = await rpc . send_transaction ( unwrap_transaction ) print ( f \"Unwrap transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Code Explanation This example demonstrates how to use Wrapped SOL: Create a wSOL account : Create an associated token account for native SOL Transfer SOL : Transfer SOL into the wSOL account Sync balance : Use sync_native() to sync the wSOL account balance Unwrap SOL : Convert wSOL back to native SOL by closing the account Key Concepts Wrapped SOL (wSOL) : Wraps native SOL into SPL Token format Native Mint : The special token mint address for native SOL Sync Native : Synchronizes the balance of native token accounts Unwrapping : Converts wSOL back to native SOL by closing the account Usage Wrapping SOL Create an associated token account for wSOL Transfer SOL to that account Call sync_native() to synchronize the balance Unwrapping SOL Use close_account() to close the wSOL account SOL in the account will be returned to the specified destination account Why Use Wrapped SOL Unified Interface : Allows SOL to be operated like other SPL tokens DeFi Protocols : Use SOL in protocols that require token interfaces Trading Pairs : Create SOL trading pairs in decentralized exchanges Program Compatibility : Enables programs that only support SPL tokens to handle SOL Important Notes The wSOL account balance equals the amount of SOL in it Creating a wSOL account requires rent, which can be recovered when closing sync_native() must be called after transferring SOL to correctly update the balance When unwrapping, the account must have no delegation permissions Sufficient SOL is required to pay transaction fees","title":"Wrapped SOL"},{"location":"cookbook/token-operations/wrapped-sol/#wrapped-sol","text":"\u4f7f\u7528 Wrapped SOL (wSOL)\uff0c\u5c06\u539f\u751f SOL \u8f6c\u6362\u4e3a SPL Token \u683c\u5f0f\u3002","title":"Wrapped SOL"},{"location":"cookbook/token-operations/wrapped-sol/#code-implementation","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Use Wrapped SOL \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.system_program import transfer , TransferParams from spl.token.instructions import ( create_associated_token_account , sync_native , SyncNativeParams , close_account , CloseAccountParams , get_associated_token_address ) from spl.token.constants import TOKEN_PROGRAM_ID , ASSOCIATED_TOKEN_PROGRAM_ID from solders.pubkey import Pubkey # Native mint address for wrapped SOL NATIVE_MINT = Pubkey . from_string ( \"So11111111111111111111111111111111111111112\" ) async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) # Example keypairs payer = Keypair () owner = Keypair () # Amount to wrap (in lamports) amount_to_wrap = 1000000000 # 1 SOL async with rpc : # Get associated token address for wrapped SOL wrapped_sol_account = get_associated_token_address ( owner = owner . pubkey (), mint = NATIVE_MINT , token_program_id = TOKEN_PROGRAM_ID ) # Create associated token account for wrapped SOL create_ata_instruction = create_associated_token_account ( payer = payer . pubkey (), owner = owner . pubkey (), mint = NATIVE_MINT , token_program_id = TOKEN_PROGRAM_ID , associated_token_program_id = ASSOCIATED_TOKEN_PROGRAM_ID ) # Transfer SOL to the wrapped SOL account transfer_instruction = transfer ( TransferParams ( from_pubkey = payer . pubkey (), to_pubkey = wrapped_sol_account , lamports = amount_to_wrap ) ) # Sync native instruction to update the wrapped SOL balance sync_native_instruction = sync_native ( SyncNativeParams ( program_id = TOKEN_PROGRAM_ID , account = wrapped_sol_account ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message for wrapping SOL wrap_message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ create_ata_instruction , transfer_instruction , sync_native_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction wrap_transaction = VersionedTransaction ( wrap_message , [ payer , owner ]) print ( f \"Wrapped SOL Account: { wrapped_sol_account } \" ) print ( f \"Amount to wrap: { amount_to_wrap / 1000000000 } SOL\" ) # Send wrapping transaction result = await rpc . send_transaction ( wrap_transaction ) print ( f \"Wrap transaction signature: { result . value } \" ) # Unwrap SOL by closing the account print ( \" \\n Unwrapping SOL...\" ) # Close account instruction to unwrap SOL close_instruction = close_account ( CloseAccountParams ( program_id = TOKEN_PROGRAM_ID , account = wrapped_sol_account , dest = owner . pubkey (), owner = owner . pubkey () ) ) # Get latest blockhash recent_blockhash = await rpc . get_latest_blockhash () # Create message for unwrapping SOL unwrap_message = MessageV0 . try_compile ( payer = payer . pubkey (), instructions = [ close_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash . value . blockhash ) # Create transaction unwrap_transaction = VersionedTransaction ( unwrap_message , [ payer , owner ]) # Send unwrapping transaction result = await rpc . send_transaction ( unwrap_transaction ) print ( f \"Unwrap transaction signature: { result . value } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Implementation"},{"location":"cookbook/token-operations/wrapped-sol/#code-explanation","text":"This example demonstrates how to use Wrapped SOL: Create a wSOL account : Create an associated token account for native SOL Transfer SOL : Transfer SOL into the wSOL account Sync balance : Use sync_native() to sync the wSOL account balance Unwrap SOL : Convert wSOL back to native SOL by closing the account","title":"Code Explanation"},{"location":"cookbook/token-operations/wrapped-sol/#key-concepts","text":"Wrapped SOL (wSOL) : Wraps native SOL into SPL Token format Native Mint : The special token mint address for native SOL Sync Native : Synchronizes the balance of native token accounts Unwrapping : Converts wSOL back to native SOL by closing the account","title":"Key Concepts"},{"location":"cookbook/token-operations/wrapped-sol/#usage","text":"","title":"Usage"},{"location":"cookbook/token-operations/wrapped-sol/#wrapping-sol","text":"Create an associated token account for wSOL Transfer SOL to that account Call sync_native() to synchronize the balance","title":"Wrapping SOL"},{"location":"cookbook/token-operations/wrapped-sol/#unwrapping-sol","text":"Use close_account() to close the wSOL account SOL in the account will be returned to the specified destination account","title":"Unwrapping SOL"},{"location":"cookbook/token-operations/wrapped-sol/#why-use-wrapped-sol","text":"Unified Interface : Allows SOL to be operated like other SPL tokens DeFi Protocols : Use SOL in protocols that require token interfaces Trading Pairs : Create SOL trading pairs in decentralized exchanges Program Compatibility : Enables programs that only support SPL tokens to handle SOL","title":"Why Use Wrapped SOL"},{"location":"cookbook/token-operations/wrapped-sol/#important-notes","text":"The wSOL account balance equals the amount of SOL in it Creating a wSOL account requires rent, which can be recovered when closing sync_native() must be called after transferring SOL to correctly update the balance When unwrapping, the account must have no delegation permissions Sufficient SOL is required to pay transaction fees","title":"Important Notes"},{"location":"cookbook/transaction-operations/add-memo-to-transaction/","text":"Add Memo to Transaction Learn how to add a memo to a Solana transaction to include additional information or comments. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Add a Memo to a Transaction \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.memo.instructions import create_memo , MemoParams from solders.pubkey import Pubkey async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () amount = 1_000_000_000 # 1 SOL memo_text = \"Hello, Solana! This is a memo.\" async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = amount ) ) # Create memo instruction memo_instruction = create_memo ( MemoParams ( program_id = Pubkey . from_string ( \"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr\" ), signer = sender . pubkey (), message = memo_text . encode ( 'utf-8' ) ) ) # Create message with both instructions message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ transfer_instruction , memo_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Transfer Amount: { amount / 1_000_000_000 } SOL\" ) print ( f \"Memo: { memo_text } \" ) print ( f \"Transaction with memo created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation This example demonstrates how to add a memo to a Solana transaction: Create Standard Transaction : Build a regular transfer transaction Create Memo Instruction : Use the SPL Memo program to create a memo instruction Combine Instructions : Include both transfer and memo instructions in the same transaction Encode Message : Convert the memo text to bytes for the instruction Create Transaction : Build a versioned transaction with both instructions Key Concepts SPL Memo Program : Official program for adding text memos to transactions Multiple Instructions : A single transaction can contain multiple instructions Memo Program ID : The fixed program ID for the memo program UTF-8 Encoding : Memo text must be encoded as bytes Transaction Ordering : Instructions are executed in the order they appear Usage To run this example: Install required dependencies: pip install solana-py solders spl-token Run the script: python add_memo_to_transaction.py Use Cases Memos are useful for: - Adding payment references or invoice numbers - Including transaction descriptions - Storing metadata on-chain - Creating audit trails - Adding context to transfers Note: Memos are publicly visible on the blockchain and increase transaction size and fees slightly.","title":"Add Memo to Transaction"},{"location":"cookbook/transaction-operations/add-memo-to-transaction/#add-memo-to-transaction","text":"Learn how to add a memo to a Solana transaction to include additional information or comments.","title":"Add Memo to Transaction"},{"location":"cookbook/transaction-operations/add-memo-to-transaction/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Add a Memo to a Transaction \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.memo.instructions import create_memo , MemoParams from solders.pubkey import Pubkey async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () amount = 1_000_000_000 # 1 SOL memo_text = \"Hello, Solana! This is a memo.\" async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = amount ) ) # Create memo instruction memo_instruction = create_memo ( MemoParams ( program_id = Pubkey . from_string ( \"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr\" ), signer = sender . pubkey (), message = memo_text . encode ( 'utf-8' ) ) ) # Create message with both instructions message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ transfer_instruction , memo_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Transfer Amount: { amount / 1_000_000_000 } SOL\" ) print ( f \"Memo: { memo_text } \" ) print ( f \"Transaction with memo created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Example"},{"location":"cookbook/transaction-operations/add-memo-to-transaction/#explanation","text":"This example demonstrates how to add a memo to a Solana transaction: Create Standard Transaction : Build a regular transfer transaction Create Memo Instruction : Use the SPL Memo program to create a memo instruction Combine Instructions : Include both transfer and memo instructions in the same transaction Encode Message : Convert the memo text to bytes for the instruction Create Transaction : Build a versioned transaction with both instructions","title":"Explanation"},{"location":"cookbook/transaction-operations/add-memo-to-transaction/#key-concepts","text":"SPL Memo Program : Official program for adding text memos to transactions Multiple Instructions : A single transaction can contain multiple instructions Memo Program ID : The fixed program ID for the memo program UTF-8 Encoding : Memo text must be encoded as bytes Transaction Ordering : Instructions are executed in the order they appear","title":"Key Concepts"},{"location":"cookbook/transaction-operations/add-memo-to-transaction/#usage","text":"To run this example: Install required dependencies: pip install solana-py solders spl-token Run the script: python add_memo_to_transaction.py","title":"Usage"},{"location":"cookbook/transaction-operations/add-memo-to-transaction/#use-cases","text":"Memos are useful for: - Adding payment references or invoice numbers - Including transaction descriptions - Storing metadata on-chain - Creating audit trails - Adding context to transfers Note: Memos are publicly visible on the blockchain and increase transaction size and fees slightly.","title":"Use Cases"},{"location":"cookbook/transaction-operations/add-priority-fees/","text":"Add Priority Fees Learn how to add priority fees to Solana transactions to increase the likelihood of faster processing during network congestion. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Add Priority Fees to a Transaction \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.instruction import Instruction from solders.pubkey import Pubkey from solders.compute_budget import set_compute_unit_price # Compute Budget Program ID COMPUTE_BUDGET_PROGRAM_ID = Pubkey . from_string ( \"ComputeBudget111111111111111111111111111111\" ) async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () amount = 1_000_000_000 # 1 SOL priority_fee_lamports = 5000 # 5000 lamports priority fee async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create priority fee instruction priority_fee_instruction = set_compute_unit_price ( priority_fee_lamports ) # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = amount ) ) # Create message with priority fee instruction first message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ priority_fee_instruction , transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Transfer Amount: { amount / 1_000_000_000 } SOL\" ) print ( f \"Priority Fee: { priority_fee_lamports } lamports\" ) print ( f \"Transaction with priority fee created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation This example demonstrates how to add priority fees to transactions: Import Compute Budget : Use the compute budget program for priority fees Set Priority Fee : Define the priority fee amount in lamports Create Priority Fee Instruction : Use set_compute_unit_price() to create the instruction Combine Instructions : Include priority fee instruction before the main instruction Create Transaction : Build the transaction with both instructions Key Concepts Priority Fees : Additional fees paid to validators for faster transaction processing Compute Budget Program : System program that manages compute unit pricing Compute Unit Price : The price per compute unit in micro-lamports Instruction Ordering : Priority fee instructions should come first in the transaction Network Congestion : Priority fees are most effective during high network usage Usage To run this example: Install required dependencies: pip install solana-py solders Run the script: python add_priority_fees.py Priority Fee Strategies Different scenarios for priority fees: Low Priority : 0-1000 lamports for standard transactions Medium Priority : 1000-5000 lamports for time-sensitive transactions High Priority : 5000+ lamports for urgent transactions during congestion Benefits Faster Processing : Higher priority fees increase chances of faster inclusion Congestion Management : Helps during network congestion periods MEV Protection : Can help protect against MEV (Maximal Extractable Value) attacks Predictable Costs : Set known additional cost for transaction priority Note: Priority fees are burned (destroyed) rather than going to validators, making them a deflationary mechanism.","title":"Add Priority Fees"},{"location":"cookbook/transaction-operations/add-priority-fees/#add-priority-fees","text":"Learn how to add priority fees to Solana transactions to increase the likelihood of faster processing during network congestion.","title":"Add Priority Fees"},{"location":"cookbook/transaction-operations/add-priority-fees/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Add Priority Fees to a Transaction \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.instruction import Instruction from solders.pubkey import Pubkey from solders.compute_budget import set_compute_unit_price # Compute Budget Program ID COMPUTE_BUDGET_PROGRAM_ID = Pubkey . from_string ( \"ComputeBudget111111111111111111111111111111\" ) async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () amount = 1_000_000_000 # 1 SOL priority_fee_lamports = 5000 # 5000 lamports priority fee async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create priority fee instruction priority_fee_instruction = set_compute_unit_price ( priority_fee_lamports ) # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = amount ) ) # Create message with priority fee instruction first message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ priority_fee_instruction , transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Transfer Amount: { amount / 1_000_000_000 } SOL\" ) print ( f \"Priority Fee: { priority_fee_lamports } lamports\" ) print ( f \"Transaction with priority fee created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Example"},{"location":"cookbook/transaction-operations/add-priority-fees/#explanation","text":"This example demonstrates how to add priority fees to transactions: Import Compute Budget : Use the compute budget program for priority fees Set Priority Fee : Define the priority fee amount in lamports Create Priority Fee Instruction : Use set_compute_unit_price() to create the instruction Combine Instructions : Include priority fee instruction before the main instruction Create Transaction : Build the transaction with both instructions","title":"Explanation"},{"location":"cookbook/transaction-operations/add-priority-fees/#key-concepts","text":"Priority Fees : Additional fees paid to validators for faster transaction processing Compute Budget Program : System program that manages compute unit pricing Compute Unit Price : The price per compute unit in micro-lamports Instruction Ordering : Priority fee instructions should come first in the transaction Network Congestion : Priority fees are most effective during high network usage","title":"Key Concepts"},{"location":"cookbook/transaction-operations/add-priority-fees/#usage","text":"To run this example: Install required dependencies: pip install solana-py solders Run the script: python add_priority_fees.py","title":"Usage"},{"location":"cookbook/transaction-operations/add-priority-fees/#priority-fee-strategies","text":"Different scenarios for priority fees: Low Priority : 0-1000 lamports for standard transactions Medium Priority : 1000-5000 lamports for time-sensitive transactions High Priority : 5000+ lamports for urgent transactions during congestion","title":"Priority Fee Strategies"},{"location":"cookbook/transaction-operations/add-priority-fees/#benefits","text":"Faster Processing : Higher priority fees increase chances of faster inclusion Congestion Management : Helps during network congestion periods MEV Protection : Can help protect against MEV (Maximal Extractable Value) attacks Predictable Costs : Set known additional cost for transaction priority Note: Priority fees are burned (destroyed) rather than going to validators, making them a deflationary mechanism.","title":"Benefits"},{"location":"cookbook/transaction-operations/calculate-transaction-cost/","text":"Calculate Transaction Cost Learn how to calculate the cost of a Solana transaction before sending it, including both transfer amount and network fees. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Calculate Transaction Cost \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () amount = 1_000_000_000 # 1 SOL async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = amount ) ) # Create message message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) # Get fee for transaction fee_response = await rpc . get_fee_for_message ( message ) print ( f \"Transaction fee: { fee_response . value } lamports\" ) print ( f \"Transaction fee: { fee_response . value / 1_000_000_000 } SOL\" ) # Calculate total cost (amount + fee) total_cost = amount + fee_response . value print ( f \"Total cost: { total_cost } lamports\" ) print ( f \"Total cost: { total_cost / 1_000_000_000 } SOL\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation This example demonstrates how to calculate the total cost of a transaction: Create Transaction : Build a standard transfer transaction Get Fee Estimate : Use get_fee_for_message() to calculate the network fee Calculate Total Cost : Add the transfer amount and the network fee Display Results : Show fees in both lamports and SOL Key Concepts Transaction Fees : Network fees paid to validators for processing transactions Fee Calculation : Fees are calculated based on the transaction's computational requirements Total Cost : The sum of the transfer amount and network fees Fee Estimation : Getting fee estimates before sending transactions Usage To run this example: Install required dependencies: pip install solana-py solders Run the script: python calculate_transaction_cost.py The script will output: - Transaction fee in lamports and SOL - Total cost including transfer amount and fees This is useful for budgeting and ensuring accounts have sufficient balance to cover both the transfer amount and network fees.","title":"Calculate Transaction Cost"},{"location":"cookbook/transaction-operations/calculate-transaction-cost/#calculate-transaction-cost","text":"Learn how to calculate the cost of a Solana transaction before sending it, including both transfer amount and network fees.","title":"Calculate Transaction Cost"},{"location":"cookbook/transaction-operations/calculate-transaction-cost/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Calculate Transaction Cost \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () amount = 1_000_000_000 # 1 SOL async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = amount ) ) # Create message message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) # Get fee for transaction fee_response = await rpc . get_fee_for_message ( message ) print ( f \"Transaction fee: { fee_response . value } lamports\" ) print ( f \"Transaction fee: { fee_response . value / 1_000_000_000 } SOL\" ) # Calculate total cost (amount + fee) total_cost = amount + fee_response . value print ( f \"Total cost: { total_cost } lamports\" ) print ( f \"Total cost: { total_cost / 1_000_000_000 } SOL\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Example"},{"location":"cookbook/transaction-operations/calculate-transaction-cost/#explanation","text":"This example demonstrates how to calculate the total cost of a transaction: Create Transaction : Build a standard transfer transaction Get Fee Estimate : Use get_fee_for_message() to calculate the network fee Calculate Total Cost : Add the transfer amount and the network fee Display Results : Show fees in both lamports and SOL","title":"Explanation"},{"location":"cookbook/transaction-operations/calculate-transaction-cost/#key-concepts","text":"Transaction Fees : Network fees paid to validators for processing transactions Fee Calculation : Fees are calculated based on the transaction's computational requirements Total Cost : The sum of the transfer amount and network fees Fee Estimation : Getting fee estimates before sending transactions","title":"Key Concepts"},{"location":"cookbook/transaction-operations/calculate-transaction-cost/#usage","text":"To run this example: Install required dependencies: pip install solana-py solders Run the script: python calculate_transaction_cost.py The script will output: - Transaction fee in lamports and SOL - Total cost including transfer amount and fees This is useful for budgeting and ensuring accounts have sufficient balance to cover both the transfer amount and network fees.","title":"Usage"},{"location":"cookbook/transaction-operations/offline-transactions/","text":"Offline Transactions Learn how to create, sign, and send Solana transactions in an offline environment, useful for security-sensitive operations. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - Offline Transactions To complete an offline transaction: 1. Create Transaction 2. Sign Transaction 3. Recover Transaction 4. Send Transaction \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.pubkey import Pubkey from solders.hash import Hash import nacl.signing import nacl.encoding import base58 async def main (): # Create connection connection = AsyncClient ( \"http://localhost:8899\" ) # Create an example tx, alice transfer to bob and feePayer is `fee_payer` # alice and fee_payer are signers in this tx fee_payer = Keypair () # Airdrop to fee_payer airdrop_resp = await connection . request_airdrop ( fee_payer . pubkey (), 1_000_000_000 ) await connection . confirm_transaction ( airdrop_resp . value ) alice = Keypair () # Airdrop to alice airdrop_resp = await connection . request_airdrop ( alice . pubkey (), 1_000_000_000 ) await connection . confirm_transaction ( airdrop_resp . value ) bob = Keypair () # 1. Create Transaction transfer_instruction = transfer ( TransferParams ( from_pubkey = alice . pubkey (), to_pubkey = bob . pubkey (), lamports = int ( 0.1 * 1_000_000_000 ) # 0.1 SOL ) ) # Get recent blockhash recent_blockhash_resp = await connection . get_latest_blockhash () recent_blockhash = recent_blockhash_resp . value . blockhash # Create message message = MessageV0 . try_compile ( payer = fee_payer . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash ) # 2. Sign Transaction (offline) # This can be done offline with saved private keys transaction = VersionedTransaction ( message , [ fee_payer , alice ]) # 3. Serialize transaction for offline storage/transmission serialized_tx = bytes ( transaction ) print ( f \"Serialized transaction length: { len ( serialized_tx ) } bytes\" ) # 4. Recover Transaction (from serialized data) # This simulates loading a transaction from offline storage recovered_transaction = VersionedTransaction . from_bytes ( serialized_tx ) # 5. Send Transaction (online) async with connection : try : signature = await connection . send_transaction ( recovered_transaction ) print ( f \"Transaction sent with signature: { signature . value } \" ) # Confirm transaction await connection . confirm_transaction ( signature . value ) print ( \"Transaction confirmed\" ) except Exception as e : print ( f \"Error sending transaction: { e } \" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation This example demonstrates the offline transaction workflow: Create Transaction : Build the transaction with all necessary instructions Sign Transaction : Sign with private keys (can be done offline) Serialize Transaction : Convert to bytes for storage or transmission Recover Transaction : Deserialize the transaction bytes Send Transaction : Submit to the network when online Key Concepts Offline Signing : Signing transactions without network connectivity Transaction Serialization : Converting transactions to bytes for storage Security Benefits : Private keys never exposed to online environments Cold Storage : Keeping signing keys on offline devices Transaction Recovery : Reconstructing transactions from serialized data Usage To run this example: Install required dependencies: pip install solana-py solders nacl Start a local Solana validator: solana-test-validator Run the script: python offline_transactions.py Offline Workflow Step 1: Online (Preparation) Get recent blockhash Prepare transaction instructions Export transaction template Step 2: Offline (Signing) Load private keys from secure storage Sign the transaction Save signed transaction Step 3: Online (Broadcasting) Load signed transaction Send to network Confirm transaction Security Benefits Air-gapped Signing : Private keys never touch online systems Reduced Attack Surface : Minimize online exposure Hardware Security : Compatible with hardware wallets Audit Trail : Clear separation of signing and broadcasting Use Cases High-value Transactions : Large transfers requiring maximum security Institutional Trading : Enterprise-grade security requirements Multi-signature Wallets : Collecting signatures from multiple parties Cold Storage Operations : Managing funds in cold storage Note: Recent blockhashes expire after about 2 minutes, so offline transactions must be submitted promptly after signing.","title":"Offline Transactions"},{"location":"cookbook/transaction-operations/offline-transactions/#offline-transactions","text":"Learn how to create, sign, and send Solana transactions in an offline environment, useful for security-sensitive operations.","title":"Offline Transactions"},{"location":"cookbook/transaction-operations/offline-transactions/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - Offline Transactions To complete an offline transaction: 1. Create Transaction 2. Sign Transaction 3. Recover Transaction 4. Send Transaction \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.pubkey import Pubkey from solders.hash import Hash import nacl.signing import nacl.encoding import base58 async def main (): # Create connection connection = AsyncClient ( \"http://localhost:8899\" ) # Create an example tx, alice transfer to bob and feePayer is `fee_payer` # alice and fee_payer are signers in this tx fee_payer = Keypair () # Airdrop to fee_payer airdrop_resp = await connection . request_airdrop ( fee_payer . pubkey (), 1_000_000_000 ) await connection . confirm_transaction ( airdrop_resp . value ) alice = Keypair () # Airdrop to alice airdrop_resp = await connection . request_airdrop ( alice . pubkey (), 1_000_000_000 ) await connection . confirm_transaction ( airdrop_resp . value ) bob = Keypair () # 1. Create Transaction transfer_instruction = transfer ( TransferParams ( from_pubkey = alice . pubkey (), to_pubkey = bob . pubkey (), lamports = int ( 0.1 * 1_000_000_000 ) # 0.1 SOL ) ) # Get recent blockhash recent_blockhash_resp = await connection . get_latest_blockhash () recent_blockhash = recent_blockhash_resp . value . blockhash # Create message message = MessageV0 . try_compile ( payer = fee_payer . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = recent_blockhash ) # 2. Sign Transaction (offline) # This can be done offline with saved private keys transaction = VersionedTransaction ( message , [ fee_payer , alice ]) # 3. Serialize transaction for offline storage/transmission serialized_tx = bytes ( transaction ) print ( f \"Serialized transaction length: { len ( serialized_tx ) } bytes\" ) # 4. Recover Transaction (from serialized data) # This simulates loading a transaction from offline storage recovered_transaction = VersionedTransaction . from_bytes ( serialized_tx ) # 5. Send Transaction (online) async with connection : try : signature = await connection . send_transaction ( recovered_transaction ) print ( f \"Transaction sent with signature: { signature . value } \" ) # Confirm transaction await connection . confirm_transaction ( signature . value ) print ( \"Transaction confirmed\" ) except Exception as e : print ( f \"Error sending transaction: { e } \" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Example"},{"location":"cookbook/transaction-operations/offline-transactions/#explanation","text":"This example demonstrates the offline transaction workflow: Create Transaction : Build the transaction with all necessary instructions Sign Transaction : Sign with private keys (can be done offline) Serialize Transaction : Convert to bytes for storage or transmission Recover Transaction : Deserialize the transaction bytes Send Transaction : Submit to the network when online","title":"Explanation"},{"location":"cookbook/transaction-operations/offline-transactions/#key-concepts","text":"Offline Signing : Signing transactions without network connectivity Transaction Serialization : Converting transactions to bytes for storage Security Benefits : Private keys never exposed to online environments Cold Storage : Keeping signing keys on offline devices Transaction Recovery : Reconstructing transactions from serialized data","title":"Key Concepts"},{"location":"cookbook/transaction-operations/offline-transactions/#usage","text":"To run this example: Install required dependencies: pip install solana-py solders nacl Start a local Solana validator: solana-test-validator Run the script: python offline_transactions.py","title":"Usage"},{"location":"cookbook/transaction-operations/offline-transactions/#offline-workflow","text":"","title":"Offline Workflow"},{"location":"cookbook/transaction-operations/offline-transactions/#step-1-online-preparation","text":"Get recent blockhash Prepare transaction instructions Export transaction template","title":"Step 1: Online (Preparation)"},{"location":"cookbook/transaction-operations/offline-transactions/#step-2-offline-signing","text":"Load private keys from secure storage Sign the transaction Save signed transaction","title":"Step 2: Offline (Signing)"},{"location":"cookbook/transaction-operations/offline-transactions/#step-3-online-broadcasting","text":"Load signed transaction Send to network Confirm transaction","title":"Step 3: Online (Broadcasting)"},{"location":"cookbook/transaction-operations/offline-transactions/#security-benefits","text":"Air-gapped Signing : Private keys never touch online systems Reduced Attack Surface : Minimize online exposure Hardware Security : Compatible with hardware wallets Audit Trail : Clear separation of signing and broadcasting","title":"Security Benefits"},{"location":"cookbook/transaction-operations/offline-transactions/#use-cases","text":"High-value Transactions : Large transfers requiring maximum security Institutional Trading : Enterprise-grade security requirements Multi-signature Wallets : Collecting signatures from multiple parties Cold Storage Operations : Managing funds in cold storage Note: Recent blockhashes expire after about 2 minutes, so offline transactions must be submitted promptly after signing.","title":"Use Cases"},{"location":"cookbook/transaction-operations/optimize-compute-requested/","text":"Optimize Compute Requested Learn how to optimize compute unit requests for Solana transactions to reduce costs and improve efficiency. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Optimize Compute Requested \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.compute_budget import set_compute_unit_limit , set_compute_unit_price async def get_simulation_compute_units ( rpc , instructions , payer_pubkey , lookup_tables = []): \"\"\"Simulate transaction to get actual compute units needed\"\"\" try : recent_blockhash = await rpc . get_latest_blockhash () message = MessageV0 . try_compile ( payer = payer_pubkey , instructions = instructions , address_lookup_table_accounts = lookup_tables , recent_blockhash = recent_blockhash . value . blockhash ) transaction = VersionedTransaction ( message , []) simulation_result = await rpc . simulate_transaction ( transaction ) if simulation_result . value . err : print ( f \"Simulation error: { simulation_result . value . err } \" ) return 200000 # Fallback value units_consumed = simulation_result . value . units_consumed if units_consumed : return units_consumed else : return 200000 # Fallback value except Exception as e : print ( f \"Error during simulation: { e } \" ) return 200000 # Fallback value async def build_optimal_transaction ( rpc , instructions , signer , lookup_tables = []): \"\"\"Build optimal transaction with precise compute unit limits\"\"\" micro_lamports = 100 # Priority fee per compute unit units = await get_simulation_compute_units ( rpc , instructions , signer . pubkey (), lookup_tables ) recent_blockhash = await rpc . get_latest_blockhash () # Add compute budget instructions compute_budget_instructions = [ set_compute_unit_limit ( units ), set_compute_unit_price ( micro_lamports ) ] all_instructions = compute_budget_instructions + instructions message = MessageV0 . try_compile ( payer = signer . pubkey (), instructions = all_instructions , address_lookup_table_accounts = lookup_tables , recent_blockhash = recent_blockhash . value . blockhash ) return VersionedTransaction ( message , [ signer ]) async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () amount = 1_000_000_000 # 1 SOL async with rpc : # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = amount ) ) # Build optimized transaction optimized_transaction = await build_optimal_transaction ( rpc , [ transfer_instruction ], sender ) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Transfer Amount: { amount / 1_000_000_000 } SOL\" ) print ( f \"Optimized transaction created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation This example demonstrates how to optimize compute unit requests: Simulate Transaction : Use simulate_transaction() to get actual compute units needed Get Optimal Units : Determine the precise compute units required Set Compute Limits : Use set_compute_unit_limit() to avoid overpaying Add Priority Fees : Set compute unit price for priority processing Build Optimal Transaction : Combine all instructions efficiently Key Concepts Compute Units : Measure of computational resources needed for transaction processing Compute Budget Program : System program for managing compute unit limits and pricing Transaction Simulation : Testing transaction execution without actually submitting it Compute Unit Limit : Maximum compute units a transaction can consume Compute Unit Price : Price per compute unit in micro-lamports Usage To run this example: Install required dependencies: pip install solana-py solders Run the script: python optimize_compute_requested.py Benefits Cost Reduction : Pay only for actual compute units used Efficiency : Avoid over-allocating compute resources Faster Processing : Optimal compute budgets can improve transaction processing Network Health : Better resource utilization for the network Best Practices Always Simulate : Use transaction simulation before submission Add Buffer : Add small buffer (10-20%) to simulation results Monitor Usage : Track compute unit consumption patterns Update Regularly : Recheck compute requirements as programs change Note: Compute unit optimization is especially important for complex transactions and during network congestion.","title":"Optimize Compute Requested"},{"location":"cookbook/transaction-operations/optimize-compute-requested/#optimize-compute-requested","text":"Learn how to optimize compute unit requests for Solana transactions to reduce costs and improve efficiency.","title":"Optimize Compute Requested"},{"location":"cookbook/transaction-operations/optimize-compute-requested/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Optimize Compute Requested \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 from solders.compute_budget import set_compute_unit_limit , set_compute_unit_price async def get_simulation_compute_units ( rpc , instructions , payer_pubkey , lookup_tables = []): \"\"\"Simulate transaction to get actual compute units needed\"\"\" try : recent_blockhash = await rpc . get_latest_blockhash () message = MessageV0 . try_compile ( payer = payer_pubkey , instructions = instructions , address_lookup_table_accounts = lookup_tables , recent_blockhash = recent_blockhash . value . blockhash ) transaction = VersionedTransaction ( message , []) simulation_result = await rpc . simulate_transaction ( transaction ) if simulation_result . value . err : print ( f \"Simulation error: { simulation_result . value . err } \" ) return 200000 # Fallback value units_consumed = simulation_result . value . units_consumed if units_consumed : return units_consumed else : return 200000 # Fallback value except Exception as e : print ( f \"Error during simulation: { e } \" ) return 200000 # Fallback value async def build_optimal_transaction ( rpc , instructions , signer , lookup_tables = []): \"\"\"Build optimal transaction with precise compute unit limits\"\"\" micro_lamports = 100 # Priority fee per compute unit units = await get_simulation_compute_units ( rpc , instructions , signer . pubkey (), lookup_tables ) recent_blockhash = await rpc . get_latest_blockhash () # Add compute budget instructions compute_budget_instructions = [ set_compute_unit_limit ( units ), set_compute_unit_price ( micro_lamports ) ] all_instructions = compute_budget_instructions + instructions message = MessageV0 . try_compile ( payer = signer . pubkey (), instructions = all_instructions , address_lookup_table_accounts = lookup_tables , recent_blockhash = recent_blockhash . value . blockhash ) return VersionedTransaction ( message , [ signer ]) async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () amount = 1_000_000_000 # 1 SOL async with rpc : # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = amount ) ) # Build optimized transaction optimized_transaction = await build_optimal_transaction ( rpc , [ transfer_instruction ], sender ) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Transfer Amount: { amount / 1_000_000_000 } SOL\" ) print ( f \"Optimized transaction created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Example"},{"location":"cookbook/transaction-operations/optimize-compute-requested/#explanation","text":"This example demonstrates how to optimize compute unit requests: Simulate Transaction : Use simulate_transaction() to get actual compute units needed Get Optimal Units : Determine the precise compute units required Set Compute Limits : Use set_compute_unit_limit() to avoid overpaying Add Priority Fees : Set compute unit price for priority processing Build Optimal Transaction : Combine all instructions efficiently","title":"Explanation"},{"location":"cookbook/transaction-operations/optimize-compute-requested/#key-concepts","text":"Compute Units : Measure of computational resources needed for transaction processing Compute Budget Program : System program for managing compute unit limits and pricing Transaction Simulation : Testing transaction execution without actually submitting it Compute Unit Limit : Maximum compute units a transaction can consume Compute Unit Price : Price per compute unit in micro-lamports","title":"Key Concepts"},{"location":"cookbook/transaction-operations/optimize-compute-requested/#usage","text":"To run this example: Install required dependencies: pip install solana-py solders Run the script: python optimize_compute_requested.py","title":"Usage"},{"location":"cookbook/transaction-operations/optimize-compute-requested/#benefits","text":"Cost Reduction : Pay only for actual compute units used Efficiency : Avoid over-allocating compute resources Faster Processing : Optimal compute budgets can improve transaction processing Network Health : Better resource utilization for the network","title":"Benefits"},{"location":"cookbook/transaction-operations/optimize-compute-requested/#best-practices","text":"Always Simulate : Use transaction simulation before submission Add Buffer : Add small buffer (10-20%) to simulation results Monitor Usage : Track compute unit consumption patterns Update Regularly : Recheck compute requirements as programs change Note: Compute unit optimization is especially important for complex transactions and during network congestion.","title":"Best Practices"},{"location":"cookbook/transaction-operations/send-sol/","text":"Send SOL Learn how to send SOL (Solana's native cryptocurrency) between accounts using the Solana Python library. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Send SOL \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () LAMPORTS_PER_SOL = 1_000_000_000 transfer_amount = LAMPORTS_PER_SOL // 100 # 0.01 SOL async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = transfer_amount ) ) # Create message message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Transfer Amount: { transfer_amount / LAMPORTS_PER_SOL } SOL\" ) print ( f \"Transaction created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation This example demonstrates the basic process of sending SOL from one account to another: Create RPC Client : Connect to the Solana devnet using AsyncClient Generate Keypairs : Create sender and recipient keypairs (in practice, you would use existing keypairs) Set Transfer Amount : Define the amount to transfer in lamports (1 SOL = 1,000,000,000 lamports) Get Latest Blockhash : Required for transaction validity Create Transfer Instruction : Use the system program's transfer function Compile Message : Create a message with the transfer instruction Create Transaction : Build a versioned transaction with the message and signatures Key Concepts Lamports : The smallest unit of SOL (1 SOL = 1,000,000,000 lamports) System Program : Built-in program that handles basic operations like transfers Versioned Transactions : Modern transaction format supporting lookup tables Blockhash : Recent blockhash ensures transaction validity and prevents replay attacks Usage To run this example: Install required dependencies: pip install solana-py solders Ensure the sender account has sufficient SOL balance on devnet Run the script: python send_sol.py Note: This example creates the transaction but doesn't submit it to the network. To actually send the transaction, you would need to call rpc.send_transaction(transaction) .","title":"Send SOL"},{"location":"cookbook/transaction-operations/send-sol/#send-sol","text":"Learn how to send SOL (Solana's native cryptocurrency) between accounts using the Solana Python library.","title":"Send SOL"},{"location":"cookbook/transaction-operations/send-sol/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Send SOL \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.system_program import transfer , TransferParams from solders.transaction import VersionedTransaction from solders.message import MessageV0 async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () LAMPORTS_PER_SOL = 1_000_000_000 transfer_amount = LAMPORTS_PER_SOL // 100 # 0.01 SOL async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create transfer instruction transfer_instruction = transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = recipient . pubkey (), lamports = transfer_amount ) ) # Create message message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Transfer Amount: { transfer_amount / LAMPORTS_PER_SOL } SOL\" ) print ( f \"Transaction created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Example"},{"location":"cookbook/transaction-operations/send-sol/#explanation","text":"This example demonstrates the basic process of sending SOL from one account to another: Create RPC Client : Connect to the Solana devnet using AsyncClient Generate Keypairs : Create sender and recipient keypairs (in practice, you would use existing keypairs) Set Transfer Amount : Define the amount to transfer in lamports (1 SOL = 1,000,000,000 lamports) Get Latest Blockhash : Required for transaction validity Create Transfer Instruction : Use the system program's transfer function Compile Message : Create a message with the transfer instruction Create Transaction : Build a versioned transaction with the message and signatures","title":"Explanation"},{"location":"cookbook/transaction-operations/send-sol/#key-concepts","text":"Lamports : The smallest unit of SOL (1 SOL = 1,000,000,000 lamports) System Program : Built-in program that handles basic operations like transfers Versioned Transactions : Modern transaction format supporting lookup tables Blockhash : Recent blockhash ensures transaction validity and prevents replay attacks","title":"Key Concepts"},{"location":"cookbook/transaction-operations/send-sol/#usage","text":"To run this example: Install required dependencies: pip install solana-py solders Ensure the sender account has sufficient SOL balance on devnet Run the script: python send_sol.py Note: This example creates the transaction but doesn't submit it to the network. To actually send the transaction, you would need to call rpc.send_transaction(transaction) .","title":"Usage"},{"location":"cookbook/transaction-operations/send-tokens/","text":"Send Tokens Learn how to send SPL tokens between accounts using the Solana Python library. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Send Tokens \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import transfer_checked , TransferCheckedParams from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () # Example token mint (USDC devnet) token_mint = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) # Example token accounts (would need to be created first) sender_token_account = Pubkey . from_string ( \"11111111111111111111111111111111\" ) recipient_token_account = Pubkey . from_string ( \"11111111111111111111111111111111\" ) amount = 1_000_000 # 1 token (6 decimals) decimals = 6 async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create transfer instruction transfer_instruction = transfer_checked ( TransferCheckedParams ( program_id = TOKEN_PROGRAM_ID , source = sender_token_account , mint = token_mint , dest = recipient_token_account , owner = sender . pubkey (), amount = amount , decimals = decimals ) ) # Create message message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Token Mint: { token_mint } \" ) print ( f \"Transfer Amount: { amount / ( 10 ** decimals ) } tokens\" ) print ( f \"Transaction created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ()) Explanation This example demonstrates how to send SPL tokens between accounts: Create RPC Client : Connect to the Solana devnet Setup Accounts : Define sender, recipient, and token mint Token Accounts : Specify source and destination token accounts Transfer Parameters : Set amount and decimals for the token Create Transfer Instruction : Use transfer_checked for secure transfers Compile Message : Create a message with the transfer instruction Create Transaction : Build a versioned transaction Key Concepts SPL Tokens : Standard tokens on Solana (like ERC-20 on Ethereum) Token Mint : The address that identifies the token type Token Accounts : Accounts that hold tokens for a specific mint Transfer Checked : Safer transfer method that verifies mint and decimals Decimals : Number of decimal places for the token (e.g., 6 for USDC) Usage To run this example: Install required dependencies: pip install solana-py solders spl-token Ensure you have: Valid token accounts for sender and recipient Sufficient token balance in the sender's account The correct token mint address Run the script: python send_tokens.py Note: This example creates the transaction but doesn't submit it. You'll need to create actual token accounts and call rpc.send_transaction(transaction) to execute the transfer.","title":"Send Tokens"},{"location":"cookbook/transaction-operations/send-tokens/#send-tokens","text":"Learn how to send SPL tokens between accounts using the Solana Python library.","title":"Send Tokens"},{"location":"cookbook/transaction-operations/send-tokens/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Send Tokens \"\"\" import asyncio from solana.rpc.async_api import AsyncClient from solders.keypair import Keypair from solders.pubkey import Pubkey from solders.transaction import VersionedTransaction from solders.message import MessageV0 from spl.token.instructions import transfer_checked , TransferCheckedParams from spl.token.constants import TOKEN_PROGRAM_ID async def main (): rpc = AsyncClient ( \"https://api.devnet.solana.com\" ) sender = Keypair () recipient = Keypair () # Example token mint (USDC devnet) token_mint = Pubkey . from_string ( \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" ) # Example token accounts (would need to be created first) sender_token_account = Pubkey . from_string ( \"11111111111111111111111111111111\" ) recipient_token_account = Pubkey . from_string ( \"11111111111111111111111111111111\" ) amount = 1_000_000 # 1 token (6 decimals) decimals = 6 async with rpc : # Get latest blockhash latest_blockhash = await rpc . get_latest_blockhash () # Create transfer instruction transfer_instruction = transfer_checked ( TransferCheckedParams ( program_id = TOKEN_PROGRAM_ID , source = sender_token_account , mint = token_mint , dest = recipient_token_account , owner = sender . pubkey (), amount = amount , decimals = decimals ) ) # Create message message = MessageV0 . try_compile ( payer = sender . pubkey (), instructions = [ transfer_instruction ], address_lookup_table_accounts = [], recent_blockhash = latest_blockhash . value . blockhash ) # Create transaction transaction = VersionedTransaction ( message , [ sender ]) print ( f \"Sender: { sender . pubkey () } \" ) print ( f \"Recipient: { recipient . pubkey () } \" ) print ( f \"Token Mint: { token_mint } \" ) print ( f \"Transfer Amount: { amount / ( 10 ** decimals ) } tokens\" ) print ( f \"Transaction created successfully\" ) if __name__ == \"__main__\" : asyncio . run ( main ())","title":"Code Example"},{"location":"cookbook/transaction-operations/send-tokens/#explanation","text":"This example demonstrates how to send SPL tokens between accounts: Create RPC Client : Connect to the Solana devnet Setup Accounts : Define sender, recipient, and token mint Token Accounts : Specify source and destination token accounts Transfer Parameters : Set amount and decimals for the token Create Transfer Instruction : Use transfer_checked for secure transfers Compile Message : Create a message with the transfer instruction Create Transaction : Build a versioned transaction","title":"Explanation"},{"location":"cookbook/transaction-operations/send-tokens/#key-concepts","text":"SPL Tokens : Standard tokens on Solana (like ERC-20 on Ethereum) Token Mint : The address that identifies the token type Token Accounts : Accounts that hold tokens for a specific mint Transfer Checked : Safer transfer method that verifies mint and decimals Decimals : Number of decimal places for the token (e.g., 6 for USDC)","title":"Key Concepts"},{"location":"cookbook/transaction-operations/send-tokens/#usage","text":"To run this example: Install required dependencies: pip install solana-py solders spl-token Ensure you have: Valid token accounts for sender and recipient Sufficient token balance in the sender's account The correct token mint address Run the script: python send_tokens.py Note: This example creates the transaction but doesn't submit it. You'll need to create actual token accounts and call rpc.send_transaction(transaction) to execute the transfer.","title":"Usage"},{"location":"cookbook/wallet-management/create-keypair/","text":"Create Keypair Learn how to create a new Solana keypair for wallet management and account operations. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create a Keypair \"\"\" from solders.keypair import Keypair def main (): # Generate a new keypair keypair = Keypair () print ( f \"address: { keypair . pubkey () } \" ) print ( f \"secret: { keypair . secret () } \" ) if __name__ == \"__main__\" : main () Explanation This example demonstrates the simplest way to create a new Solana keypair: Import Keypair : Import the Keypair class from the solders library Generate Keypair : Call Keypair() to create a new random keypair Access Public Key : Use keypair.pubkey() to get the public address Access Secret Key : Use keypair.secret() to get the private key bytes Key Concepts Keypair : A public-private key pair used for Solana account operations Public Key : The account address that can be safely shared Private Key : The secret key that must be kept secure and never shared Cryptographic Security : Uses Ed25519 elliptic curve cryptography Random Generation : Each keypair is cryptographically randomly generated Usage To run this example: Install required dependencies: pip install solders Run the script: python create_keypair.py The output will show: - address : The public key (account address) - secret : The private key as bytes (keep this secure!) Security Considerations Never share your private key : Anyone with the private key has full control of the account Store securely : Save private keys in encrypted storage or hardware wallets Backup safely : Create secure backups of your keypairs Generate offline : For maximum security, generate keypairs on offline systems Use Cases New Wallet Creation : Generate fresh wallets for users Testing : Create temporary keypairs for development and testing Account Management : Generate keypairs for different purposes (trading, staking, etc.) Multi-signature Setup : Create multiple keypairs for multi-sig wallets Note: This example generates a completely random keypair. For production use, ensure you have proper backup and recovery mechanisms in place.","title":"Create Keypair"},{"location":"cookbook/wallet-management/create-keypair/#create-keypair","text":"Learn how to create a new Solana keypair for wallet management and account operations.","title":"Create Keypair"},{"location":"cookbook/wallet-management/create-keypair/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Create a Keypair \"\"\" from solders.keypair import Keypair def main (): # Generate a new keypair keypair = Keypair () print ( f \"address: { keypair . pubkey () } \" ) print ( f \"secret: { keypair . secret () } \" ) if __name__ == \"__main__\" : main ()","title":"Code Example"},{"location":"cookbook/wallet-management/create-keypair/#explanation","text":"This example demonstrates the simplest way to create a new Solana keypair: Import Keypair : Import the Keypair class from the solders library Generate Keypair : Call Keypair() to create a new random keypair Access Public Key : Use keypair.pubkey() to get the public address Access Secret Key : Use keypair.secret() to get the private key bytes","title":"Explanation"},{"location":"cookbook/wallet-management/create-keypair/#key-concepts","text":"Keypair : A public-private key pair used for Solana account operations Public Key : The account address that can be safely shared Private Key : The secret key that must be kept secure and never shared Cryptographic Security : Uses Ed25519 elliptic curve cryptography Random Generation : Each keypair is cryptographically randomly generated","title":"Key Concepts"},{"location":"cookbook/wallet-management/create-keypair/#usage","text":"To run this example: Install required dependencies: pip install solders Run the script: python create_keypair.py The output will show: - address : The public key (account address) - secret : The private key as bytes (keep this secure!)","title":"Usage"},{"location":"cookbook/wallet-management/create-keypair/#security-considerations","text":"Never share your private key : Anyone with the private key has full control of the account Store securely : Save private keys in encrypted storage or hardware wallets Backup safely : Create secure backups of your keypairs Generate offline : For maximum security, generate keypairs on offline systems","title":"Security Considerations"},{"location":"cookbook/wallet-management/create-keypair/#use-cases","text":"New Wallet Creation : Generate fresh wallets for users Testing : Create temporary keypairs for development and testing Account Management : Generate keypairs for different purposes (trading, staking, etc.) Multi-signature Setup : Create multiple keypairs for multi-sig wallets Note: This example generates a completely random keypair. For production use, ensure you have proper backup and recovery mechanisms in place.","title":"Use Cases"},{"location":"cookbook/wallet-management/restore-keypair/","text":"Restore Keypair Learn how to restore a Solana keypair from existing private key bytes for wallet recovery operations. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Restore a Keypair \"\"\" from solders.keypair import Keypair def main (): keypair_bytes = bytes ([ 174 , 47 , 154 , 16 , 202 , 193 , 206 , 113 , 199 , 190 , 53 , 133 , 169 , 175 , 31 , 56 , 222 , 53 , 138 , 189 , 224 , 216 , 117 , 173 , 10 , 149 , 53 , 45 , 73 , 251 , 237 , 246 , 15 , 185 , 186 , 82 , 177 , 240 , 148 , 69 , 241 , 227 , 167 , 80 , 141 , 89 , 240 , 121 , 121 , 35 , 172 , 247 , 68 , 251 , 226 , 218 , 48 , 63 , 176 , 109 , 168 , 89 , 238 , 135 ]) signer = Keypair . from_bytes ( keypair_bytes ) print ( signer . pubkey ()) if __name__ == \"__main__\" : main () Explanation This example demonstrates how to restore a keypair from existing private key bytes: Define Private Key : Create a bytes array containing the 64-byte private key Restore Keypair : Use Keypair.from_bytes() to reconstruct the keypair Access Public Key : The restored keypair provides access to the public key Verify Restoration : Print the public key to verify successful restoration Key Concepts Keypair Restoration : Rebuilding a keypair from stored private key bytes Private Key Format : Solana private keys are 64 bytes (32 bytes seed + 32 bytes public key) Deterministic Recovery : Same private key bytes always produce the same keypair Wallet Recovery : Essential for restoring access to existing accounts Usage To run this example: Install required dependencies: pip install solders Run the script: python restore_keypair.py The output will show the public key address corresponding to the restored keypair. Common Use Cases From File Storage # Read private key from file with open ( 'private_key.txt' , 'rb' ) as f : private_key_bytes = f . read () keypair = Keypair . from_bytes ( private_key_bytes ) From Base58 String import base58 # Convert from base58 string format private_key_string = \"your_base58_private_key_here\" private_key_bytes = base58 . b58decode ( private_key_string ) keypair = Keypair . from_bytes ( private_key_bytes ) From Environment Variable import os import base58 # Load from environment variable private_key_env = os . getenv ( 'SOLANA_PRIVATE_KEY' ) if private_key_env : private_key_bytes = base58 . b58decode ( private_key_env ) keypair = Keypair . from_bytes ( private_key_bytes ) Security Considerations Secure Storage : Never store private keys in plain text Environment Variables : Use secure environment variables for production File Permissions : Ensure private key files have restricted permissions Backup Verification : Always verify restored keypairs match expected addresses Error Handling try : keypair = Keypair . from_bytes ( keypair_bytes ) print ( f \"Successfully restored keypair: { keypair . pubkey () } \" ) except Exception as e : print ( f \"Failed to restore keypair: { e } \" ) Note: The example shows a sample private key for demonstration. Never use this key for actual transactions as it's publicly visible.","title":"Restore Keypair"},{"location":"cookbook/wallet-management/restore-keypair/#restore-keypair","text":"Learn how to restore a Solana keypair from existing private key bytes for wallet recovery operations.","title":"Restore Keypair"},{"location":"cookbook/wallet-management/restore-keypair/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Restore a Keypair \"\"\" from solders.keypair import Keypair def main (): keypair_bytes = bytes ([ 174 , 47 , 154 , 16 , 202 , 193 , 206 , 113 , 199 , 190 , 53 , 133 , 169 , 175 , 31 , 56 , 222 , 53 , 138 , 189 , 224 , 216 , 117 , 173 , 10 , 149 , 53 , 45 , 73 , 251 , 237 , 246 , 15 , 185 , 186 , 82 , 177 , 240 , 148 , 69 , 241 , 227 , 167 , 80 , 141 , 89 , 240 , 121 , 121 , 35 , 172 , 247 , 68 , 251 , 226 , 218 , 48 , 63 , 176 , 109 , 168 , 89 , 238 , 135 ]) signer = Keypair . from_bytes ( keypair_bytes ) print ( signer . pubkey ()) if __name__ == \"__main__\" : main ()","title":"Code Example"},{"location":"cookbook/wallet-management/restore-keypair/#explanation","text":"This example demonstrates how to restore a keypair from existing private key bytes: Define Private Key : Create a bytes array containing the 64-byte private key Restore Keypair : Use Keypair.from_bytes() to reconstruct the keypair Access Public Key : The restored keypair provides access to the public key Verify Restoration : Print the public key to verify successful restoration","title":"Explanation"},{"location":"cookbook/wallet-management/restore-keypair/#key-concepts","text":"Keypair Restoration : Rebuilding a keypair from stored private key bytes Private Key Format : Solana private keys are 64 bytes (32 bytes seed + 32 bytes public key) Deterministic Recovery : Same private key bytes always produce the same keypair Wallet Recovery : Essential for restoring access to existing accounts","title":"Key Concepts"},{"location":"cookbook/wallet-management/restore-keypair/#usage","text":"To run this example: Install required dependencies: pip install solders Run the script: python restore_keypair.py The output will show the public key address corresponding to the restored keypair.","title":"Usage"},{"location":"cookbook/wallet-management/restore-keypair/#common-use-cases","text":"","title":"Common Use Cases"},{"location":"cookbook/wallet-management/restore-keypair/#from-file-storage","text":"# Read private key from file with open ( 'private_key.txt' , 'rb' ) as f : private_key_bytes = f . read () keypair = Keypair . from_bytes ( private_key_bytes )","title":"From File Storage"},{"location":"cookbook/wallet-management/restore-keypair/#from-base58-string","text":"import base58 # Convert from base58 string format private_key_string = \"your_base58_private_key_here\" private_key_bytes = base58 . b58decode ( private_key_string ) keypair = Keypair . from_bytes ( private_key_bytes )","title":"From Base58 String"},{"location":"cookbook/wallet-management/restore-keypair/#from-environment-variable","text":"import os import base58 # Load from environment variable private_key_env = os . getenv ( 'SOLANA_PRIVATE_KEY' ) if private_key_env : private_key_bytes = base58 . b58decode ( private_key_env ) keypair = Keypair . from_bytes ( private_key_bytes )","title":"From Environment Variable"},{"location":"cookbook/wallet-management/restore-keypair/#security-considerations","text":"Secure Storage : Never store private keys in plain text Environment Variables : Use secure environment variables for production File Permissions : Ensure private key files have restricted permissions Backup Verification : Always verify restored keypairs match expected addresses","title":"Security Considerations"},{"location":"cookbook/wallet-management/restore-keypair/#error-handling","text":"try : keypair = Keypair . from_bytes ( keypair_bytes ) print ( f \"Successfully restored keypair: { keypair . pubkey () } \" ) except Exception as e : print ( f \"Failed to restore keypair: { e } \" ) Note: The example shows a sample private key for demonstration. Never use this key for actual transactions as it's publicly visible.","title":"Error Handling"},{"location":"cookbook/wallet-management/sign-verify-message/","text":"Sign and Verify Message Learn how to sign messages with a Solana keypair and verify message signatures for authentication and integrity verification. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Sign and Verify a Message \"\"\" from solders.keypair import Keypair from solders.pubkey import Pubkey import nacl.signing import nacl.encoding def main (): # Create a keypair keypair = Keypair () message = b \"Hello, Solana!\" # Sign the message signature = keypair . sign_message ( message ) print ( f \"Message: { message } \" ) print ( f \"Signature: { signature } \" ) print ( f \"Public Key: { keypair . pubkey () } \" ) # Verify the signature try : # Use nacl to verify the signature verify_key = nacl . signing . VerifyKey ( keypair . pubkey () . __bytes__ ()) verify_key . verify ( message , signature . __bytes__ ()) print ( \"Signature is valid: True\" ) except Exception as e : print ( f \"Signature is valid: False - { e } \" ) if __name__ == \"__main__\" : main () Explanation This example demonstrates message signing and verification: Create Keypair : Generate a new keypair for signing Define Message : Create a message to sign (as bytes) Sign Message : Use keypair.sign_message() to create a signature Verify Signature : Use NaCl library to verify the signature's authenticity Handle Verification : Catch exceptions if signature verification fails Key Concepts Digital Signatures : Cryptographic proof that a message was signed by a specific private key Message Signing : Creating a signature that proves ownership of a private key Signature Verification : Confirming that a signature was created by the holder of a private key Ed25519 Signatures : Solana uses Ed25519 elliptic curve signatures Non-repudiation : Signed messages provide proof of authenticity Usage To run this example: Install required dependencies: pip install solders pynacl Run the script: python sign_verify_message.py The output will show the message, signature, public key, and verification result. Extended Examples Sign and Verify with Different Keys def demonstrate_signature_verification (): \"\"\"Demonstrate signature verification with different keypairs\"\"\" # Create signer keypair signer = Keypair () message = b \"This is a test message\" # Sign the message signature = signer . sign_message ( message ) # Verify with correct public key try : verify_key = nacl . signing . VerifyKey ( signer . pubkey () . __bytes__ ()) verify_key . verify ( message , signature . __bytes__ ()) print ( \"\u2713 Signature verified with correct public key\" ) except : print ( \"\u2717 Signature verification failed\" ) # Try to verify with wrong public key wrong_keypair = Keypair () try : wrong_verify_key = nacl . signing . VerifyKey ( wrong_keypair . pubkey () . __bytes__ ()) wrong_verify_key . verify ( message , signature . __bytes__ ()) print ( \"\u2717 This should not happen - wrong key verified!\" ) except : print ( \"\u2713 Signature correctly rejected with wrong public key\" ) Message Authentication Function def authenticate_message ( message : bytes , signature : bytes , public_key : Pubkey ) -> bool : \"\"\"Authenticate a message with its signature and public key\"\"\" try : verify_key = nacl . signing . VerifyKey ( public_key . __bytes__ ()) verify_key . verify ( message , signature ) return True except Exception : return False # Usage keypair = Keypair () message = b \"Authenticate this message\" signature = keypair . sign_message ( message ) is_authentic = authenticate_message ( message , signature . __bytes__ (), keypair . pubkey ()) print ( f \"Message is authentic: { is_authentic } \" ) Batch Message Verification def verify_multiple_messages ( messages_and_signatures : list ) -> dict : \"\"\"Verify multiple message-signature pairs\"\"\" results = {} for i , ( message , signature , public_key ) in enumerate ( messages_and_signatures ): try : verify_key = nacl . signing . VerifyKey ( public_key . __bytes__ ()) verify_key . verify ( message , signature ) results [ f \"message_ { i } \" ] = True except Exception as e : results [ f \"message_ { i } \" ] = False return results Practical Applications User Authentication def authenticate_user ( user_address : str , challenge : bytes , signature : bytes ) -> bool : \"\"\"Authenticate a user by verifying they signed a challenge\"\"\" try : public_key = Pubkey . from_string ( user_address ) verify_key = nacl . signing . VerifyKey ( public_key . __bytes__ ()) verify_key . verify ( challenge , signature ) return True except : return False Message Integrity def create_signed_message ( keypair : Keypair , message : str ) -> dict : \"\"\"Create a signed message with metadata\"\"\" message_bytes = message . encode ( 'utf-8' ) signature = keypair . sign_message ( message_bytes ) return { \"message\" : message , \"signature\" : signature . __bytes__ () . hex (), \"public_key\" : str ( keypair . pubkey ()), \"timestamp\" : int ( time . time ()) } def verify_signed_message ( signed_message : dict ) -> bool : \"\"\"Verify a signed message with metadata\"\"\" try : message_bytes = signed_message [ \"message\" ] . encode ( 'utf-8' ) signature = bytes . fromhex ( signed_message [ \"signature\" ]) public_key = Pubkey . from_string ( signed_message [ \"public_key\" ]) verify_key = nacl . signing . VerifyKey ( public_key . __bytes__ ()) verify_key . verify ( message_bytes , signature ) return True except : return False Security Considerations Message Format : Always use bytes for message signing Signature Storage : Store signatures securely and never reuse them Public Key Validation : Always validate public keys before verification Replay Protection : Include timestamps or nonces in messages Error Handling : Properly handle verification failures Common Use Cases Wallet Authentication : Prove ownership of a wallet address Message Integrity : Ensure messages haven't been tampered with API Authentication : Authenticate API requests with signatures Decentralized Identity : Create cryptographic proof of identity Smart Contract Interactions : Sign off-chain messages for on-chain verification Error Handling def safe_sign_and_verify ( keypair : Keypair , message : bytes ) -> tuple : \"\"\"Safely sign and verify a message with error handling\"\"\" try : signature = keypair . sign_message ( message ) verify_key = nacl . signing . VerifyKey ( keypair . pubkey () . __bytes__ ()) verify_key . verify ( message , signature . __bytes__ ()) return True , signature except Exception as e : return False , f \"Error: { e } \" Note: Message signing is different from transaction signing - it's used for authentication and integrity verification rather than blockchain transactions.","title":"Sign and Verify Message"},{"location":"cookbook/wallet-management/sign-verify-message/#sign-and-verify-message","text":"Learn how to sign messages with a Solana keypair and verify message signatures for authentication and integrity verification.","title":"Sign and Verify Message"},{"location":"cookbook/wallet-management/sign-verify-message/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Sign and Verify a Message \"\"\" from solders.keypair import Keypair from solders.pubkey import Pubkey import nacl.signing import nacl.encoding def main (): # Create a keypair keypair = Keypair () message = b \"Hello, Solana!\" # Sign the message signature = keypair . sign_message ( message ) print ( f \"Message: { message } \" ) print ( f \"Signature: { signature } \" ) print ( f \"Public Key: { keypair . pubkey () } \" ) # Verify the signature try : # Use nacl to verify the signature verify_key = nacl . signing . VerifyKey ( keypair . pubkey () . __bytes__ ()) verify_key . verify ( message , signature . __bytes__ ()) print ( \"Signature is valid: True\" ) except Exception as e : print ( f \"Signature is valid: False - { e } \" ) if __name__ == \"__main__\" : main ()","title":"Code Example"},{"location":"cookbook/wallet-management/sign-verify-message/#explanation","text":"This example demonstrates message signing and verification: Create Keypair : Generate a new keypair for signing Define Message : Create a message to sign (as bytes) Sign Message : Use keypair.sign_message() to create a signature Verify Signature : Use NaCl library to verify the signature's authenticity Handle Verification : Catch exceptions if signature verification fails","title":"Explanation"},{"location":"cookbook/wallet-management/sign-verify-message/#key-concepts","text":"Digital Signatures : Cryptographic proof that a message was signed by a specific private key Message Signing : Creating a signature that proves ownership of a private key Signature Verification : Confirming that a signature was created by the holder of a private key Ed25519 Signatures : Solana uses Ed25519 elliptic curve signatures Non-repudiation : Signed messages provide proof of authenticity","title":"Key Concepts"},{"location":"cookbook/wallet-management/sign-verify-message/#usage","text":"To run this example: Install required dependencies: pip install solders pynacl Run the script: python sign_verify_message.py The output will show the message, signature, public key, and verification result.","title":"Usage"},{"location":"cookbook/wallet-management/sign-verify-message/#extended-examples","text":"","title":"Extended Examples"},{"location":"cookbook/wallet-management/sign-verify-message/#sign-and-verify-with-different-keys","text":"def demonstrate_signature_verification (): \"\"\"Demonstrate signature verification with different keypairs\"\"\" # Create signer keypair signer = Keypair () message = b \"This is a test message\" # Sign the message signature = signer . sign_message ( message ) # Verify with correct public key try : verify_key = nacl . signing . VerifyKey ( signer . pubkey () . __bytes__ ()) verify_key . verify ( message , signature . __bytes__ ()) print ( \"\u2713 Signature verified with correct public key\" ) except : print ( \"\u2717 Signature verification failed\" ) # Try to verify with wrong public key wrong_keypair = Keypair () try : wrong_verify_key = nacl . signing . VerifyKey ( wrong_keypair . pubkey () . __bytes__ ()) wrong_verify_key . verify ( message , signature . __bytes__ ()) print ( \"\u2717 This should not happen - wrong key verified!\" ) except : print ( \"\u2713 Signature correctly rejected with wrong public key\" )","title":"Sign and Verify with Different Keys"},{"location":"cookbook/wallet-management/sign-verify-message/#message-authentication-function","text":"def authenticate_message ( message : bytes , signature : bytes , public_key : Pubkey ) -> bool : \"\"\"Authenticate a message with its signature and public key\"\"\" try : verify_key = nacl . signing . VerifyKey ( public_key . __bytes__ ()) verify_key . verify ( message , signature ) return True except Exception : return False # Usage keypair = Keypair () message = b \"Authenticate this message\" signature = keypair . sign_message ( message ) is_authentic = authenticate_message ( message , signature . __bytes__ (), keypair . pubkey ()) print ( f \"Message is authentic: { is_authentic } \" )","title":"Message Authentication Function"},{"location":"cookbook/wallet-management/sign-verify-message/#batch-message-verification","text":"def verify_multiple_messages ( messages_and_signatures : list ) -> dict : \"\"\"Verify multiple message-signature pairs\"\"\" results = {} for i , ( message , signature , public_key ) in enumerate ( messages_and_signatures ): try : verify_key = nacl . signing . VerifyKey ( public_key . __bytes__ ()) verify_key . verify ( message , signature ) results [ f \"message_ { i } \" ] = True except Exception as e : results [ f \"message_ { i } \" ] = False return results","title":"Batch Message Verification"},{"location":"cookbook/wallet-management/sign-verify-message/#practical-applications","text":"","title":"Practical Applications"},{"location":"cookbook/wallet-management/sign-verify-message/#user-authentication","text":"def authenticate_user ( user_address : str , challenge : bytes , signature : bytes ) -> bool : \"\"\"Authenticate a user by verifying they signed a challenge\"\"\" try : public_key = Pubkey . from_string ( user_address ) verify_key = nacl . signing . VerifyKey ( public_key . __bytes__ ()) verify_key . verify ( challenge , signature ) return True except : return False","title":"User Authentication"},{"location":"cookbook/wallet-management/sign-verify-message/#message-integrity","text":"def create_signed_message ( keypair : Keypair , message : str ) -> dict : \"\"\"Create a signed message with metadata\"\"\" message_bytes = message . encode ( 'utf-8' ) signature = keypair . sign_message ( message_bytes ) return { \"message\" : message , \"signature\" : signature . __bytes__ () . hex (), \"public_key\" : str ( keypair . pubkey ()), \"timestamp\" : int ( time . time ()) } def verify_signed_message ( signed_message : dict ) -> bool : \"\"\"Verify a signed message with metadata\"\"\" try : message_bytes = signed_message [ \"message\" ] . encode ( 'utf-8' ) signature = bytes . fromhex ( signed_message [ \"signature\" ]) public_key = Pubkey . from_string ( signed_message [ \"public_key\" ]) verify_key = nacl . signing . VerifyKey ( public_key . __bytes__ ()) verify_key . verify ( message_bytes , signature ) return True except : return False","title":"Message Integrity"},{"location":"cookbook/wallet-management/sign-verify-message/#security-considerations","text":"Message Format : Always use bytes for message signing Signature Storage : Store signatures securely and never reuse them Public Key Validation : Always validate public keys before verification Replay Protection : Include timestamps or nonces in messages Error Handling : Properly handle verification failures","title":"Security Considerations"},{"location":"cookbook/wallet-management/sign-verify-message/#common-use-cases","text":"Wallet Authentication : Prove ownership of a wallet address Message Integrity : Ensure messages haven't been tampered with API Authentication : Authenticate API requests with signatures Decentralized Identity : Create cryptographic proof of identity Smart Contract Interactions : Sign off-chain messages for on-chain verification","title":"Common Use Cases"},{"location":"cookbook/wallet-management/sign-verify-message/#error-handling","text":"def safe_sign_and_verify ( keypair : Keypair , message : bytes ) -> tuple : \"\"\"Safely sign and verify a message with error handling\"\"\" try : signature = keypair . sign_message ( message ) verify_key = nacl . signing . VerifyKey ( keypair . pubkey () . __bytes__ ()) verify_key . verify ( message , signature . __bytes__ ()) return True , signature except Exception as e : return False , f \"Error: { e } \" Note: Message signing is different from transaction signing - it's used for authentication and integrity verification rather than blockchain transactions.","title":"Error Handling"},{"location":"cookbook/wallet-management/validate-public-key/","text":"Validate Public Key Learn how to validate Solana public keys to ensure they are properly formatted and cryptographically valid. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Validate a Public Key \"\"\" from solders.pubkey import Pubkey def main (): # on curve address key = Pubkey . from_string ( \"5oNDL3swdJJF1g9DzJiZ4ynHXgszjAEpUkxVYejchzrY\" ) print ( key . is_on_curve ()) off_curve_address = Pubkey . from_string ( \"4BJXYkfvg37zEmBbsacZjeQDpTNx91KppxFJxRqrz48e\" ) print ( off_curve_address . is_on_curve ()) if __name__ == \"__main__\" : main () Explanation This example demonstrates how to validate Solana public keys: Create Public Key : Use Pubkey.from_string() to create a public key from a string Check Curve Validity : Use is_on_curve() to verify if the key is on the Ed25519 curve Validate Different Keys : Test both valid and invalid public keys Return Results : The method returns True for valid keys, False for invalid ones Key Concepts Ed25519 Curve : Solana uses Ed25519 elliptic curve cryptography On-Curve Validation : Public keys must be valid points on the Ed25519 curve Off-Curve Keys : Some addresses may be valid base58 strings but not valid curve points Cryptographic Validity : Different from format validation - checks mathematical validity Usage To run this example: Install required dependencies: pip install solders Run the script: python validate_public_key.py The output will show: - True for the first key (valid curve point) - False for the second key (off-curve address) Extended Validation Function def validate_public_key_comprehensive ( address : str ) -> dict : \"\"\"Comprehensive public key validation with detailed results\"\"\" result = { \"address\" : address , \"is_valid_format\" : False , \"is_on_curve\" : False , \"validation_error\" : None } try : # Check if the address can be parsed as a public key pubkey = Pubkey . from_string ( address ) result [ \"is_valid_format\" ] = True # Check if it's on the Ed25519 curve result [ \"is_on_curve\" ] = pubkey . is_on_curve () except ValueError as e : result [ \"validation_error\" ] = f \"Invalid format: { e } \" except Exception as e : result [ \"validation_error\" ] = f \"Validation error: { e } \" return result # Usage example addresses_to_test = [ \"5oNDL3swdJJF1g9DzJiZ4ynHXgszjAEpUkxVYejchzrY\" , # Valid on-curve \"4BJXYkfvg37zEmBbsacZjeQDpTNx91KppxFJxRqrz48e\" , # Valid format, off-curve \"invalid_address\" , # Invalid format \"11111111111111111111111111111111\" # System program (on-curve) ] for address in addresses_to_test : result = validate_public_key_comprehensive ( address ) print ( f \"Address: { address [: 20 ] } ...\" ) print ( f \" Valid format: { result [ 'is_valid_format' ] } \" ) print ( f \" On curve: { result [ 'is_on_curve' ] } \" ) if result [ 'validation_error' ]: print ( f \" Error: { result [ 'validation_error' ] } \" ) print () Common Use Cases Input Validation def is_valid_solana_address ( address : str ) -> bool : \"\"\"Check if a string is a valid Solana address\"\"\" try : pubkey = Pubkey . from_string ( address ) return pubkey . is_on_curve () except : return False Program Derived Address (PDA) Validation def validate_pda ( address : str ) -> bool : \"\"\"Validate Program Derived Address (should be off-curve)\"\"\" try : pubkey = Pubkey . from_string ( address ) return not pubkey . is_on_curve () # PDAs are off-curve except : return False Batch Validation def validate_multiple_addresses ( addresses : list ) -> dict : \"\"\"Validate multiple addresses at once\"\"\" results = {} for address in addresses : try : pubkey = Pubkey . from_string ( address ) results [ address ] = { \"valid\" : True , \"on_curve\" : pubkey . is_on_curve () } except Exception as e : results [ address ] = { \"valid\" : False , \"error\" : str ( e ) } return results Key Differences On-Curve Keys : Can be used for signing transactions (normal wallet addresses) Off-Curve Keys : Cannot sign but can receive tokens (Program Derived Addresses) Format Validation : Checks if the string is valid base58 and correct length Cryptographic Validation : Checks if the key is a valid point on the Ed25519 curve Security Considerations Always Validate : Validate public keys before using them in transactions Handle Errors : Wrap validation in try-catch blocks User Input : Validate all user-provided addresses PDA Handling : Remember that PDAs are intentionally off-curve Error Types Format Errors : Invalid base58 encoding or incorrect length Curve Validation : Valid format but not on the Ed25519 curve Parsing Errors : Cannot be converted to a Pubkey object Note: Off-curve addresses are not necessarily invalid - they may be Program Derived Addresses that are intentionally off-curve for security reasons.","title":"Validate Public Key"},{"location":"cookbook/wallet-management/validate-public-key/#validate-public-key","text":"Learn how to validate Solana public keys to ensure they are properly formatted and cryptographically valid.","title":"Validate Public Key"},{"location":"cookbook/wallet-management/validate-public-key/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Validate a Public Key \"\"\" from solders.pubkey import Pubkey def main (): # on curve address key = Pubkey . from_string ( \"5oNDL3swdJJF1g9DzJiZ4ynHXgszjAEpUkxVYejchzrY\" ) print ( key . is_on_curve ()) off_curve_address = Pubkey . from_string ( \"4BJXYkfvg37zEmBbsacZjeQDpTNx91KppxFJxRqrz48e\" ) print ( off_curve_address . is_on_curve ()) if __name__ == \"__main__\" : main ()","title":"Code Example"},{"location":"cookbook/wallet-management/validate-public-key/#explanation","text":"This example demonstrates how to validate Solana public keys: Create Public Key : Use Pubkey.from_string() to create a public key from a string Check Curve Validity : Use is_on_curve() to verify if the key is on the Ed25519 curve Validate Different Keys : Test both valid and invalid public keys Return Results : The method returns True for valid keys, False for invalid ones","title":"Explanation"},{"location":"cookbook/wallet-management/validate-public-key/#key-concepts","text":"Ed25519 Curve : Solana uses Ed25519 elliptic curve cryptography On-Curve Validation : Public keys must be valid points on the Ed25519 curve Off-Curve Keys : Some addresses may be valid base58 strings but not valid curve points Cryptographic Validity : Different from format validation - checks mathematical validity","title":"Key Concepts"},{"location":"cookbook/wallet-management/validate-public-key/#usage","text":"To run this example: Install required dependencies: pip install solders Run the script: python validate_public_key.py The output will show: - True for the first key (valid curve point) - False for the second key (off-curve address)","title":"Usage"},{"location":"cookbook/wallet-management/validate-public-key/#extended-validation-function","text":"def validate_public_key_comprehensive ( address : str ) -> dict : \"\"\"Comprehensive public key validation with detailed results\"\"\" result = { \"address\" : address , \"is_valid_format\" : False , \"is_on_curve\" : False , \"validation_error\" : None } try : # Check if the address can be parsed as a public key pubkey = Pubkey . from_string ( address ) result [ \"is_valid_format\" ] = True # Check if it's on the Ed25519 curve result [ \"is_on_curve\" ] = pubkey . is_on_curve () except ValueError as e : result [ \"validation_error\" ] = f \"Invalid format: { e } \" except Exception as e : result [ \"validation_error\" ] = f \"Validation error: { e } \" return result # Usage example addresses_to_test = [ \"5oNDL3swdJJF1g9DzJiZ4ynHXgszjAEpUkxVYejchzrY\" , # Valid on-curve \"4BJXYkfvg37zEmBbsacZjeQDpTNx91KppxFJxRqrz48e\" , # Valid format, off-curve \"invalid_address\" , # Invalid format \"11111111111111111111111111111111\" # System program (on-curve) ] for address in addresses_to_test : result = validate_public_key_comprehensive ( address ) print ( f \"Address: { address [: 20 ] } ...\" ) print ( f \" Valid format: { result [ 'is_valid_format' ] } \" ) print ( f \" On curve: { result [ 'is_on_curve' ] } \" ) if result [ 'validation_error' ]: print ( f \" Error: { result [ 'validation_error' ] } \" ) print ()","title":"Extended Validation Function"},{"location":"cookbook/wallet-management/validate-public-key/#common-use-cases","text":"","title":"Common Use Cases"},{"location":"cookbook/wallet-management/validate-public-key/#input-validation","text":"def is_valid_solana_address ( address : str ) -> bool : \"\"\"Check if a string is a valid Solana address\"\"\" try : pubkey = Pubkey . from_string ( address ) return pubkey . is_on_curve () except : return False","title":"Input Validation"},{"location":"cookbook/wallet-management/validate-public-key/#program-derived-address-pda-validation","text":"def validate_pda ( address : str ) -> bool : \"\"\"Validate Program Derived Address (should be off-curve)\"\"\" try : pubkey = Pubkey . from_string ( address ) return not pubkey . is_on_curve () # PDAs are off-curve except : return False","title":"Program Derived Address (PDA) Validation"},{"location":"cookbook/wallet-management/validate-public-key/#batch-validation","text":"def validate_multiple_addresses ( addresses : list ) -> dict : \"\"\"Validate multiple addresses at once\"\"\" results = {} for address in addresses : try : pubkey = Pubkey . from_string ( address ) results [ address ] = { \"valid\" : True , \"on_curve\" : pubkey . is_on_curve () } except Exception as e : results [ address ] = { \"valid\" : False , \"error\" : str ( e ) } return results","title":"Batch Validation"},{"location":"cookbook/wallet-management/validate-public-key/#key-differences","text":"On-Curve Keys : Can be used for signing transactions (normal wallet addresses) Off-Curve Keys : Cannot sign but can receive tokens (Program Derived Addresses) Format Validation : Checks if the string is valid base58 and correct length Cryptographic Validation : Checks if the key is a valid point on the Ed25519 curve","title":"Key Differences"},{"location":"cookbook/wallet-management/validate-public-key/#security-considerations","text":"Always Validate : Validate public keys before using them in transactions Handle Errors : Wrap validation in try-catch blocks User Input : Validate all user-provided addresses PDA Handling : Remember that PDAs are intentionally off-curve","title":"Security Considerations"},{"location":"cookbook/wallet-management/validate-public-key/#error-types","text":"Format Errors : Invalid base58 encoding or incorrect length Curve Validation : Valid format but not on the Ed25519 curve Parsing Errors : Cannot be converted to a Pubkey object Note: Off-curve addresses are not necessarily invalid - they may be Program Derived Addresses that are intentionally off-curve for security reasons.","title":"Error Types"},{"location":"cookbook/wallet-management/verify-keypair/","text":"Verify Keypair Learn how to verify that a private key corresponds to a specific public key address in Solana. Code Example #!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Verify a Keypair \"\"\" from solders.keypair import Keypair from solders.pubkey import Pubkey def main (): public_key = Pubkey . from_string ( \"24PNhTaNtomHhoy3fTRaMhAFCRj4uHqhZEEoWrKDbR5p\" ) keypair_bytes = bytes ([ 174 , 47 , 154 , 16 , 202 , 193 , 206 , 113 , 199 , 190 , 53 , 133 , 169 , 175 , 31 , 56 , 222 , 53 , 138 , 189 , 224 , 216 , 117 , 173 , 10 , 149 , 53 , 45 , 73 , 251 , 237 , 246 , 15 , 185 , 186 , 82 , 177 , 240 , 148 , 69 , 241 , 227 , 167 , 80 , 141 , 89 , 240 , 121 , 121 , 35 , 172 , 247 , 68 , 251 , 226 , 218 , 48 , 63 , 176 , 109 , 168 , 89 , 238 , 135 ]) signer = Keypair . from_bytes ( keypair_bytes ) print ( signer . pubkey () == public_key ) if __name__ == \"__main__\" : main () Explanation This example demonstrates how to verify that a private key matches a specific public key: Define Expected Public Key : Create a Pubkey object from the expected address string Restore Keypair : Reconstruct the keypair from the private key bytes Compare Public Keys : Compare the derived public key with the expected one Return Result : The comparison returns True if they match, False otherwise Key Concepts Keypair Verification : Confirming that a private key generates a specific public key Public Key Derivation : Every private key deterministically produces one public key Address Validation : Ensuring private keys match expected wallet addresses Security Verification : Confirming key integrity before use Usage To run this example: Install required dependencies: pip install solders Run the script: python verify_keypair.py The output will be True if the private key matches the public key, False otherwise. Practical Applications Wallet Verification def verify_wallet_keypair ( expected_address : str , private_key_bytes : bytes ) -> bool : \"\"\"Verify that a private key corresponds to an expected wallet address\"\"\" try : expected_pubkey = Pubkey . from_string ( expected_address ) keypair = Keypair . from_bytes ( private_key_bytes ) return keypair . pubkey () == expected_pubkey except Exception as e : print ( f \"Verification failed: { e } \" ) return False Backup Verification def verify_backup_integrity ( original_pubkey : Pubkey , backup_private_key : bytes ) -> bool : \"\"\"Verify that a backup private key can restore the original keypair\"\"\" try : restored_keypair = Keypair . from_bytes ( backup_private_key ) return restored_keypair . pubkey () == original_pubkey except Exception : return False Multi-Key Verification def verify_multiple_keypairs ( key_pairs : list ) -> dict : \"\"\"Verify multiple keypair combinations\"\"\" results = {} for i , ( address , private_key ) in enumerate ( key_pairs ): try : expected_pubkey = Pubkey . from_string ( address ) keypair = Keypair . from_bytes ( private_key ) results [ f \"keypair_ { i } \" ] = keypair . pubkey () == expected_pubkey except Exception as e : results [ f \"keypair_ { i } \" ] = f \"Error: { e } \" return results Security Use Cases Wallet Import : Verify imported private keys match expected addresses Backup Validation : Confirm backup files contain correct private keys Key Migration : Ensure keys are correctly transferred between systems Multi-signature Setup : Verify all participant keys are correct Error Handling def safe_verify_keypair ( public_key_str : str , private_key_bytes : bytes ) -> bool : \"\"\"Safely verify keypair with proper error handling\"\"\" try : public_key = Pubkey . from_string ( public_key_str ) keypair = Keypair . from_bytes ( private_key_bytes ) return keypair . pubkey () == public_key except ValueError as e : print ( f \"Invalid public key format: { e } \" ) return False except Exception as e : print ( f \"Keypair verification failed: { e } \" ) return False Best Practices Always Verify : Verify keypairs before using them in transactions Handle Errors : Use try-catch blocks for robust error handling Validate Input : Ensure public key strings and private key bytes are valid Log Results : Log verification results for debugging and auditing Note: This example uses sample keys for demonstration. In production, use your actual private keys and expected addresses.","title":"Verify Keypair"},{"location":"cookbook/wallet-management/verify-keypair/#verify-keypair","text":"Learn how to verify that a private key corresponds to a specific public key address in Solana.","title":"Verify Keypair"},{"location":"cookbook/wallet-management/verify-keypair/#code-example","text":"#!/usr/bin/env python3 \"\"\" Solana Cookbook - How to Verify a Keypair \"\"\" from solders.keypair import Keypair from solders.pubkey import Pubkey def main (): public_key = Pubkey . from_string ( \"24PNhTaNtomHhoy3fTRaMhAFCRj4uHqhZEEoWrKDbR5p\" ) keypair_bytes = bytes ([ 174 , 47 , 154 , 16 , 202 , 193 , 206 , 113 , 199 , 190 , 53 , 133 , 169 , 175 , 31 , 56 , 222 , 53 , 138 , 189 , 224 , 216 , 117 , 173 , 10 , 149 , 53 , 45 , 73 , 251 , 237 , 246 , 15 , 185 , 186 , 82 , 177 , 240 , 148 , 69 , 241 , 227 , 167 , 80 , 141 , 89 , 240 , 121 , 121 , 35 , 172 , 247 , 68 , 251 , 226 , 218 , 48 , 63 , 176 , 109 , 168 , 89 , 238 , 135 ]) signer = Keypair . from_bytes ( keypair_bytes ) print ( signer . pubkey () == public_key ) if __name__ == \"__main__\" : main ()","title":"Code Example"},{"location":"cookbook/wallet-management/verify-keypair/#explanation","text":"This example demonstrates how to verify that a private key matches a specific public key: Define Expected Public Key : Create a Pubkey object from the expected address string Restore Keypair : Reconstruct the keypair from the private key bytes Compare Public Keys : Compare the derived public key with the expected one Return Result : The comparison returns True if they match, False otherwise","title":"Explanation"},{"location":"cookbook/wallet-management/verify-keypair/#key-concepts","text":"Keypair Verification : Confirming that a private key generates a specific public key Public Key Derivation : Every private key deterministically produces one public key Address Validation : Ensuring private keys match expected wallet addresses Security Verification : Confirming key integrity before use","title":"Key Concepts"},{"location":"cookbook/wallet-management/verify-keypair/#usage","text":"To run this example: Install required dependencies: pip install solders Run the script: python verify_keypair.py The output will be True if the private key matches the public key, False otherwise.","title":"Usage"},{"location":"cookbook/wallet-management/verify-keypair/#practical-applications","text":"","title":"Practical Applications"},{"location":"cookbook/wallet-management/verify-keypair/#wallet-verification","text":"def verify_wallet_keypair ( expected_address : str , private_key_bytes : bytes ) -> bool : \"\"\"Verify that a private key corresponds to an expected wallet address\"\"\" try : expected_pubkey = Pubkey . from_string ( expected_address ) keypair = Keypair . from_bytes ( private_key_bytes ) return keypair . pubkey () == expected_pubkey except Exception as e : print ( f \"Verification failed: { e } \" ) return False","title":"Wallet Verification"},{"location":"cookbook/wallet-management/verify-keypair/#backup-verification","text":"def verify_backup_integrity ( original_pubkey : Pubkey , backup_private_key : bytes ) -> bool : \"\"\"Verify that a backup private key can restore the original keypair\"\"\" try : restored_keypair = Keypair . from_bytes ( backup_private_key ) return restored_keypair . pubkey () == original_pubkey except Exception : return False","title":"Backup Verification"},{"location":"cookbook/wallet-management/verify-keypair/#multi-key-verification","text":"def verify_multiple_keypairs ( key_pairs : list ) -> dict : \"\"\"Verify multiple keypair combinations\"\"\" results = {} for i , ( address , private_key ) in enumerate ( key_pairs ): try : expected_pubkey = Pubkey . from_string ( address ) keypair = Keypair . from_bytes ( private_key ) results [ f \"keypair_ { i } \" ] = keypair . pubkey () == expected_pubkey except Exception as e : results [ f \"keypair_ { i } \" ] = f \"Error: { e } \" return results","title":"Multi-Key Verification"},{"location":"cookbook/wallet-management/verify-keypair/#security-use-cases","text":"Wallet Import : Verify imported private keys match expected addresses Backup Validation : Confirm backup files contain correct private keys Key Migration : Ensure keys are correctly transferred between systems Multi-signature Setup : Verify all participant keys are correct","title":"Security Use Cases"},{"location":"cookbook/wallet-management/verify-keypair/#error-handling","text":"def safe_verify_keypair ( public_key_str : str , private_key_bytes : bytes ) -> bool : \"\"\"Safely verify keypair with proper error handling\"\"\" try : public_key = Pubkey . from_string ( public_key_str ) keypair = Keypair . from_bytes ( private_key_bytes ) return keypair . pubkey () == public_key except ValueError as e : print ( f \"Invalid public key format: { e } \" ) return False except Exception as e : print ( f \"Keypair verification failed: { e } \" ) return False","title":"Error Handling"},{"location":"cookbook/wallet-management/verify-keypair/#best-practices","text":"Always Verify : Verify keypairs before using them in transactions Handle Errors : Use try-catch blocks for robust error handling Validate Input : Ensure public key strings and private key bytes are valid Log Results : Log verification results for debugging and auditing Note: This example uses sample keys for demonstration. In production, use your actual private keys and expected addresses.","title":"Best Practices"},{"location":"core/api/","text":"Moved \ufe0f This library uses many core types from the Solders package which used to be provided by solana-py itself. If you are upgrading from an old version and you're looking for something that was deleted, it's probably in solders now.","title":"Moved"},{"location":"core/api/#moved","text":"\ufe0f This library uses many core types from the Solders package which used to be provided by solana-py itself. If you are upgrading from an old version and you're looking for something that was deleted, it's probably in solders now.","title":"Moved"},{"location":"core/utils/","text":"Utils Utility functions for solanaweb3. cluster Tools for getting RPC cluster information. ClusterUrls ( tuple ) A collection of urls for each cluster. Source code in solana/utils/cluster.py class ClusterUrls ( NamedTuple ): \"\"\"A collection of urls for each cluster.\"\"\" devnet : str testnet : str mainnet_beta : str __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in solana/utils/cluster.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , devnet , testnet , mainnet_beta ) special staticmethod Create new instance of ClusterUrls(devnet, testnet, mainnet_beta) __repr__ ( self ) special Return a nicely formatted representation string Source code in solana/utils/cluster.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self Endpoint ( tuple ) Container for http and https cluster urls. Source code in solana/utils/cluster.py class Endpoint ( NamedTuple ): \"\"\"Container for http and https cluster urls.\"\"\" http : ClusterUrls https : ClusterUrls __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in solana/utils/cluster.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , http , https ) special staticmethod Create new instance of Endpoint(http, https) __repr__ ( self ) special Return a nicely formatted representation string Source code in solana/utils/cluster.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self cluster_api_url ( cluster = None , tls = True ) Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. Source code in solana/utils/cluster.py def cluster_api_url ( cluster : Optional [ Cluster ] = None , tls : bool = True ) -> str : \"\"\"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. \"\"\" urls = ENDPOINT . https if tls else ENDPOINT . http if cluster is None : return urls . devnet return getattr ( urls , cluster ) security_txt Utils for security.txt. FOOTER Footer of the security.txt. HEADER Header of the security.txt. NoSecurityTxtFoundError ( Exception ) Raise when security text is not found. Source code in solana/utils/security_txt.py class NoSecurityTxtFoundError ( Exception ): \"\"\"Raise when security text is not found.\"\"\" SecurityTxt dataclass Security txt data. Source code in solana/utils/security_txt.py @dataclass class SecurityTxt : \"\"\"Security txt data.\"\"\" # pylint: disable=too-many-instance-attributes name : str project_url : str contacts : str policy : str preferred_languages : Optional [ str ] = None source_code : Optional [ str ] = None encryption : Optional [ str ] = None auditors : Optional [ str ] = None acknowledgements : Optional [ str ] = None expiry : Optional [ str ] = None parse_security_txt ( data ) Parse and extract security.txt section from the data section of the compiled program. Parameters: Name Type Description Default data bytes Program data in bytes from the ProgramAccount. required Returns: Type Description SecurityTxt The Security Txt. Source code in solana/utils/security_txt.py def parse_security_txt ( data : bytes ) -> SecurityTxt : \"\"\"Parse and extract security.txt section from the data section of the compiled program. Args: data: Program data in bytes from the ProgramAccount. Returns: The Security Txt. \"\"\" if not isinstance ( data , bytes ): raise TypeError ( f \"data provided in parse(data) must be bytes, found: { type ( data ) } \" ) s_idx = data . find ( bytes ( HEADER , \"utf-8\" )) e_idx = data . find ( bytes ( FOOTER , \"utf-8\" )) if s_idx == - 1 : raise NoSecurityTxtFoundError ( \"Program doesn't have security.txt section\" ) content_arr = data [ s_idx + len ( HEADER ) : e_idx ] content_da : List [ Any ] = [[]] for char in content_arr : if char == 0 : content_da . append ([]) else : content_da [ len ( content_da ) - 1 ] . append ( chr ( char )) content_da . pop () content_dict = {} for idx , content in enumerate ( content_da ): content_da [ idx ] = \"\" . join ( content ) for iidx , idata in enumerate ( content_da ): if any ( idata == x . name for x in fields ( SecurityTxt )): next_key = iidx + 1 content_dict . update ({ str ( idata ): content_da [ next_key ]}) try : security_txt = SecurityTxt ( ** content_dict ) except TypeError as err : raise err return security_txt validate Validation utilities. validate_instruction_keys ( instruction , expected ) Verify length of AccountMeta list of a transaction instruction is at least the expected length. Parameters: Name Type Description Default instruction Instruction A Instruction object. required expected int The expected length. required Source code in solana/utils/validate.py def validate_instruction_keys ( instruction : Instruction , expected : int ) -> None : \"\"\"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Args: instruction: A Instruction object. expected: The expected length. \"\"\" if len ( instruction . accounts ) < expected : raise ValueError ( f \"invalid instruction: found { len ( instruction . accounts ) } keys, expected at least { expected } \" ) validate_instruction_type ( parsed_data , expected_type ) Check that the instruction type of the parsed data matches the expected instruction type. Parameters: Name Type Description Default parsed_data Any Parsed instruction data object with instruction_type field. required expected_type IntEnum The expected instruction type. required Source code in solana/utils/validate.py def validate_instruction_type ( parsed_data : Any , expected_type : IntEnum ) -> None : \"\"\"Check that the instruction type of the parsed data matches the expected instruction type. Args: parsed_data: Parsed instruction data object with `instruction_type` field. expected_type: The expected instruction type. \"\"\" if parsed_data . instruction_type != expected_type : raise ValueError ( f \"invalid instruction; instruction index mismatch { parsed_data . instruction_type } != { expected_type } \" )","title":"Utils"},{"location":"core/utils/#utils","text":"Utility functions for solanaweb3.","title":"Utils"},{"location":"core/utils/#solana.utils.cluster","text":"Tools for getting RPC cluster information.","title":"cluster"},{"location":"core/utils/#solana.utils.cluster.ClusterUrls","text":"A collection of urls for each cluster. Source code in solana/utils/cluster.py class ClusterUrls ( NamedTuple ): \"\"\"A collection of urls for each cluster.\"\"\" devnet : str testnet : str mainnet_beta : str","title":"ClusterUrls"},{"location":"core/utils/#solana.utils.cluster.ClusterUrls.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in solana/utils/cluster.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"core/utils/#solana.utils.cluster.ClusterUrls.__new__","text":"Create new instance of ClusterUrls(devnet, testnet, mainnet_beta)","title":"__new__()"},{"location":"core/utils/#solana.utils.cluster.ClusterUrls.__repr__","text":"Return a nicely formatted representation string Source code in solana/utils/cluster.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"core/utils/#solana.utils.cluster.Endpoint","text":"Container for http and https cluster urls. Source code in solana/utils/cluster.py class Endpoint ( NamedTuple ): \"\"\"Container for http and https cluster urls.\"\"\" http : ClusterUrls https : ClusterUrls","title":"Endpoint"},{"location":"core/utils/#solana.utils.cluster.Endpoint.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in solana/utils/cluster.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"core/utils/#solana.utils.cluster.Endpoint.__new__","text":"Create new instance of Endpoint(http, https)","title":"__new__()"},{"location":"core/utils/#solana.utils.cluster.Endpoint.__repr__","text":"Return a nicely formatted representation string Source code in solana/utils/cluster.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"core/utils/#solana.utils.cluster.cluster_api_url","text":"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. Source code in solana/utils/cluster.py def cluster_api_url ( cluster : Optional [ Cluster ] = None , tls : bool = True ) -> str : \"\"\"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. \"\"\" urls = ENDPOINT . https if tls else ENDPOINT . http if cluster is None : return urls . devnet return getattr ( urls , cluster )","title":"cluster_api_url()"},{"location":"core/utils/#solana.utils.security_txt","text":"Utils for security.txt.","title":"security_txt"},{"location":"core/utils/#solana.utils.security_txt.FOOTER","text":"Footer of the security.txt.","title":"FOOTER"},{"location":"core/utils/#solana.utils.security_txt.HEADER","text":"Header of the security.txt.","title":"HEADER"},{"location":"core/utils/#solana.utils.security_txt.NoSecurityTxtFoundError","text":"Raise when security text is not found. Source code in solana/utils/security_txt.py class NoSecurityTxtFoundError ( Exception ): \"\"\"Raise when security text is not found.\"\"\"","title":"NoSecurityTxtFoundError"},{"location":"core/utils/#solana.utils.security_txt.SecurityTxt","text":"Security txt data. Source code in solana/utils/security_txt.py @dataclass class SecurityTxt : \"\"\"Security txt data.\"\"\" # pylint: disable=too-many-instance-attributes name : str project_url : str contacts : str policy : str preferred_languages : Optional [ str ] = None source_code : Optional [ str ] = None encryption : Optional [ str ] = None auditors : Optional [ str ] = None acknowledgements : Optional [ str ] = None expiry : Optional [ str ] = None","title":"SecurityTxt"},{"location":"core/utils/#solana.utils.security_txt.parse_security_txt","text":"Parse and extract security.txt section from the data section of the compiled program. Parameters: Name Type Description Default data bytes Program data in bytes from the ProgramAccount. required Returns: Type Description SecurityTxt The Security Txt. Source code in solana/utils/security_txt.py def parse_security_txt ( data : bytes ) -> SecurityTxt : \"\"\"Parse and extract security.txt section from the data section of the compiled program. Args: data: Program data in bytes from the ProgramAccount. Returns: The Security Txt. \"\"\" if not isinstance ( data , bytes ): raise TypeError ( f \"data provided in parse(data) must be bytes, found: { type ( data ) } \" ) s_idx = data . find ( bytes ( HEADER , \"utf-8\" )) e_idx = data . find ( bytes ( FOOTER , \"utf-8\" )) if s_idx == - 1 : raise NoSecurityTxtFoundError ( \"Program doesn't have security.txt section\" ) content_arr = data [ s_idx + len ( HEADER ) : e_idx ] content_da : List [ Any ] = [[]] for char in content_arr : if char == 0 : content_da . append ([]) else : content_da [ len ( content_da ) - 1 ] . append ( chr ( char )) content_da . pop () content_dict = {} for idx , content in enumerate ( content_da ): content_da [ idx ] = \"\" . join ( content ) for iidx , idata in enumerate ( content_da ): if any ( idata == x . name for x in fields ( SecurityTxt )): next_key = iidx + 1 content_dict . update ({ str ( idata ): content_da [ next_key ]}) try : security_txt = SecurityTxt ( ** content_dict ) except TypeError as err : raise err return security_txt","title":"parse_security_txt()"},{"location":"core/utils/#solana.utils.validate","text":"Validation utilities.","title":"validate"},{"location":"core/utils/#solana.utils.validate.validate_instruction_keys","text":"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Parameters: Name Type Description Default instruction Instruction A Instruction object. required expected int The expected length. required Source code in solana/utils/validate.py def validate_instruction_keys ( instruction : Instruction , expected : int ) -> None : \"\"\"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Args: instruction: A Instruction object. expected: The expected length. \"\"\" if len ( instruction . accounts ) < expected : raise ValueError ( f \"invalid instruction: found { len ( instruction . accounts ) } keys, expected at least { expected } \" )","title":"validate_instruction_keys()"},{"location":"core/utils/#solana.utils.validate.validate_instruction_type","text":"Check that the instruction type of the parsed data matches the expected instruction type. Parameters: Name Type Description Default parsed_data Any Parsed instruction data object with instruction_type field. required expected_type IntEnum The expected instruction type. required Source code in solana/utils/validate.py def validate_instruction_type ( parsed_data : Any , expected_type : IntEnum ) -> None : \"\"\"Check that the instruction type of the parsed data matches the expected instruction type. Args: parsed_data: Parsed instruction data object with `instruction_type` field. expected_type: The expected instruction type. \"\"\" if parsed_data . instruction_type != expected_type : raise ValueError ( f \"invalid instruction; instruction index mismatch { parsed_data . instruction_type } != { expected_type } \" )","title":"validate_instruction_type()"},{"location":"core/vote_program/","text":"Vote Program Library to interface with the vote program. WithdrawFromVoteAccountParams ( tuple ) Transfer SOL from vote account to identity. Source code in solana/vote_program.py class WithdrawFromVoteAccountParams ( NamedTuple ): \"\"\"Transfer SOL from vote account to identity.\"\"\" vote_account_from_pubkey : Pubkey \"\"\"\"\"\" to_pubkey : Pubkey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" withdrawer : Pubkey \"\"\"\"\"\" __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in solana/vote_program.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , vote_account_from_pubkey , to_pubkey , lamports , withdrawer ) special staticmethod Create new instance of WithdrawFromVoteAccountParams(vote_account_from_pubkey, to_pubkey, lamports, withdrawer) __repr__ ( self ) special Return a nicely formatted representation string Source code in solana/vote_program.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self withdraw_from_vote_account ( params ) Generate an instruction that transfers lamports from a vote account to any other. Examples: >>> from solders.pubkey import Pubkey >>> from solders.keypair import Keypair >>> vote = Pubkey ([ 0 ] * 31 + [ 1 ]) >>> withdrawer = Keypair . from_seed ( bytes ([ 0 ] * 32 )) >>> instruction = withdraw_from_vote_account ( ... WithdrawFromVoteAccountParams ( ... vote_account_from_pubkey = vote , ... to_pubkey = withdrawer . pubkey (), ... withdrawer = withdrawer . pubkey (), ... lamports = 3_000_000_000 , ... ) ... ) >>> type ( instruction ) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The generated instruction. Source code in solana/vote_program.py def withdraw_from_vote_account ( params : WithdrawFromVoteAccountParams ) -> Instruction : \"\"\"Generate an instruction that transfers lamports from a vote account to any other. Example: >>> from solders.pubkey import Pubkey >>> from solders.keypair import Keypair >>> vote = Pubkey([0] * 31 + [1]) >>> withdrawer = Keypair.from_seed(bytes([0]*32)) >>> instruction = withdraw_from_vote_account( ... WithdrawFromVoteAccountParams( ... vote_account_from_pubkey=vote, ... to_pubkey=withdrawer.pubkey(), ... withdrawer=withdrawer.pubkey(), ... lamports=3_000_000_000, ... ) ... ) >>> type(instruction) <class 'solders.instruction.Instruction'> Returns: The generated instruction. \"\"\" data = VOTE_INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . WITHDRAW_FROM_VOTE_ACCOUNT , \"args\" : { \"lamports\" : params . lamports }, } ) return Instruction ( accounts = [ AccountMeta ( pubkey = params . vote_account_from_pubkey , is_signer = False , is_writable = True , ), AccountMeta ( pubkey = params . to_pubkey , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . withdrawer , is_signer = True , is_writable = True ), ], program_id = VOTE_PROGRAM_ID , data = data , )","title":"Vote Program"},{"location":"core/vote_program/#vote-program","text":"Library to interface with the vote program.","title":"Vote Program"},{"location":"core/vote_program/#solana.vote_program.WithdrawFromVoteAccountParams","text":"Transfer SOL from vote account to identity. Source code in solana/vote_program.py class WithdrawFromVoteAccountParams ( NamedTuple ): \"\"\"Transfer SOL from vote account to identity.\"\"\" vote_account_from_pubkey : Pubkey \"\"\"\"\"\" to_pubkey : Pubkey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" withdrawer : Pubkey \"\"\"\"\"\"","title":"WithdrawFromVoteAccountParams"},{"location":"core/vote_program/#solana.vote_program.WithdrawFromVoteAccountParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in solana/vote_program.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"core/vote_program/#solana.vote_program.WithdrawFromVoteAccountParams.__new__","text":"Create new instance of WithdrawFromVoteAccountParams(vote_account_from_pubkey, to_pubkey, lamports, withdrawer)","title":"__new__()"},{"location":"core/vote_program/#solana.vote_program.WithdrawFromVoteAccountParams.__repr__","text":"Return a nicely formatted representation string Source code in solana/vote_program.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"core/vote_program/#solana.vote_program.withdraw_from_vote_account","text":"Generate an instruction that transfers lamports from a vote account to any other. Examples: >>> from solders.pubkey import Pubkey >>> from solders.keypair import Keypair >>> vote = Pubkey ([ 0 ] * 31 + [ 1 ]) >>> withdrawer = Keypair . from_seed ( bytes ([ 0 ] * 32 )) >>> instruction = withdraw_from_vote_account ( ... WithdrawFromVoteAccountParams ( ... vote_account_from_pubkey = vote , ... to_pubkey = withdrawer . pubkey (), ... withdrawer = withdrawer . pubkey (), ... lamports = 3_000_000_000 , ... ) ... ) >>> type ( instruction ) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The generated instruction. Source code in solana/vote_program.py def withdraw_from_vote_account ( params : WithdrawFromVoteAccountParams ) -> Instruction : \"\"\"Generate an instruction that transfers lamports from a vote account to any other. Example: >>> from solders.pubkey import Pubkey >>> from solders.keypair import Keypair >>> vote = Pubkey([0] * 31 + [1]) >>> withdrawer = Keypair.from_seed(bytes([0]*32)) >>> instruction = withdraw_from_vote_account( ... WithdrawFromVoteAccountParams( ... vote_account_from_pubkey=vote, ... to_pubkey=withdrawer.pubkey(), ... withdrawer=withdrawer.pubkey(), ... lamports=3_000_000_000, ... ) ... ) >>> type(instruction) <class 'solders.instruction.Instruction'> Returns: The generated instruction. \"\"\" data = VOTE_INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . WITHDRAW_FROM_VOTE_ACCOUNT , \"args\" : { \"lamports\" : params . lamports }, } ) return Instruction ( accounts = [ AccountMeta ( pubkey = params . vote_account_from_pubkey , is_signer = False , is_writable = True , ), AccountMeta ( pubkey = params . to_pubkey , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . withdrawer , is_signer = True , is_writable = True ), ], program_id = VOTE_PROGRAM_ID , data = data , )","title":"withdraw_from_vote_account()"},{"location":"rpc/api/","text":"API Client API client to interact with the Solana JSON RPC Endpoint. Client ( _ClientCore ) Client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None timeout float HTTP request timeout in seconds. 10 extra_headers Optional[Dict[str, str]] Extra headers to pass for HTTP request. None proxy Optional[str] Proxy URL to pass to the HTTP client. None Source code in solana/rpc/api.py class Client ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". timeout: HTTP request timeout in seconds. extra_headers: Extra headers to pass for HTTP request. proxy: Proxy URL to pass to the HTTP client. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , proxy : Optional [ str ] = None , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers , proxy = proxy ) def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" body = self . _get_health_body () response = self . _provider . make_request ( body , GetHealthResp ) return response . value == \"ok\" def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(Pubkey([0] * 31 + [1])).value # doctest: +SKIP 4104230290 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetBalanceResp ) def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key, encoded in either base58 or base64. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(Pubkey([0] * 31 + [1])).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetAccountInfoResp ) def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1])).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return self . _provider . make_request ( body , GetBlockCommitmentResp ) def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return self . _provider . make_request ( body , GetBlockTimeResp ) def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes().value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : Union [ int , None ] = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return self . _provider . make_request ( body , GetBlockResp ) def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(1).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height().value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return self . _provider . make_request ( body , GetBlockHeightResp ) def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return self . _provider . make_request ( body , GetBlocksResp ) def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> solana_client.get_signatures_for_address(pubkey, limit=1).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return self . _provider . make_request ( body , GetSignaturesForAddressResp ) def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> solana_client.get_transaction(sig).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return self . _provider . make_request ( body , GetTransactionResp ) def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info().value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return self . _provider . make_request ( body , GetEpochInfoResp ) def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule().value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> msg = Message([transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))]) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(msg).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return self . _provider . make_request ( body , GetFeeForMessageResp ) def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_first_available_block().value # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash().value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity().value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return self . _provider . make_request ( self . _get_identity , GetIdentityResp ) def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor().value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return self . _provider . make_request ( body , GetInflationGovernorResp ) def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate().value.epoch # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) def get_inflation_reward ( self , pubkeys : List [ Pubkey ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetInflationRewardResp : \"\"\"Returns the inflation / staking reward for a list of addresses for an epoch. Args: pubkeys: An array of addresses to query, as base-58 encoded strings epoch: (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used commitment: Bank state to query. It can be either \"finalized\" or \"confirmed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_reward().value.amount # doctest: +SKIP 2500 \"\"\" body = self . _get_inflation_reward_body ( pubkeys , epoch , commitment ) return self . _provider . make_request ( body , GetInflationRewardResp ) def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts().value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return self . _provider . make_request ( body , GetLargestAccountsResp ) def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> list(solana_client.get_leader_schedule().value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return self . _provider . make_request ( body , GetLeaderScheduleResp ) def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetMultipleAccountsResp ) def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts_json_parsed(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsResp ) def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash().value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return self . _provider . make_request ( body , GetLatestBlockhashResp ) def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> solana_client.get_signature_statuses(sigs).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return self . _provider . make_request ( body , GetSignatureStatusesResp ) def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot().value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return self . _provider . make_request ( body , GetSlotResp ) def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader().value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return self . _provider . make_request ( body , GetSlotLeaderResp ) def get_slot_leaders ( self , start : int , limit : int ) -> GetSlotLeadersResp : \"\"\"Returns the list of slot leaders for the provided start slot and limit. Args: start: The start slot to get the slot leaders from. limit: The number of slot leaders to return. Returns: A list of slot leaders. \"\"\" body = self . _get_slot_leaders_body ( start , limit ) return self . _provider . make_request ( body , GetSlotLeadersResp ) def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply().value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return self . _provider . make_request ( body , GetSupplyResp ) def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> solana_client.get_token_account_balance(pubkey).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenAccountBalanceResp ) def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenLargestAccountsResp ) def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenSupplyResp ) def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count().value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return self . _provider . make_request ( body , GetTransactionCountResp ) def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot().value # doctest: +SKIP 1234 \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version().value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return self . _provider . make_request ( self . _get_version , GetVersionResp ) def get_vote_accounts ( self , vote_pubkey : Optional [ Pubkey ] = None , commitment : Optional [ Commitment ] = None , keep_unstaked_delinquents : Optional [ bool ] = None , delinquent_slot_distance : Optional [ int ] = None , ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: vote_pubkey: Only return results for this validator vote address. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". keep_unstaked_delinquents: Filter out delinquent validators with no stake. delinquent_slot_distance: Specify the number of slots behind the tip that the validator must fall to be considered delinquent. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts().value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( vote_pubkey , commitment , keep_unstaked_delinquents , delinquent_slot_distance ) return self . _provider . make_request ( body , GetVoteAccountsResp ) def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return self . _provider . make_request ( body , RequestAirdropResp ) def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], opts : Optional [ types . TxOpts ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. opts: (optional) Transaction options. Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> ixns = [transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))] >>> msg = Message(ixns, sender.pubkey()) >>> client = Client(\"http://localhost:8899\") >>> client.send_transaction(Transaction([sender], msg, client.get_latest_blockhash().value.blockhash)) # doctest: +SKIP \"\"\" # noqa: E501 tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return self . send_raw_transaction ( bytes ( txn ), opts = tx_opts ) def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , replace_recent_blockhash : bool = False , min_context_slot : Optional [ int ] = None , inner_instructions : bool = False , accounts_addresses : Optional [ List [ Pubkey ]] = None , accounts_encoding : str = \"base64\" , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. sig_verify: If True the transaction signatures will be verified (conflicts with ``replace_recent_blockhash``). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". replace_recent_blockhash: If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with ``sig_verify``). min_context_slot: The minimum slot that the request can be evaluated at. inner_instructions: If true the response will include inner instructions. These inner instructions will be `jsonParsed` where possible, otherwise json. accounts_addresses: An array of accounts to return, as base-58 encoded strings accounts_encoding: Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. Example: >>> from solders.transaction import Transaction >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.from_bytes(bytes.fromhex(full_signed_tx_hex)) >>> solana_client.simulate_transaction(tx).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment , replace_recent_blockhash , min_context_slot , inner_instructions , accounts_addresses , accounts_encoding , ) return self . _provider . make_request ( body , SimulateTransactionResp ) def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit().value # doctest: +SKIP True \"\"\" return self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) # type: ignore def __post_send_with_confirm ( self , resp : SendTransactionResp , conf_comm : Commitment , last_valid_block_height : Optional [ int ], ) -> SendTransactionResp : resp = self . _post_send ( resp ) sig = resp . value self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , sig ) self . confirm_transaction ( sig , conf_comm , last_valid_block_height = last_valid_block_height ) return resp def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" timeout = time () + 90 commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment )) . value sleep ( sleep_seconds ) else : if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp __init__ ( self , endpoint = None , commitment = None , timeout = 10 , extra_headers = None , proxy = None ) special Init API client. Source code in solana/rpc/api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , proxy : Optional [ str ] = None , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers , proxy = proxy ) confirm_transaction ( self , tx_sig , commitment = None , sleep_seconds = 0.5 , last_valid_block_height = None ) Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig Signature the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/api.py def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" timeout = time () + 90 commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment )) . value sleep ( sleep_seconds ) else : if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp get_account_info ( self , pubkey , commitment = None , encoding = 'base64' , data_slice = None ) Returns all the account info for the specified public key, encoded in either base58 or base64. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value Account ( Account { lamports : 4104230290 , data . len : 0 , owner : 11111111111111111111111111111111 , executable : false , rent_epoch : 371 , }, ) Source code in solana/rpc/api.py def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key, encoded in either base58 or base64. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(Pubkey([0] * 31 + [1])).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetAccountInfoResp ) get_account_info_json_parsed ( self , pubkey , commitment = None ) Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info_json_parsed ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value . owner Pubkey ( 11111111111111111111111111111111 , ) Source code in solana/rpc/api.py def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1])).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) get_balance ( self , pubkey , commitment = None ) Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_balance ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value 4104230290 Source code in solana/rpc/api.py def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(Pubkey([0] * 31 + [1])).value # doctest: +SKIP 4104230290 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetBalanceResp ) get_block ( self , slot , encoding = 'json' , max_supported_transaction_version = None ) Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' max_supported_transaction_version Union[int, None] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block ( 1 ) . value . blockhash Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/api.py def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : Union [ int , None ] = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return self . _provider . make_request ( body , GetBlockResp ) get_block_commitment ( self , slot ) Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_commitment ( 0 ) . total_stake 497717120 Source code in solana/rpc/api.py def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return self . _provider . make_request ( body , GetBlockCommitmentResp ) get_block_height ( self , commitment = None ) Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_height () . value 1233 Source code in solana/rpc/api.py def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height().value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return self . _provider . make_request ( body , GetBlockHeightResp ) get_block_time ( self , slot ) Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_time ( 5 ) . value 1598400007 Source code in solana/rpc/api.py def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return self . _provider . make_request ( body , GetBlockTimeResp ) get_blocks ( self , start_slot , end_slot = None ) Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_blocks ( 5 , 10 ) . value [ 5 , 6 , 7 , 8 , 9 , 10 ] Source code in solana/rpc/api.py def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return self . _provider . make_request ( body , GetBlocksResp ) get_cluster_nodes ( self ) Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_cluster_nodes () . value [ 0 ] . tpu '139.178.65.155:8004' Source code in solana/rpc/api.py def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes().value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) get_epoch_info ( self , commitment = None ) Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_info () . value . epoch 0 Source code in solana/rpc/api.py def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info().value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return self . _provider . make_request ( body , GetEpochInfoResp ) get_epoch_schedule ( self ) Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_schedule () . value . slots_per_epoch 8192 Source code in solana/rpc/api.py def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule().value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) get_fee_for_message ( self , message , commitment = None ) Returns the fee for a message. Parameters: Name Type Description Default message VersionedMessage Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solders.message import Message >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> msg = Message ([ transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))]) >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fee_for_message ( msg ) . value 5000 Source code in solana/rpc/api.py def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> msg = Message([transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))]) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(msg).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return self . _provider . make_request ( body , GetFeeForMessageResp ) get_first_available_block ( self ) Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_first_available_block () . value 1 Source code in solana/rpc/api.py def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_first_available_block().value # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) get_genesis_hash ( self ) Returns the genesis hash. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_genesis_hash () . value Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/api.py def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash().value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) get_identity ( self ) Returns the identity pubkey for the current node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_identity () . value . identity Pubkey ( 2 LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv , ) Source code in solana/rpc/api.py def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity().value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return self . _provider . make_request ( self . _get_identity , GetIdentityResp ) get_inflation_governor ( self , commitment = None ) Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_governor () . value . foundation 0.05 Source code in solana/rpc/api.py def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor().value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return self . _provider . make_request ( body , GetInflationGovernorResp ) get_inflation_rate ( self ) Returns the specific inflation values for the current epoch. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_rate () . value . epoch 1 Source code in solana/rpc/api.py def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate().value.epoch # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) get_inflation_reward ( self , pubkeys , epoch = None , commitment = None ) Returns the inflation / staking reward for a list of addresses for an epoch. Parameters: Name Type Description Default pubkeys List[Pubkey] An array of addresses to query, as base-58 encoded strings required epoch Optional[int] (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\" or \"confirmed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_reward () . value . amount 2500 Source code in solana/rpc/api.py def get_inflation_reward ( self , pubkeys : List [ Pubkey ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetInflationRewardResp : \"\"\"Returns the inflation / staking reward for a list of addresses for an epoch. Args: pubkeys: An array of addresses to query, as base-58 encoded strings epoch: (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used commitment: Bank state to query. It can be either \"finalized\" or \"confirmed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_reward().value.amount # doctest: +SKIP 2500 \"\"\" body = self . _get_inflation_reward_body ( pubkeys , epoch , commitment ) return self . _provider . make_request ( body , GetInflationRewardResp ) get_largest_accounts ( self , filter_opt = None , commitment = None ) Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_largest_accounts () . value [ 0 ] . lamports 500000000000000000 Source code in solana/rpc/api.py def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts().value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return self . _provider . make_request ( body , GetLargestAccountsResp ) get_latest_blockhash ( self , commitment = None ) Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_latest_blockhash () . value RpcBlockhash { blockhash : Hash ( 4 TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT , ), last_valid_block_height : 158286487 , } Source code in solana/rpc/api.py def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash().value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return self . _provider . make_request ( body , GetLatestBlockhashResp ) get_leader_schedule ( self , epoch = None , commitment = None ) Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> list ( solana_client . get_leader_schedule () . value . items ())[ 0 ] ( Pubkey ( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr , ), [ 346448 , 346449 , 346450 , 346451 , 369140 , 369141 , 369142 , 369143 , 384204 , 384205 , 384206 , 384207 ]) Source code in solana/rpc/api.py def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> list(solana_client.get_leader_schedule().value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return self . _provider . make_request ( body , GetLeaderScheduleResp ) get_minimum_balance_for_rent_exemption ( self , usize , commitment = None ) Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_balance_for_rent_exemption ( 50 ) . value 1238880 Source code in solana/rpc/api.py def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) get_minimum_ledger_slot ( self ) Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_ledger_slot () . value 1234 Source code in solana/rpc/api.py def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot().value # doctest: +SKIP 1234 \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) get_multiple_accounts ( self , pubkeys , commitment = None , encoding = 'base64' , data_slice = None ) Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts ( pubkeys ) . value [ 0 ] . lamports 1 Source code in solana/rpc/api.py def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetMultipleAccountsResp ) get_multiple_accounts_json_parsed ( self , pubkeys , commitment = None ) Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Parameters: Name Type Description Default pubkeys List[Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts_json_parsed ( pubkeys ) . value [ 0 ] . lamports 1 Source code in solana/rpc/api.py def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts_json_parsed(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) get_program_accounts ( self , pubkey , commitment = None , encoding = 'base64' , data_slice = None , filters = None ) Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". 'base64' data_slice Optional[types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required filters Optional[Sequence[Union[int, types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List , Union >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> solana_client . get_program_accounts ( pubkey , filters = filters ) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/api.py def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsResp ) get_program_accounts_json_parsed ( self , pubkey , commitment = None , filters = None ) Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None filters Optional[Sequence[Union[int, types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List , Union >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> solana_client . get_program_accounts ( pubkey , filters = filters ) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/api.py def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) get_recent_performance_samples ( self , limit = None ) Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_recent_performance_samples ( 1 ) . value [ 0 ] RpcPerfSample ( RpcPerfSample { slot : 168036172 , num_transactions : 7159 , num_slots : 158 , sample_period_secs : 60 , }, ) Source code in solana/rpc/api.py def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(1).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) get_signature_statuses ( self , signatures , search_transaction_history = False ) Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[Signature] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> sigs = [ Signature . from_string ( sig ) for sig in raw_sigs ] >>> solana_client . get_signature_statuses ( sigs ) . value [ 0 ] . confirmations 10 Source code in solana/rpc/api.py def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> solana_client.get_signature_statuses(sigs).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return self . _provider . make_request ( body , GetSignatureStatusesResp ) get_signatures_for_address ( self , account , before = None , until = None , limit = None , commitment = None ) Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Pubkey Account to be queried. required before Optional[Signature] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[Signature] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey . from_string ( \"Vote111111111111111111111111111111111111111\" ) >>> solana_client . get_signatures_for_address ( pubkey , limit = 1 ) . value [ 0 ] . signature Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> solana_client.get_signatures_for_address(pubkey, limit=1).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return self . _provider . make_request ( body , GetSignaturesForAddressResp ) get_slot ( self , commitment = None ) Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot () . value 7515 Source code in solana/rpc/api.py def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot().value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return self . _provider . make_request ( body , GetSlotResp ) get_slot_leader ( self , commitment = None ) Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot_leader () . value Pubkey ( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV , ) Source code in solana/rpc/api.py def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader().value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return self . _provider . make_request ( body , GetSlotLeaderResp ) get_slot_leaders ( self , start , limit ) Returns the list of slot leaders for the provided start slot and limit. Parameters: Name Type Description Default start int The start slot to get the slot leaders from. required limit int The number of slot leaders to return. required Returns: Type Description GetSlotLeadersResp A list of slot leaders. Source code in solana/rpc/api.py def get_slot_leaders ( self , start : int , limit : int ) -> GetSlotLeadersResp : \"\"\"Returns the list of slot leaders for the provided start slot and limit. Args: start: The start slot to get the slot leaders from. limit: The number of slot leaders to return. Returns: A list of slot leaders. \"\"\" body = self . _get_slot_leaders_body ( start , limit ) return self . _provider . make_request ( body , GetSlotLeadersResp ) get_supply ( self , commitment = None ) Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_supply () . value . circulating 683635192454157660 Source code in solana/rpc/api.py def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply().value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return self . _provider . make_request ( body , GetSupplyResp ) get_token_account_balance ( self , pubkey , commitment = None ) Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Pubkey Pubkey of Token account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkey = Pubkey . from_string ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) >>> solana_client . get_token_account_balance ( pubkey ) . value . amount # noqa: E501 '9864' Source code in solana/rpc/api.py def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> solana_client.get_token_account_balance(pubkey).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenAccountBalanceResp ) get_token_accounts_by_delegate ( self , delegate , opts , commitment = None ) Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) get_token_accounts_by_delegate_json_parsed ( self , delegate , opts , commitment = None ) Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) get_token_accounts_by_owner ( self , owner , opts , commitment = None ) Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) get_token_accounts_by_owner_json_parsed ( self , owner , opts , commitment = None ) Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) get_token_largest_accounts ( self , pubkey , commitment = None ) Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/api.py def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenLargestAccountsResp ) get_token_supply ( self , pubkey , commitment = None ) Returns the total supply of an SPL Token type. Source code in solana/rpc/api.py def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenSupplyResp ) get_transaction ( self , tx_sig , encoding = 'json' , commitment = None , max_supported_transaction_version = None ) Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig Signature Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> from solders.signature import Signature >>> sig = Signature . from_string ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) >>> solana_client . get_transaction ( sig ) . value . block_time 1234 Source code in solana/rpc/api.py def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> solana_client.get_transaction(sig).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return self . _provider . make_request ( body , GetTransactionResp ) get_transaction_count ( self , commitment = None ) Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_transaction_count () . value 4554 Source code in solana/rpc/api.py def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count().value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return self . _provider . make_request ( body , GetTransactionCountResp ) get_version ( self ) Returns the current solana versions running on the node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_version () . value . solana_core '1.13.2' Source code in solana/rpc/api.py def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version().value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return self . _provider . make_request ( self . _get_version , GetVersionResp ) get_vote_accounts ( self , vote_pubkey = None , commitment = None , keep_unstaked_delinquents = None , delinquent_slot_distance = None ) Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default vote_pubkey Optional[Pubkey] Only return results for this validator vote address. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None keep_unstaked_delinquents Optional[bool] Filter out delinquent validators with no stake. None delinquent_slot_distance Optional[int] Specify the number of slots behind the tip that the validator must fall to be considered delinquent. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_vote_accounts () . value . current [ 0 ] . commission 100 Source code in solana/rpc/api.py def get_vote_accounts ( self , vote_pubkey : Optional [ Pubkey ] = None , commitment : Optional [ Commitment ] = None , keep_unstaked_delinquents : Optional [ bool ] = None , delinquent_slot_distance : Optional [ int ] = None , ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: vote_pubkey: Only return results for this validator vote address. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". keep_unstaked_delinquents: Filter out delinquent validators with no stake. delinquent_slot_distance: Specify the number of slots behind the tip that the validator must fall to be considered delinquent. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts().value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( vote_pubkey , commitment , keep_unstaked_delinquents , delinquent_slot_distance ) return self . _provider . make_request ( body , GetVoteAccountsResp ) is_connected ( self ) Health check. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . is_connected () True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/api.py def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" body = self . _get_health_body () response = self . _provider . make_request ( body , GetHealthResp ) return response . value == \"ok\" request_airdrop ( self , pubkey , lamports , commitment = None ) Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amout of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . request_airdrop ( Pubkey ([ 0 ] * 31 + [ 1 ]), 10000 ) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return self . _provider . make_request ( body , RequestAirdropResp ) send_raw_transaction ( self , txn , opts = None ) Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn bytes Transaction bytes. required opts Optional[types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client . send_raw_transaction ( bytes . fromhex ( full_signed_tx_hex )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) send_transaction ( self , txn , opts = None ) Send a transaction. Parameters: Name Type Description Default txn Union[VersionedTransaction, Transaction] transaction object. required opts Optional[types.TxOpts] (optional) Transaction options. None Examples: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams , transfer >>> from solders.message import Message >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> ixns = [ transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))] >>> msg = Message ( ixns , sender . pubkey ()) >>> client = Client ( \"http://localhost:8899\" ) >>> client . send_transaction ( Transaction ([ sender ], msg , client . get_latest_blockhash () . value . blockhash )) Source code in solana/rpc/api.py def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], opts : Optional [ types . TxOpts ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. opts: (optional) Transaction options. Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> ixns = [transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))] >>> msg = Message(ixns, sender.pubkey()) >>> client = Client(\"http://localhost:8899\") >>> client.send_transaction(Transaction([sender], msg, client.get_latest_blockhash().value.blockhash)) # doctest: +SKIP \"\"\" # noqa: E501 tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return self . send_raw_transaction ( bytes ( txn ), opts = tx_opts ) simulate_transaction ( self , txn , sig_verify = False , commitment = None , replace_recent_blockhash = False , min_context_slot = None , inner_instructions = False , accounts_addresses = None , accounts_encoding = 'base64' ) Simulate sending a transaction. Parameters: Name Type Description Default txn Union[Transaction, VersionedTransaction] A transaction object. required sig_verify bool If True the transaction signatures will be verified (conflicts with replace_recent_blockhash ). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None replace_recent_blockhash bool If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with sig_verify ). False min_context_slot Optional[int] The minimum slot that the request can be evaluated at. None inner_instructions bool If true the response will include inner instructions. These inner instructions will be jsonParsed where possible, otherwise json. False accounts_addresses Optional[List[Pubkey]] An array of accounts to return, as base-58 encoded strings None accounts_encoding str Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. 'base64' Examples: >>> from solders.transaction import Transaction >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction . from_bytes ( bytes . fromhex ( full_signed_tx_hex )) >>> solana_client . simulate_transaction ( tx ) . value . logs [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ] Source code in solana/rpc/api.py def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , replace_recent_blockhash : bool = False , min_context_slot : Optional [ int ] = None , inner_instructions : bool = False , accounts_addresses : Optional [ List [ Pubkey ]] = None , accounts_encoding : str = \"base64\" , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. sig_verify: If True the transaction signatures will be verified (conflicts with ``replace_recent_blockhash``). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". replace_recent_blockhash: If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with ``sig_verify``). min_context_slot: The minimum slot that the request can be evaluated at. inner_instructions: If true the response will include inner instructions. These inner instructions will be `jsonParsed` where possible, otherwise json. accounts_addresses: An array of accounts to return, as base-58 encoded strings accounts_encoding: Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. Example: >>> from solders.transaction import Transaction >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.from_bytes(bytes.fromhex(full_signed_tx_hex)) >>> solana_client.simulate_transaction(tx).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment , replace_recent_blockhash , min_context_slot , inner_instructions , accounts_addresses , accounts_encoding , ) return self . _provider . make_request ( body , SimulateTransactionResp ) validator_exit ( self ) Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . validator_exit () . value True Source code in solana/rpc/api.py def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit().value # doctest: +SKIP True \"\"\" return self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) # type: ignore","title":"API Client"},{"location":"rpc/api/#api-client","text":"API client to interact with the Solana JSON RPC Endpoint.","title":"API Client"},{"location":"rpc/api/#solana.rpc.api.Client","text":"Client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None timeout float HTTP request timeout in seconds. 10 extra_headers Optional[Dict[str, str]] Extra headers to pass for HTTP request. None proxy Optional[str] Proxy URL to pass to the HTTP client. None Source code in solana/rpc/api.py class Client ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". timeout: HTTP request timeout in seconds. extra_headers: Extra headers to pass for HTTP request. proxy: Proxy URL to pass to the HTTP client. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , proxy : Optional [ str ] = None , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers , proxy = proxy ) def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" body = self . _get_health_body () response = self . _provider . make_request ( body , GetHealthResp ) return response . value == \"ok\" def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(Pubkey([0] * 31 + [1])).value # doctest: +SKIP 4104230290 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetBalanceResp ) def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key, encoded in either base58 or base64. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(Pubkey([0] * 31 + [1])).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetAccountInfoResp ) def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1])).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return self . _provider . make_request ( body , GetBlockCommitmentResp ) def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return self . _provider . make_request ( body , GetBlockTimeResp ) def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes().value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : Union [ int , None ] = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return self . _provider . make_request ( body , GetBlockResp ) def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(1).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height().value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return self . _provider . make_request ( body , GetBlockHeightResp ) def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return self . _provider . make_request ( body , GetBlocksResp ) def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> solana_client.get_signatures_for_address(pubkey, limit=1).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return self . _provider . make_request ( body , GetSignaturesForAddressResp ) def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> solana_client.get_transaction(sig).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return self . _provider . make_request ( body , GetTransactionResp ) def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info().value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return self . _provider . make_request ( body , GetEpochInfoResp ) def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule().value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> msg = Message([transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))]) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(msg).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return self . _provider . make_request ( body , GetFeeForMessageResp ) def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_first_available_block().value # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash().value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity().value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return self . _provider . make_request ( self . _get_identity , GetIdentityResp ) def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor().value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return self . _provider . make_request ( body , GetInflationGovernorResp ) def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate().value.epoch # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) def get_inflation_reward ( self , pubkeys : List [ Pubkey ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetInflationRewardResp : \"\"\"Returns the inflation / staking reward for a list of addresses for an epoch. Args: pubkeys: An array of addresses to query, as base-58 encoded strings epoch: (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used commitment: Bank state to query. It can be either \"finalized\" or \"confirmed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_reward().value.amount # doctest: +SKIP 2500 \"\"\" body = self . _get_inflation_reward_body ( pubkeys , epoch , commitment ) return self . _provider . make_request ( body , GetInflationRewardResp ) def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts().value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return self . _provider . make_request ( body , GetLargestAccountsResp ) def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> list(solana_client.get_leader_schedule().value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return self . _provider . make_request ( body , GetLeaderScheduleResp ) def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetMultipleAccountsResp ) def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts_json_parsed(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsResp ) def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash().value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return self . _provider . make_request ( body , GetLatestBlockhashResp ) def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> solana_client.get_signature_statuses(sigs).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return self . _provider . make_request ( body , GetSignatureStatusesResp ) def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot().value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return self . _provider . make_request ( body , GetSlotResp ) def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader().value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return self . _provider . make_request ( body , GetSlotLeaderResp ) def get_slot_leaders ( self , start : int , limit : int ) -> GetSlotLeadersResp : \"\"\"Returns the list of slot leaders for the provided start slot and limit. Args: start: The start slot to get the slot leaders from. limit: The number of slot leaders to return. Returns: A list of slot leaders. \"\"\" body = self . _get_slot_leaders_body ( start , limit ) return self . _provider . make_request ( body , GetSlotLeadersResp ) def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply().value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return self . _provider . make_request ( body , GetSupplyResp ) def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> solana_client.get_token_account_balance(pubkey).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenAccountBalanceResp ) def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenLargestAccountsResp ) def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenSupplyResp ) def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count().value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return self . _provider . make_request ( body , GetTransactionCountResp ) def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot().value # doctest: +SKIP 1234 \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version().value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return self . _provider . make_request ( self . _get_version , GetVersionResp ) def get_vote_accounts ( self , vote_pubkey : Optional [ Pubkey ] = None , commitment : Optional [ Commitment ] = None , keep_unstaked_delinquents : Optional [ bool ] = None , delinquent_slot_distance : Optional [ int ] = None , ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: vote_pubkey: Only return results for this validator vote address. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". keep_unstaked_delinquents: Filter out delinquent validators with no stake. delinquent_slot_distance: Specify the number of slots behind the tip that the validator must fall to be considered delinquent. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts().value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( vote_pubkey , commitment , keep_unstaked_delinquents , delinquent_slot_distance ) return self . _provider . make_request ( body , GetVoteAccountsResp ) def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return self . _provider . make_request ( body , RequestAirdropResp ) def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], opts : Optional [ types . TxOpts ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. opts: (optional) Transaction options. Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> ixns = [transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))] >>> msg = Message(ixns, sender.pubkey()) >>> client = Client(\"http://localhost:8899\") >>> client.send_transaction(Transaction([sender], msg, client.get_latest_blockhash().value.blockhash)) # doctest: +SKIP \"\"\" # noqa: E501 tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return self . send_raw_transaction ( bytes ( txn ), opts = tx_opts ) def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , replace_recent_blockhash : bool = False , min_context_slot : Optional [ int ] = None , inner_instructions : bool = False , accounts_addresses : Optional [ List [ Pubkey ]] = None , accounts_encoding : str = \"base64\" , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. sig_verify: If True the transaction signatures will be verified (conflicts with ``replace_recent_blockhash``). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". replace_recent_blockhash: If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with ``sig_verify``). min_context_slot: The minimum slot that the request can be evaluated at. inner_instructions: If true the response will include inner instructions. These inner instructions will be `jsonParsed` where possible, otherwise json. accounts_addresses: An array of accounts to return, as base-58 encoded strings accounts_encoding: Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. Example: >>> from solders.transaction import Transaction >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.from_bytes(bytes.fromhex(full_signed_tx_hex)) >>> solana_client.simulate_transaction(tx).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment , replace_recent_blockhash , min_context_slot , inner_instructions , accounts_addresses , accounts_encoding , ) return self . _provider . make_request ( body , SimulateTransactionResp ) def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit().value # doctest: +SKIP True \"\"\" return self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) # type: ignore def __post_send_with_confirm ( self , resp : SendTransactionResp , conf_comm : Commitment , last_valid_block_height : Optional [ int ], ) -> SendTransactionResp : resp = self . _post_send ( resp ) sig = resp . value self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , sig ) self . confirm_transaction ( sig , conf_comm , last_valid_block_height = last_valid_block_height ) return resp def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" timeout = time () + 90 commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment )) . value sleep ( sleep_seconds ) else : if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"Client"},{"location":"rpc/api/#solana.rpc.api.Client.__init__","text":"Init API client. Source code in solana/rpc/api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , proxy : Optional [ str ] = None , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers , proxy = proxy )","title":"__init__()"},{"location":"rpc/api/#solana.rpc.api.Client.confirm_transaction","text":"Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig Signature the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/api.py def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" timeout = time () + 90 commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment )) . value sleep ( sleep_seconds ) else : if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"confirm_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.get_account_info","text":"Returns all the account info for the specified public key, encoded in either base58 or base64. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value Account ( Account { lamports : 4104230290 , data . len : 0 , owner : 11111111111111111111111111111111 , executable : false , rent_epoch : 371 , }, ) Source code in solana/rpc/api.py def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key, encoded in either base58 or base64. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(Pubkey([0] * 31 + [1])).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetAccountInfoResp )","title":"get_account_info()"},{"location":"rpc/api/#solana.rpc.api.Client.get_account_info_json_parsed","text":"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info_json_parsed ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value . owner Pubkey ( 11111111111111111111111111111111 , ) Source code in solana/rpc/api.py def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1])).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp )","title":"get_account_info_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_balance","text":"Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_balance ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value 4104230290 Source code in solana/rpc/api.py def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(Pubkey([0] * 31 + [1])).value # doctest: +SKIP 4104230290 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetBalanceResp )","title":"get_balance()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block","text":"Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' max_supported_transaction_version Union[int, None] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block ( 1 ) . value . blockhash Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/api.py def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : Union [ int , None ] = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return self . _provider . make_request ( body , GetBlockResp )","title":"get_block()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_commitment","text":"Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_commitment ( 0 ) . total_stake 497717120 Source code in solana/rpc/api.py def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return self . _provider . make_request ( body , GetBlockCommitmentResp )","title":"get_block_commitment()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_height","text":"Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_height () . value 1233 Source code in solana/rpc/api.py def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height().value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return self . _provider . make_request ( body , GetBlockHeightResp )","title":"get_block_height()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_time","text":"Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_time ( 5 ) . value 1598400007 Source code in solana/rpc/api.py def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return self . _provider . make_request ( body , GetBlockTimeResp )","title":"get_block_time()"},{"location":"rpc/api/#solana.rpc.api.Client.get_blocks","text":"Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_blocks ( 5 , 10 ) . value [ 5 , 6 , 7 , 8 , 9 , 10 ] Source code in solana/rpc/api.py def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return self . _provider . make_request ( body , GetBlocksResp )","title":"get_blocks()"},{"location":"rpc/api/#solana.rpc.api.Client.get_cluster_nodes","text":"Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_cluster_nodes () . value [ 0 ] . tpu '139.178.65.155:8004' Source code in solana/rpc/api.py def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes().value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp )","title":"get_cluster_nodes()"},{"location":"rpc/api/#solana.rpc.api.Client.get_epoch_info","text":"Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_info () . value . epoch 0 Source code in solana/rpc/api.py def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info().value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return self . _provider . make_request ( body , GetEpochInfoResp )","title":"get_epoch_info()"},{"location":"rpc/api/#solana.rpc.api.Client.get_epoch_schedule","text":"Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_schedule () . value . slots_per_epoch 8192 Source code in solana/rpc/api.py def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule().value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp )","title":"get_epoch_schedule()"},{"location":"rpc/api/#solana.rpc.api.Client.get_fee_for_message","text":"Returns the fee for a message. Parameters: Name Type Description Default message VersionedMessage Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solders.message import Message >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> msg = Message ([ transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))]) >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fee_for_message ( msg ) . value 5000 Source code in solana/rpc/api.py def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> msg = Message([transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))]) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(msg).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return self . _provider . make_request ( body , GetFeeForMessageResp )","title":"get_fee_for_message()"},{"location":"rpc/api/#solana.rpc.api.Client.get_first_available_block","text":"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_first_available_block () . value 1 Source code in solana/rpc/api.py def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_first_available_block().value # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp )","title":"get_first_available_block()"},{"location":"rpc/api/#solana.rpc.api.Client.get_genesis_hash","text":"Returns the genesis hash. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_genesis_hash () . value Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/api.py def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash().value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp )","title":"get_genesis_hash()"},{"location":"rpc/api/#solana.rpc.api.Client.get_identity","text":"Returns the identity pubkey for the current node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_identity () . value . identity Pubkey ( 2 LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv , ) Source code in solana/rpc/api.py def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity().value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return self . _provider . make_request ( self . _get_identity , GetIdentityResp )","title":"get_identity()"},{"location":"rpc/api/#solana.rpc.api.Client.get_inflation_governor","text":"Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_governor () . value . foundation 0.05 Source code in solana/rpc/api.py def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor().value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return self . _provider . make_request ( body , GetInflationGovernorResp )","title":"get_inflation_governor()"},{"location":"rpc/api/#solana.rpc.api.Client.get_inflation_rate","text":"Returns the specific inflation values for the current epoch. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_rate () . value . epoch 1 Source code in solana/rpc/api.py def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate().value.epoch # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp )","title":"get_inflation_rate()"},{"location":"rpc/api/#solana.rpc.api.Client.get_inflation_reward","text":"Returns the inflation / staking reward for a list of addresses for an epoch. Parameters: Name Type Description Default pubkeys List[Pubkey] An array of addresses to query, as base-58 encoded strings required epoch Optional[int] (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\" or \"confirmed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_reward () . value . amount 2500 Source code in solana/rpc/api.py def get_inflation_reward ( self , pubkeys : List [ Pubkey ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetInflationRewardResp : \"\"\"Returns the inflation / staking reward for a list of addresses for an epoch. Args: pubkeys: An array of addresses to query, as base-58 encoded strings epoch: (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used commitment: Bank state to query. It can be either \"finalized\" or \"confirmed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_reward().value.amount # doctest: +SKIP 2500 \"\"\" body = self . _get_inflation_reward_body ( pubkeys , epoch , commitment ) return self . _provider . make_request ( body , GetInflationRewardResp )","title":"get_inflation_reward()"},{"location":"rpc/api/#solana.rpc.api.Client.get_largest_accounts","text":"Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_largest_accounts () . value [ 0 ] . lamports 500000000000000000 Source code in solana/rpc/api.py def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts().value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return self . _provider . make_request ( body , GetLargestAccountsResp )","title":"get_largest_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_latest_blockhash","text":"Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_latest_blockhash () . value RpcBlockhash { blockhash : Hash ( 4 TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT , ), last_valid_block_height : 158286487 , } Source code in solana/rpc/api.py def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash().value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return self . _provider . make_request ( body , GetLatestBlockhashResp )","title":"get_latest_blockhash()"},{"location":"rpc/api/#solana.rpc.api.Client.get_leader_schedule","text":"Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> list ( solana_client . get_leader_schedule () . value . items ())[ 0 ] ( Pubkey ( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr , ), [ 346448 , 346449 , 346450 , 346451 , 369140 , 369141 , 369142 , 369143 , 384204 , 384205 , 384206 , 384207 ]) Source code in solana/rpc/api.py def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> list(solana_client.get_leader_schedule().value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return self . _provider . make_request ( body , GetLeaderScheduleResp )","title":"get_leader_schedule()"},{"location":"rpc/api/#solana.rpc.api.Client.get_minimum_balance_for_rent_exemption","text":"Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_balance_for_rent_exemption ( 50 ) . value 1238880 Source code in solana/rpc/api.py def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp )","title":"get_minimum_balance_for_rent_exemption()"},{"location":"rpc/api/#solana.rpc.api.Client.get_minimum_ledger_slot","text":"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_ledger_slot () . value 1234 Source code in solana/rpc/api.py def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot().value # doctest: +SKIP 1234 \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp )","title":"get_minimum_ledger_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_multiple_accounts","text":"Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts ( pubkeys ) . value [ 0 ] . lamports 1 Source code in solana/rpc/api.py def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetMultipleAccountsResp )","title":"get_multiple_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_multiple_accounts_json_parsed","text":"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Parameters: Name Type Description Default pubkeys List[Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts_json_parsed ( pubkeys ) . value [ 0 ] . lamports 1 Source code in solana/rpc/api.py def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts_json_parsed(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp )","title":"get_multiple_accounts_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_program_accounts","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". 'base64' data_slice Optional[types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required filters Optional[Sequence[Union[int, types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List , Union >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> solana_client . get_program_accounts ( pubkey , filters = filters ) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/api.py def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsResp )","title":"get_program_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_program_accounts_json_parsed","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None filters Optional[Sequence[Union[int, types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List , Union >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> solana_client . get_program_accounts ( pubkey , filters = filters ) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/api.py def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp )","title":"get_program_accounts_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_recent_performance_samples","text":"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_recent_performance_samples ( 1 ) . value [ 0 ] RpcPerfSample ( RpcPerfSample { slot : 168036172 , num_transactions : 7159 , num_slots : 158 , sample_period_secs : 60 , }, ) Source code in solana/rpc/api.py def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(1).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return self . _provider . make_request ( body , GetRecentPerformanceSamplesResp )","title":"get_recent_performance_samples()"},{"location":"rpc/api/#solana.rpc.api.Client.get_signature_statuses","text":"Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[Signature] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> sigs = [ Signature . from_string ( sig ) for sig in raw_sigs ] >>> solana_client . get_signature_statuses ( sigs ) . value [ 0 ] . confirmations 10 Source code in solana/rpc/api.py def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> solana_client.get_signature_statuses(sigs).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return self . _provider . make_request ( body , GetSignatureStatusesResp )","title":"get_signature_statuses()"},{"location":"rpc/api/#solana.rpc.api.Client.get_signatures_for_address","text":"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Pubkey Account to be queried. required before Optional[Signature] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[Signature] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey . from_string ( \"Vote111111111111111111111111111111111111111\" ) >>> solana_client . get_signatures_for_address ( pubkey , limit = 1 ) . value [ 0 ] . signature Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> solana_client.get_signatures_for_address(pubkey, limit=1).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return self . _provider . make_request ( body , GetSignaturesForAddressResp )","title":"get_signatures_for_address()"},{"location":"rpc/api/#solana.rpc.api.Client.get_slot","text":"Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot () . value 7515 Source code in solana/rpc/api.py def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot().value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return self . _provider . make_request ( body , GetSlotResp )","title":"get_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_slot_leader","text":"Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot_leader () . value Pubkey ( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV , ) Source code in solana/rpc/api.py def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader().value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return self . _provider . make_request ( body , GetSlotLeaderResp )","title":"get_slot_leader()"},{"location":"rpc/api/#solana.rpc.api.Client.get_slot_leaders","text":"Returns the list of slot leaders for the provided start slot and limit. Parameters: Name Type Description Default start int The start slot to get the slot leaders from. required limit int The number of slot leaders to return. required Returns: Type Description GetSlotLeadersResp A list of slot leaders. Source code in solana/rpc/api.py def get_slot_leaders ( self , start : int , limit : int ) -> GetSlotLeadersResp : \"\"\"Returns the list of slot leaders for the provided start slot and limit. Args: start: The start slot to get the slot leaders from. limit: The number of slot leaders to return. Returns: A list of slot leaders. \"\"\" body = self . _get_slot_leaders_body ( start , limit ) return self . _provider . make_request ( body , GetSlotLeadersResp )","title":"get_slot_leaders()"},{"location":"rpc/api/#solana.rpc.api.Client.get_supply","text":"Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_supply () . value . circulating 683635192454157660 Source code in solana/rpc/api.py def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply().value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return self . _provider . make_request ( body , GetSupplyResp )","title":"get_supply()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_account_balance","text":"Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Pubkey Pubkey of Token account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkey = Pubkey . from_string ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) >>> solana_client . get_token_account_balance ( pubkey ) . value . amount # noqa: E501 '9864' Source code in solana/rpc/api.py def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> solana_client.get_token_account_balance(pubkey).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenAccountBalanceResp )","title":"get_token_account_balance()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_delegate","text":"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateResp )","title":"get_token_accounts_by_delegate()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_delegate_json_parsed","text":"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp )","title":"get_token_accounts_by_delegate_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_owner","text":"Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerResp )","title":"get_token_accounts_by_owner()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_owner_json_parsed","text":"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp )","title":"get_token_accounts_by_owner_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_largest_accounts","text":"Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/api.py def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenLargestAccountsResp )","title":"get_token_largest_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_supply","text":"Returns the total supply of an SPL Token type. Source code in solana/rpc/api.py def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenSupplyResp )","title":"get_token_supply()"},{"location":"rpc/api/#solana.rpc.api.Client.get_transaction","text":"Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig Signature Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> from solders.signature import Signature >>> sig = Signature . from_string ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) >>> solana_client . get_transaction ( sig ) . value . block_time 1234 Source code in solana/rpc/api.py def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> solana_client.get_transaction(sig).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return self . _provider . make_request ( body , GetTransactionResp )","title":"get_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.get_transaction_count","text":"Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_transaction_count () . value 4554 Source code in solana/rpc/api.py def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count().value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return self . _provider . make_request ( body , GetTransactionCountResp )","title":"get_transaction_count()"},{"location":"rpc/api/#solana.rpc.api.Client.get_version","text":"Returns the current solana versions running on the node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_version () . value . solana_core '1.13.2' Source code in solana/rpc/api.py def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version().value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return self . _provider . make_request ( self . _get_version , GetVersionResp )","title":"get_version()"},{"location":"rpc/api/#solana.rpc.api.Client.get_vote_accounts","text":"Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default vote_pubkey Optional[Pubkey] Only return results for this validator vote address. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None keep_unstaked_delinquents Optional[bool] Filter out delinquent validators with no stake. None delinquent_slot_distance Optional[int] Specify the number of slots behind the tip that the validator must fall to be considered delinquent. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_vote_accounts () . value . current [ 0 ] . commission 100 Source code in solana/rpc/api.py def get_vote_accounts ( self , vote_pubkey : Optional [ Pubkey ] = None , commitment : Optional [ Commitment ] = None , keep_unstaked_delinquents : Optional [ bool ] = None , delinquent_slot_distance : Optional [ int ] = None , ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: vote_pubkey: Only return results for this validator vote address. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". keep_unstaked_delinquents: Filter out delinquent validators with no stake. delinquent_slot_distance: Specify the number of slots behind the tip that the validator must fall to be considered delinquent. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts().value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( vote_pubkey , commitment , keep_unstaked_delinquents , delinquent_slot_distance ) return self . _provider . make_request ( body , GetVoteAccountsResp )","title":"get_vote_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.is_connected","text":"Health check. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . is_connected () True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/api.py def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" body = self . _get_health_body () response = self . _provider . make_request ( body , GetHealthResp ) return response . value == \"ok\"","title":"is_connected()"},{"location":"rpc/api/#solana.rpc.api.Client.request_airdrop","text":"Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amout of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . request_airdrop ( Pubkey ([ 0 ] * 31 + [ 1 ]), 10000 ) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return self . _provider . make_request ( body , RequestAirdropResp )","title":"request_airdrop()"},{"location":"rpc/api/#solana.rpc.api.Client.send_raw_transaction","text":"Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn bytes Transaction bytes. required opts Optional[types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client . send_raw_transaction ( bytes . fromhex ( full_signed_tx_hex )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args )","title":"send_raw_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.send_transaction","text":"Send a transaction. Parameters: Name Type Description Default txn Union[VersionedTransaction, Transaction] transaction object. required opts Optional[types.TxOpts] (optional) Transaction options. None Examples: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams , transfer >>> from solders.message import Message >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> ixns = [ transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))] >>> msg = Message ( ixns , sender . pubkey ()) >>> client = Client ( \"http://localhost:8899\" ) >>> client . send_transaction ( Transaction ([ sender ], msg , client . get_latest_blockhash () . value . blockhash )) Source code in solana/rpc/api.py def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], opts : Optional [ types . TxOpts ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. opts: (optional) Transaction options. Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> ixns = [transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))] >>> msg = Message(ixns, sender.pubkey()) >>> client = Client(\"http://localhost:8899\") >>> client.send_transaction(Transaction([sender], msg, client.get_latest_blockhash().value.blockhash)) # doctest: +SKIP \"\"\" # noqa: E501 tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return self . send_raw_transaction ( bytes ( txn ), opts = tx_opts )","title":"send_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.simulate_transaction","text":"Simulate sending a transaction. Parameters: Name Type Description Default txn Union[Transaction, VersionedTransaction] A transaction object. required sig_verify bool If True the transaction signatures will be verified (conflicts with replace_recent_blockhash ). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None replace_recent_blockhash bool If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with sig_verify ). False min_context_slot Optional[int] The minimum slot that the request can be evaluated at. None inner_instructions bool If true the response will include inner instructions. These inner instructions will be jsonParsed where possible, otherwise json. False accounts_addresses Optional[List[Pubkey]] An array of accounts to return, as base-58 encoded strings None accounts_encoding str Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. 'base64' Examples: >>> from solders.transaction import Transaction >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction . from_bytes ( bytes . fromhex ( full_signed_tx_hex )) >>> solana_client . simulate_transaction ( tx ) . value . logs [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ] Source code in solana/rpc/api.py def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , replace_recent_blockhash : bool = False , min_context_slot : Optional [ int ] = None , inner_instructions : bool = False , accounts_addresses : Optional [ List [ Pubkey ]] = None , accounts_encoding : str = \"base64\" , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. sig_verify: If True the transaction signatures will be verified (conflicts with ``replace_recent_blockhash``). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". replace_recent_blockhash: If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with ``sig_verify``). min_context_slot: The minimum slot that the request can be evaluated at. inner_instructions: If true the response will include inner instructions. These inner instructions will be `jsonParsed` where possible, otherwise json. accounts_addresses: An array of accounts to return, as base-58 encoded strings accounts_encoding: Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. Example: >>> from solders.transaction import Transaction >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.from_bytes(bytes.fromhex(full_signed_tx_hex)) >>> solana_client.simulate_transaction(tx).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment , replace_recent_blockhash , min_context_slot , inner_instructions , accounts_addresses , accounts_encoding , ) return self . _provider . make_request ( body , SimulateTransactionResp )","title":"simulate_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.validator_exit","text":"Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . validator_exit () . value True Source code in solana/rpc/api.py def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit().value # doctest: +SKIP True \"\"\" return self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) # type: ignore","title":"validator_exit()"},{"location":"rpc/async_api/","text":"Async API Client Async API client to interact with the Solana JSON RPC Endpoint. AsyncClient ( _ClientCore ) Async client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None timeout float HTTP request timeout in seconds. 10 extra_headers Optional[Dict[str, str]] Extra headers to pass for HTTP request. None proxy Optional[str] Proxy URL to pass to the HTTP client. None Source code in solana/rpc/async_api.py class AsyncClient ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Async client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". timeout: HTTP request timeout in seconds. extra_headers: Extra headers to pass for HTTP request. proxy: Proxy URL to pass to the HTTP client. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , proxy : Optional [ str ] = None , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers , proxy = proxy ) async def __aenter__ ( self ) -> \"AsyncClient\" : \"\"\"Use as a context manager.\"\"\" await self . _provider . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" body = self . _get_health_body () response = await self . _provider . make_request ( body , GetHealthResp ) return response . value == \"ok\" async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_balance(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP 0 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetBalanceResp ) async def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetAccountInfoResp ) async def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1]))).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return await self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) async def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_commitment(0)).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return await self . _provider . make_request ( body , GetBlockCommitmentResp ) async def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_time(5)).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return await self . _provider . make_request ( body , GetBlockTimeResp ) async def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_cluster_nodes()).value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) async def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : Union [ int , None ] = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block(1)).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetBlockResp ) async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_recent_performance_samples(1)).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return await self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_height()).value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return await self . _provider . make_request ( body , GetBlockHeightResp ) async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_blocks(5, 10)).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return await self . _provider . make_request ( body , GetBlocksResp ) async def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> (await solana_client.get_signatures_for_address(pubkey, limit=1)).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return await self . _provider . make_request ( body , GetSignaturesForAddressResp ) async def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> (await solana_client.get_transaction(sig)).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetTransactionResp ) async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_info()).value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return await self . _provider . make_request ( body , GetEpochInfoResp ) async def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_schedule()).value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) async def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> msg = Message([transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))]) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_fee_for_message(msg)).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return await self . _provider . make_request ( body , GetFeeForMessageResp ) async def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_first_available_block()).value # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) async def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_genesis_hash()).value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) async def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_identity()).value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return await self . _provider . make_request ( self . _get_identity , GetIdentityResp ) async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> await (solana_client.get_inflation_governor()).value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return await self . _provider . make_request ( body , GetInflationGovernorResp ) async def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_rate()).value.epoch # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) async def get_inflation_reward ( self , pubkeys : List [ Pubkey ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetInflationRewardResp : \"\"\"Returns the inflation / staking reward for a list of addresses for an epoch. Args: pubkeys: An array of addresses to query, as base-58 encoded strings epoch: (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used commitment: Bank state to query. It can be either \"finalized\" or \"confirmed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_reward()).value.amount # doctest: +SKIP 2500 \"\"\" body = self . _get_inflation_reward_body ( pubkeys , epoch , commitment ) return await self . _provider . make_request ( body , GetInflationRewardResp ) async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_largest_accounts()).value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return await self . _provider . make_request ( body , GetLargestAccountsResp ) async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> resp = await solana_client.get_leader_schedule() # doctest: +SKIP >>> list(resp.value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return await self . _provider . make_request ( body , GetLeaderScheduleResp ) async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_balance_for_rent_exemption(50)).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return await self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) async def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> (await solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) async def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return await self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsResp ) async def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_latest_blockhash()).value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return await self . _provider . make_request ( body , GetLatestBlockhashResp ) async def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> (await solana_client.get_signature_statuses(sigs)).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return await self . _provider . make_request ( body , GetSignatureStatusesResp ) async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot()).value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return await self . _provider . make_request ( body , GetSlotResp ) async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot_leader()).value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return await self . _provider . make_request ( body , GetSlotLeaderResp ) async def get_slot_leaders ( self , start : int , limit : int ) -> GetSlotLeadersResp : \"\"\"Returns the list of slot leaders for the provided start slot and limit. Args: start: The start slot to get the slot leaders from. limit: The number of slot leaders to return. Returns: A list of slot leaders. \"\"\" body = self . _get_slot_leaders_body ( start , limit ) return await self . _provider . make_request ( body , GetSlotLeadersResp ) async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_supply()).value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return await self . _provider . make_request ( body , GetSupplyResp ) async def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> (await solana_client.get_token_account_balance(pubkey)).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenAccountBalanceResp ) async def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) async def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) async def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) async def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) async def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenLargestAccountsResp ) async def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenSupplyResp ) async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_transaction_count()).value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return await self . _provider . make_request ( body , GetTransactionCountResp ) async def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_ledger_slot()).value # doctest: +SKIP 1234 \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) async def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_version()).value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return await self . _provider . make_request ( self . _get_version , GetVersionResp ) async def get_vote_accounts ( self , vote_pubkey : Optional [ Pubkey ] = None , commitment : Optional [ Commitment ] = None , keep_unstaked_delinquents : Optional [ bool ] = None , delinquent_slot_distance : Optional [ int ] = None , ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: vote_pubkey: Only return results for this validator vote address. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". keep_unstaked_delinquents: Filter out delinquent validators with no stake. delinquent_slot_distance: Specify the number of slots behind the tip that the validator must fall to be considered delinquent. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_vote_accounts()).value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( vote_pubkey , commitment , keep_unstaked_delinquents , delinquent_slot_distance ) return await self . _provider . make_request ( body , GetVoteAccountsResp ) async def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return await self . _provider . make_request ( body , RequestAirdropResp ) async def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> (await solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex))).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = await self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) async def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], opts : Optional [ types . TxOpts ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. opts: (optional) Transaction options. Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> from solders.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> ixns = [transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))] >>> msg = Message(ixns, sender.pubkey()) >>> client = AsyncClient(\"http://localhost:8899\") >>> (await client.send_transaction(Transaction([sender], msg, (await client.get_latest_blockhash()).value.blockhash))) # doctest: +SKIP \"\"\" # noqa: E501 return await self . send_raw_transaction ( bytes ( txn ), opts = opts ) async def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , replace_recent_blockhash : bool = False , min_context_slot : Optional [ int ] = None , inner_instructions : bool = False , accounts_addresses : Optional [ List [ Pubkey ]] = None , accounts_encoding : str = \"base64\" , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. sig_verify: If True the transaction signatures will be verified (conflicts with ``replace_recent_blockhash``). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". replace_recent_blockhash: If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with ``sig_verify``). min_context_slot: The minimum slot that the request can be evaluated at. inner_instructions: If true the response will include inner instructions. These inner instructions will be `jsonParsed` where possible, otherwise json. accounts_addresses: An array of accounts to return, as base-58 encoded strings accounts_encoding: Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.from_bytes(bytes.fromhex(full_signed_tx_hex)) >>> (await solana_client.simulate_transaction(tx)).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment , replace_recent_blockhash , min_context_slot , inner_instructions , accounts_addresses , accounts_encoding , ) return await self . _provider . make_request ( body , SimulateTransactionResp ) async def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.validator_exit()).value # doctest: +SKIP True \"\"\" return await self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) # type: ignore async def __post_send_with_confirm ( self , resp : SendTransactionResp , conf_comm : Commitment , last_valid_block_height : Optional [ int ], ) -> SendTransactionResp : resp = self . _post_send ( resp ) sig = resp . value self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , sig ) await self . confirm_transaction ( sig , conf_comm , last_valid_block_height = last_valid_block_height ) return resp async def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment )) . value await asyncio . sleep ( sleep_seconds ) else : raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 90 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp __aenter__ ( self ) async special Use as a context manager. Source code in solana/rpc/async_api.py async def __aenter__ ( self ) -> \"AsyncClient\" : \"\"\"Use as a context manager.\"\"\" await self . _provider . __aenter__ () return self __aexit__ ( self , _exc_type , _exc , _tb ) async special Exits the context manager. Source code in solana/rpc/async_api.py async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () __init__ ( self , endpoint = None , commitment = None , timeout = 10 , extra_headers = None , proxy = None ) special Init API client. Source code in solana/rpc/async_api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , proxy : Optional [ str ] = None , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers , proxy = proxy ) close ( self ) async Use this when you are done with the client. Source code in solana/rpc/async_api.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () confirm_transaction ( self , tx_sig , commitment = None , sleep_seconds = 0.5 , last_valid_block_height = None ) async Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig Signature the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/async_api.py async def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment )) . value await asyncio . sleep ( sleep_seconds ) else : raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 90 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp get_account_info ( self , pubkey , commitment = None , encoding = 'base64' , data_slice = None ) async Returns all the account info for the specified public key. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_account_info ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value Account ( Account { lamports : 4104230290 , data . len : 0 , owner : 11111111111111111111111111111111 , executable : false , rent_epoch : 371 , }, ) Source code in solana/rpc/async_api.py async def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetAccountInfoResp ) get_account_info_json_parsed ( self , pubkey , commitment = None ) async Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_account_info_json_parsed ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value . owner Pubkey ( 11111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1]))).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return await self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) get_balance ( self , pubkey , commitment = None ) async Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_balance ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value 0 Source code in solana/rpc/async_api.py async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_balance(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP 0 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetBalanceResp ) get_block ( self , slot , encoding = 'json' , max_supported_transaction_version = None ) async Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block ( 1 )) . value . blockhash Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/async_api.py async def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : Union [ int , None ] = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block(1)).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetBlockResp ) get_block_commitment ( self , slot ) async Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_commitment ( 0 )) . total_stake 497717120 Source code in solana/rpc/async_api.py async def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_commitment(0)).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return await self . _provider . make_request ( body , GetBlockCommitmentResp ) get_block_height ( self , commitment = None ) async Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_height ()) . value 1233 Source code in solana/rpc/async_api.py async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_height()).value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return await self . _provider . make_request ( body , GetBlockHeightResp ) get_block_time ( self , slot ) async Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_time ( 5 )) . value 1598400007 Source code in solana/rpc/async_api.py async def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_time(5)).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return await self . _provider . make_request ( body , GetBlockTimeResp ) get_blocks ( self , start_slot , end_slot = None ) async Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_blocks ( 5 , 10 )) . value [ 5 , 6 , 7 , 8 , 9 , 10 ] Source code in solana/rpc/async_api.py async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_blocks(5, 10)).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return await self . _provider . make_request ( body , GetBlocksResp ) get_cluster_nodes ( self ) async Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_cluster_nodes ()) . value [ 0 ] . tpu '139.178.65.155:8004' Source code in solana/rpc/async_api.py async def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_cluster_nodes()).value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) get_epoch_info ( self , commitment = None ) async Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_epoch_info ()) . value . epoch 0 Source code in solana/rpc/async_api.py async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_info()).value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return await self . _provider . make_request ( body , GetEpochInfoResp ) get_epoch_schedule ( self ) async Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_epoch_schedule ()) . value . slots_per_epoch 8192 Source code in solana/rpc/async_api.py async def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_schedule()).value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) get_fee_for_message ( self , message , commitment = None ) async Returns the fee for a message. Parameters: Name Type Description Default message Union[solders.message.Message, solders.message.MessageV0] Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solders.message import Message >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> msg = Message ([ transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))]) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_fee_for_message ( msg )) . value 5000 Source code in solana/rpc/async_api.py async def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> msg = Message([transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))]) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_fee_for_message(msg)).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return await self . _provider . make_request ( body , GetFeeForMessageResp ) get_first_available_block ( self ) async Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_first_available_block ()) . value 1 Source code in solana/rpc/async_api.py async def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_first_available_block()).value # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) get_genesis_hash ( self ) async Returns the genesis hash. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_genesis_hash ()) . value Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/async_api.py async def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_genesis_hash()).value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) get_identity ( self ) async Returns the identity pubkey for the current node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_identity ()) . value . identity Pubkey ( 2 LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv , ) Source code in solana/rpc/async_api.py async def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_identity()).value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return await self . _provider . make_request ( self . _get_identity , GetIdentityResp ) get_inflation_governor ( self , commitment = None ) async Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> await ( solana_client . get_inflation_governor ()) . value . foundation 0.05 Source code in solana/rpc/async_api.py async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> await (solana_client.get_inflation_governor()).value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return await self . _provider . make_request ( body , GetInflationGovernorResp ) get_inflation_rate ( self ) async Returns the specific inflation values for the current epoch. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_inflation_rate ()) . value . epoch 1 Source code in solana/rpc/async_api.py async def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_rate()).value.epoch # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) get_inflation_reward ( self , pubkeys , epoch = None , commitment = None ) async Returns the inflation / staking reward for a list of addresses for an epoch. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] An array of addresses to query, as base-58 encoded strings required epoch Optional[int] (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\" or \"confirmed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_inflation_reward ()) . value . amount 2500 Source code in solana/rpc/async_api.py async def get_inflation_reward ( self , pubkeys : List [ Pubkey ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetInflationRewardResp : \"\"\"Returns the inflation / staking reward for a list of addresses for an epoch. Args: pubkeys: An array of addresses to query, as base-58 encoded strings epoch: (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used commitment: Bank state to query. It can be either \"finalized\" or \"confirmed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_reward()).value.amount # doctest: +SKIP 2500 \"\"\" body = self . _get_inflation_reward_body ( pubkeys , epoch , commitment ) return await self . _provider . make_request ( body , GetInflationRewardResp ) get_largest_accounts ( self , filter_opt = None , commitment = None ) async Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_largest_accounts ()) . value [ 0 ] . lamports 500000000000000000 Source code in solana/rpc/async_api.py async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_largest_accounts()).value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return await self . _provider . make_request ( body , GetLargestAccountsResp ) get_latest_blockhash ( self , commitment = None ) async Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_latest_blockhash ()) . value RpcBlockhash { blockhash : Hash ( 4 TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT , ), last_valid_block_height : 158286487 , } Source code in solana/rpc/async_api.py async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_latest_blockhash()).value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return await self . _provider . make_request ( body , GetLatestBlockhashResp ) get_leader_schedule ( self , epoch = None , commitment = None ) async Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> resp = await solana_client . get_leader_schedule () >>> list ( resp . value . items ())[ 0 ] ( Pubkey ( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr , ), [ 346448 , 346449 , 346450 , 346451 , 369140 , 369141 , 369142 , 369143 , 384204 , 384205 , 384206 , 384207 ]) Source code in solana/rpc/async_api.py async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> resp = await solana_client.get_leader_schedule() # doctest: +SKIP >>> list(resp.value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return await self . _provider . make_request ( body , GetLeaderScheduleResp ) get_minimum_balance_for_rent_exemption ( self , usize , commitment = None ) async Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_minimum_balance_for_rent_exemption ( 50 )) . value 1238880 Source code in solana/rpc/async_api.py async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_balance_for_rent_exemption(50)).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return await self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) get_minimum_ledger_slot ( self ) async Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_minimum_ledger_slot ()) . value 1234 Source code in solana/rpc/async_api.py async def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_ledger_slot()).value # doctest: +SKIP 1234 \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) get_multiple_accounts ( self , pubkeys , commitment = None , encoding = 'base64' , data_slice = None ) async Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> ( await solana_client . get_multiple_accounts ( pubkeys )) . value [ 0 ] . lamports 1 Source code in solana/rpc/async_api.py async def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> (await solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) get_multiple_accounts_json_parsed ( self , pubkeys , commitment = None ) async Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> asyncio . run ( solana_client . get_multiple_accounts ( pubkeys )) . value [ 0 ] . lamports 1 Source code in solana/rpc/async_api.py async def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return await self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) get_program_accounts ( self , pubkey , commitment = None , encoding = None , data_slice = None , filters = None ) async Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding Optional[str] (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from typing import List , Union >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , types . MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> ( await solana_client . get_program_accounts ( pubkey , filters = filters )) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/async_api.py async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsResp ) get_program_accounts_json_parsed ( self , pubkey , commitment = None , filters = None ) async Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from typing import List , Union >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , types . MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> ( await solana_client . get_program_accounts ( pubkey , filters = filters )) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/async_api.py async def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) get_recent_performance_samples ( self , limit = None ) async Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_recent_performance_samples ( 1 )) . value [ 0 ] RpcPerfSample ( RpcPerfSample { slot : 168036172 , num_transactions : 7159 , num_slots : 158 , sample_period_secs : 60 , }, ) Source code in solana/rpc/async_api.py async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_recent_performance_samples(1)).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return await self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) get_signature_statuses ( self , signatures , search_transaction_history = False ) async Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[solders.signature.Signature] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> sigs = [ Signature . from_string ( sig ) for sig in raw_sigs ] >>> ( await solana_client . get_signature_statuses ( sigs )) . value [ 0 ] . confirmations 10 Source code in solana/rpc/async_api.py async def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> (await solana_client.get_signature_statuses(sigs)).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return await self . _provider . make_request ( body , GetSignatureStatusesResp ) get_signatures_for_address ( self , account , before = None , until = None , limit = None , commitment = None ) async Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Pubkey Account to be queried. required before Optional[solders.signature.Signature] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[solders.signature.Signature] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey . from_string ( \"Vote111111111111111111111111111111111111111\" ) >>> ( await solana_client . get_signatures_for_address ( pubkey , limit = 1 )) . value [ 0 ] . signature Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> (await solana_client.get_signatures_for_address(pubkey, limit=1)).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return await self . _provider . make_request ( body , GetSignaturesForAddressResp ) get_slot ( self , commitment = None ) async Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_slot ()) . value 7515 Source code in solana/rpc/async_api.py async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot()).value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return await self . _provider . make_request ( body , GetSlotResp ) get_slot_leader ( self , commitment = None ) async Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_slot_leader ()) . value Pubkey ( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV , ) Source code in solana/rpc/async_api.py async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot_leader()).value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return await self . _provider . make_request ( body , GetSlotLeaderResp ) get_slot_leaders ( self , start , limit ) async Returns the list of slot leaders for the provided start slot and limit. Parameters: Name Type Description Default start int The start slot to get the slot leaders from. required limit int The number of slot leaders to return. required Returns: Type Description GetSlotLeadersResp A list of slot leaders. Source code in solana/rpc/async_api.py async def get_slot_leaders ( self , start : int , limit : int ) -> GetSlotLeadersResp : \"\"\"Returns the list of slot leaders for the provided start slot and limit. Args: start: The start slot to get the slot leaders from. limit: The number of slot leaders to return. Returns: A list of slot leaders. \"\"\" body = self . _get_slot_leaders_body ( start , limit ) return await self . _provider . make_request ( body , GetSlotLeadersResp ) get_supply ( self , commitment = None ) async Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_supply ()) . value . circulating 683635192454157660 Source code in solana/rpc/async_api.py async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_supply()).value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return await self . _provider . make_request ( body , GetSupplyResp ) get_token_account_balance ( self , pubkey , commitment = None ) async Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Pubkey Pubkey of Token account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkey = Pubkey . from_string ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) >>> ( await solana_client . get_token_account_balance ( pubkey )) . value . amount # noqa: E501 '9864' Source code in solana/rpc/async_api.py async def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> (await solana_client.get_token_account_balance(pubkey)).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenAccountBalanceResp ) get_token_accounts_by_delegate ( self , delegate , opts , commitment = None ) async Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) get_token_accounts_by_delegate_json_parsed ( self , delegate , opts , commitment = None ) async Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) get_token_accounts_by_owner ( self , owner , opts , commitment = None ) async Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) get_token_accounts_by_owner_json_parsed ( self , owner , opts , commitment = None ) async Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) get_token_largest_accounts ( self , pubkey , commitment = None ) async Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/async_api.py async def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenLargestAccountsResp ) get_token_supply ( self , pubkey , commitment = None ) async Returns the total supply of an SPL Token type. Source code in solana/rpc/async_api.py async def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenSupplyResp ) get_transaction ( self , tx_sig , encoding = 'json' , commitment = None , max_supported_transaction_version = None ) async Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig Signature Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> from solders.signature import Signature >>> sig = Signature . from_string ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) >>> ( await solana_client . get_transaction ( sig )) . value . block_time 1234 Source code in solana/rpc/async_api.py async def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> (await solana_client.get_transaction(sig)).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetTransactionResp ) get_transaction_count ( self , commitment = None ) async Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_transaction_count ()) . value 4554 Source code in solana/rpc/async_api.py async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_transaction_count()).value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return await self . _provider . make_request ( body , GetTransactionCountResp ) get_version ( self ) async Returns the current solana versions running on the node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_version ()) . value . solana_core '1.13.2' Source code in solana/rpc/async_api.py async def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_version()).value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return await self . _provider . make_request ( self . _get_version , GetVersionResp ) get_vote_accounts ( self , vote_pubkey = None , commitment = None , keep_unstaked_delinquents = None , delinquent_slot_distance = None ) async Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default vote_pubkey Optional[solders.pubkey.Pubkey] Only return results for this validator vote address. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None keep_unstaked_delinquents Optional[bool] Filter out delinquent validators with no stake. None delinquent_slot_distance Optional[int] Specify the number of slots behind the tip that the validator must fall to be considered delinquent. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_vote_accounts ()) . value . current [ 0 ] . commission 100 Source code in solana/rpc/async_api.py async def get_vote_accounts ( self , vote_pubkey : Optional [ Pubkey ] = None , commitment : Optional [ Commitment ] = None , keep_unstaked_delinquents : Optional [ bool ] = None , delinquent_slot_distance : Optional [ int ] = None , ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: vote_pubkey: Only return results for this validator vote address. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". keep_unstaked_delinquents: Filter out delinquent validators with no stake. delinquent_slot_distance: Specify the number of slots behind the tip that the validator must fall to be considered delinquent. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_vote_accounts()).value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( vote_pubkey , commitment , keep_unstaked_delinquents , delinquent_slot_distance ) return await self . _provider . make_request ( body , GetVoteAccountsResp ) is_connected ( self ) async Health check. solana_client = AsyncClient(\"http://localhost:8899\") asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/async_api.py async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" body = self . _get_health_body () response = await self . _provider . make_request ( body , GetHealthResp ) return response . value == \"ok\" request_airdrop ( self , pubkey , lamports , commitment = None ) async Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amount of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . request_airdrop ( Pubkey ([ 0 ] * 31 + [ 1 ]), 10000 )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return await self . _provider . make_request ( body , RequestAirdropResp ) send_raw_transaction ( self , txn , opts = None ) async Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn bytes Transaction bytes. required opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> ( await solana_client . send_raw_transaction ( bytes . fromhex ( full_signed_tx_hex ))) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> (await solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex))).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = await self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) send_transaction ( self , txn , opts = None ) async Send a transaction. Parameters: Name Type Description Default txn Union[solders.transaction.VersionedTransaction, solders.transaction.Transaction] transaction object. required opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solders.message import Message >>> from solders.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> ixns = [ transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))] >>> msg = Message ( ixns , sender . pubkey ()) >>> client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await client . send_transaction ( Transaction ([ sender ], msg , ( await client . get_latest_blockhash ()) . value . blockhash ))) Source code in solana/rpc/async_api.py async def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], opts : Optional [ types . TxOpts ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. opts: (optional) Transaction options. Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> from solders.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> ixns = [transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))] >>> msg = Message(ixns, sender.pubkey()) >>> client = AsyncClient(\"http://localhost:8899\") >>> (await client.send_transaction(Transaction([sender], msg, (await client.get_latest_blockhash()).value.blockhash))) # doctest: +SKIP \"\"\" # noqa: E501 return await self . send_raw_transaction ( bytes ( txn ), opts = opts ) simulate_transaction ( self , txn , sig_verify = False , commitment = None , replace_recent_blockhash = False , min_context_slot = None , inner_instructions = False , accounts_addresses = None , accounts_encoding = 'base64' ) async Simulate sending a transaction. Parameters: Name Type Description Default txn Union[solders.transaction.Transaction, solders.transaction.VersionedTransaction] A transaction object. required sig_verify bool If True the transaction signatures will be verified (conflicts with replace_recent_blockhash ). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None replace_recent_blockhash bool If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with sig_verify ). False min_context_slot Optional[int] The minimum slot that the request can be evaluated at. None inner_instructions bool If true the response will include inner instructions. These inner instructions will be jsonParsed where possible, otherwise json. False accounts_addresses Optional[List[solders.pubkey.Pubkey]] An array of accounts to return, as base-58 encoded strings None accounts_encoding str Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. 'base64' Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction . from_bytes ( bytes . fromhex ( full_signed_tx_hex )) >>> ( await solana_client . simulate_transaction ( tx )) . value . logs [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ] Source code in solana/rpc/async_api.py async def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , replace_recent_blockhash : bool = False , min_context_slot : Optional [ int ] = None , inner_instructions : bool = False , accounts_addresses : Optional [ List [ Pubkey ]] = None , accounts_encoding : str = \"base64\" , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. sig_verify: If True the transaction signatures will be verified (conflicts with ``replace_recent_blockhash``). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". replace_recent_blockhash: If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with ``sig_verify``). min_context_slot: The minimum slot that the request can be evaluated at. inner_instructions: If true the response will include inner instructions. These inner instructions will be `jsonParsed` where possible, otherwise json. accounts_addresses: An array of accounts to return, as base-58 encoded strings accounts_encoding: Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.from_bytes(bytes.fromhex(full_signed_tx_hex)) >>> (await solana_client.simulate_transaction(tx)).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment , replace_recent_blockhash , min_context_slot , inner_instructions , accounts_addresses , accounts_encoding , ) return await self . _provider . make_request ( body , SimulateTransactionResp ) validator_exit ( self ) async Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . validator_exit ()) . value True Source code in solana/rpc/async_api.py async def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.validator_exit()).value # doctest: +SKIP True \"\"\" return await self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) # type: ignore","title":"Async API Client"},{"location":"rpc/async_api/#async-api-client","text":"Async API client to interact with the Solana JSON RPC Endpoint.","title":"Async API Client"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient","text":"Async client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None timeout float HTTP request timeout in seconds. 10 extra_headers Optional[Dict[str, str]] Extra headers to pass for HTTP request. None proxy Optional[str] Proxy URL to pass to the HTTP client. None Source code in solana/rpc/async_api.py class AsyncClient ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Async client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". timeout: HTTP request timeout in seconds. extra_headers: Extra headers to pass for HTTP request. proxy: Proxy URL to pass to the HTTP client. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , proxy : Optional [ str ] = None , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers , proxy = proxy ) async def __aenter__ ( self ) -> \"AsyncClient\" : \"\"\"Use as a context manager.\"\"\" await self . _provider . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" body = self . _get_health_body () response = await self . _provider . make_request ( body , GetHealthResp ) return response . value == \"ok\" async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_balance(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP 0 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetBalanceResp ) async def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetAccountInfoResp ) async def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1]))).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return await self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) async def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_commitment(0)).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return await self . _provider . make_request ( body , GetBlockCommitmentResp ) async def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_time(5)).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return await self . _provider . make_request ( body , GetBlockTimeResp ) async def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_cluster_nodes()).value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) async def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : Union [ int , None ] = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block(1)).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetBlockResp ) async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_recent_performance_samples(1)).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return await self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_height()).value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return await self . _provider . make_request ( body , GetBlockHeightResp ) async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_blocks(5, 10)).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return await self . _provider . make_request ( body , GetBlocksResp ) async def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> (await solana_client.get_signatures_for_address(pubkey, limit=1)).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return await self . _provider . make_request ( body , GetSignaturesForAddressResp ) async def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> (await solana_client.get_transaction(sig)).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetTransactionResp ) async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_info()).value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return await self . _provider . make_request ( body , GetEpochInfoResp ) async def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_schedule()).value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) async def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> msg = Message([transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))]) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_fee_for_message(msg)).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return await self . _provider . make_request ( body , GetFeeForMessageResp ) async def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_first_available_block()).value # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) async def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_genesis_hash()).value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) async def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_identity()).value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return await self . _provider . make_request ( self . _get_identity , GetIdentityResp ) async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> await (solana_client.get_inflation_governor()).value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return await self . _provider . make_request ( body , GetInflationGovernorResp ) async def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_rate()).value.epoch # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) async def get_inflation_reward ( self , pubkeys : List [ Pubkey ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetInflationRewardResp : \"\"\"Returns the inflation / staking reward for a list of addresses for an epoch. Args: pubkeys: An array of addresses to query, as base-58 encoded strings epoch: (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used commitment: Bank state to query. It can be either \"finalized\" or \"confirmed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_reward()).value.amount # doctest: +SKIP 2500 \"\"\" body = self . _get_inflation_reward_body ( pubkeys , epoch , commitment ) return await self . _provider . make_request ( body , GetInflationRewardResp ) async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_largest_accounts()).value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return await self . _provider . make_request ( body , GetLargestAccountsResp ) async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> resp = await solana_client.get_leader_schedule() # doctest: +SKIP >>> list(resp.value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return await self . _provider . make_request ( body , GetLeaderScheduleResp ) async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_balance_for_rent_exemption(50)).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return await self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) async def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> (await solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) async def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return await self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsResp ) async def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_latest_blockhash()).value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return await self . _provider . make_request ( body , GetLatestBlockhashResp ) async def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> (await solana_client.get_signature_statuses(sigs)).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return await self . _provider . make_request ( body , GetSignatureStatusesResp ) async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot()).value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return await self . _provider . make_request ( body , GetSlotResp ) async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot_leader()).value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return await self . _provider . make_request ( body , GetSlotLeaderResp ) async def get_slot_leaders ( self , start : int , limit : int ) -> GetSlotLeadersResp : \"\"\"Returns the list of slot leaders for the provided start slot and limit. Args: start: The start slot to get the slot leaders from. limit: The number of slot leaders to return. Returns: A list of slot leaders. \"\"\" body = self . _get_slot_leaders_body ( start , limit ) return await self . _provider . make_request ( body , GetSlotLeadersResp ) async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_supply()).value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return await self . _provider . make_request ( body , GetSupplyResp ) async def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> (await solana_client.get_token_account_balance(pubkey)).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenAccountBalanceResp ) async def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) async def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) async def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) async def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) async def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenLargestAccountsResp ) async def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenSupplyResp ) async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_transaction_count()).value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return await self . _provider . make_request ( body , GetTransactionCountResp ) async def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_ledger_slot()).value # doctest: +SKIP 1234 \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) async def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_version()).value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return await self . _provider . make_request ( self . _get_version , GetVersionResp ) async def get_vote_accounts ( self , vote_pubkey : Optional [ Pubkey ] = None , commitment : Optional [ Commitment ] = None , keep_unstaked_delinquents : Optional [ bool ] = None , delinquent_slot_distance : Optional [ int ] = None , ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: vote_pubkey: Only return results for this validator vote address. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". keep_unstaked_delinquents: Filter out delinquent validators with no stake. delinquent_slot_distance: Specify the number of slots behind the tip that the validator must fall to be considered delinquent. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_vote_accounts()).value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( vote_pubkey , commitment , keep_unstaked_delinquents , delinquent_slot_distance ) return await self . _provider . make_request ( body , GetVoteAccountsResp ) async def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return await self . _provider . make_request ( body , RequestAirdropResp ) async def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> (await solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex))).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = await self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) async def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], opts : Optional [ types . TxOpts ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. opts: (optional) Transaction options. Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> from solders.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> ixns = [transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))] >>> msg = Message(ixns, sender.pubkey()) >>> client = AsyncClient(\"http://localhost:8899\") >>> (await client.send_transaction(Transaction([sender], msg, (await client.get_latest_blockhash()).value.blockhash))) # doctest: +SKIP \"\"\" # noqa: E501 return await self . send_raw_transaction ( bytes ( txn ), opts = opts ) async def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , replace_recent_blockhash : bool = False , min_context_slot : Optional [ int ] = None , inner_instructions : bool = False , accounts_addresses : Optional [ List [ Pubkey ]] = None , accounts_encoding : str = \"base64\" , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. sig_verify: If True the transaction signatures will be verified (conflicts with ``replace_recent_blockhash``). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". replace_recent_blockhash: If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with ``sig_verify``). min_context_slot: The minimum slot that the request can be evaluated at. inner_instructions: If true the response will include inner instructions. These inner instructions will be `jsonParsed` where possible, otherwise json. accounts_addresses: An array of accounts to return, as base-58 encoded strings accounts_encoding: Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.from_bytes(bytes.fromhex(full_signed_tx_hex)) >>> (await solana_client.simulate_transaction(tx)).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment , replace_recent_blockhash , min_context_slot , inner_instructions , accounts_addresses , accounts_encoding , ) return await self . _provider . make_request ( body , SimulateTransactionResp ) async def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.validator_exit()).value # doctest: +SKIP True \"\"\" return await self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) # type: ignore async def __post_send_with_confirm ( self , resp : SendTransactionResp , conf_comm : Commitment , last_valid_block_height : Optional [ int ], ) -> SendTransactionResp : resp = self . _post_send ( resp ) sig = resp . value self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , sig ) await self . confirm_transaction ( sig , conf_comm , last_valid_block_height = last_valid_block_height ) return resp async def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment )) . value await asyncio . sleep ( sleep_seconds ) else : raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 90 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"AsyncClient"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.__aenter__","text":"Use as a context manager. Source code in solana/rpc/async_api.py async def __aenter__ ( self ) -> \"AsyncClient\" : \"\"\"Use as a context manager.\"\"\" await self . _provider . __aenter__ () return self","title":"__aenter__()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.__aexit__","text":"Exits the context manager. Source code in solana/rpc/async_api.py async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close ()","title":"__aexit__()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.__init__","text":"Init API client. Source code in solana/rpc/async_api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , proxy : Optional [ str ] = None , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers , proxy = proxy )","title":"__init__()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.close","text":"Use this when you are done with the client. Source code in solana/rpc/async_api.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close ()","title":"close()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.confirm_transaction","text":"Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig Signature the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/async_api.py async def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment )) . value await asyncio . sleep ( sleep_seconds ) else : raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 90 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"confirm_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_account_info","text":"Returns all the account info for the specified public key. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_account_info ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value Account ( Account { lamports : 4104230290 , data . len : 0 , owner : 11111111111111111111111111111111 , executable : false , rent_epoch : 371 , }, ) Source code in solana/rpc/async_api.py async def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetAccountInfoResp )","title":"get_account_info()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_account_info_json_parsed","text":"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_account_info_json_parsed ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value . owner Pubkey ( 11111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1]))).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return await self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp )","title":"get_account_info_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_balance","text":"Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_balance ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value 0 Source code in solana/rpc/async_api.py async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_balance(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP 0 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetBalanceResp )","title":"get_balance()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block","text":"Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block ( 1 )) . value . blockhash Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/async_api.py async def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : Union [ int , None ] = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block(1)).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetBlockResp )","title":"get_block()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_commitment","text":"Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_commitment ( 0 )) . total_stake 497717120 Source code in solana/rpc/async_api.py async def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_commitment(0)).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return await self . _provider . make_request ( body , GetBlockCommitmentResp )","title":"get_block_commitment()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_height","text":"Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_height ()) . value 1233 Source code in solana/rpc/async_api.py async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_height()).value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return await self . _provider . make_request ( body , GetBlockHeightResp )","title":"get_block_height()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_time","text":"Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_time ( 5 )) . value 1598400007 Source code in solana/rpc/async_api.py async def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_time(5)).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return await self . _provider . make_request ( body , GetBlockTimeResp )","title":"get_block_time()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_blocks","text":"Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_blocks ( 5 , 10 )) . value [ 5 , 6 , 7 , 8 , 9 , 10 ] Source code in solana/rpc/async_api.py async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_blocks(5, 10)).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return await self . _provider . make_request ( body , GetBlocksResp )","title":"get_blocks()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_cluster_nodes","text":"Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_cluster_nodes ()) . value [ 0 ] . tpu '139.178.65.155:8004' Source code in solana/rpc/async_api.py async def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_cluster_nodes()).value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp )","title":"get_cluster_nodes()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_epoch_info","text":"Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_epoch_info ()) . value . epoch 0 Source code in solana/rpc/async_api.py async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_info()).value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return await self . _provider . make_request ( body , GetEpochInfoResp )","title":"get_epoch_info()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_epoch_schedule","text":"Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_epoch_schedule ()) . value . slots_per_epoch 8192 Source code in solana/rpc/async_api.py async def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_schedule()).value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp )","title":"get_epoch_schedule()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_fee_for_message","text":"Returns the fee for a message. Parameters: Name Type Description Default message Union[solders.message.Message, solders.message.MessageV0] Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solders.message import Message >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> msg = Message ([ transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))]) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_fee_for_message ( msg )) . value 5000 Source code in solana/rpc/async_api.py async def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> msg = Message([transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))]) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_fee_for_message(msg)).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return await self . _provider . make_request ( body , GetFeeForMessageResp )","title":"get_fee_for_message()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_first_available_block","text":"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_first_available_block ()) . value 1 Source code in solana/rpc/async_api.py async def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_first_available_block()).value # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp )","title":"get_first_available_block()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_genesis_hash","text":"Returns the genesis hash. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_genesis_hash ()) . value Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/async_api.py async def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_genesis_hash()).value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp )","title":"get_genesis_hash()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_identity","text":"Returns the identity pubkey for the current node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_identity ()) . value . identity Pubkey ( 2 LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv , ) Source code in solana/rpc/async_api.py async def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_identity()).value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return await self . _provider . make_request ( self . _get_identity , GetIdentityResp )","title":"get_identity()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_inflation_governor","text":"Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> await ( solana_client . get_inflation_governor ()) . value . foundation 0.05 Source code in solana/rpc/async_api.py async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> await (solana_client.get_inflation_governor()).value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return await self . _provider . make_request ( body , GetInflationGovernorResp )","title":"get_inflation_governor()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_inflation_rate","text":"Returns the specific inflation values for the current epoch. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_inflation_rate ()) . value . epoch 1 Source code in solana/rpc/async_api.py async def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_rate()).value.epoch # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp )","title":"get_inflation_rate()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_inflation_reward","text":"Returns the inflation / staking reward for a list of addresses for an epoch. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] An array of addresses to query, as base-58 encoded strings required epoch Optional[int] (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\" or \"confirmed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_inflation_reward ()) . value . amount 2500 Source code in solana/rpc/async_api.py async def get_inflation_reward ( self , pubkeys : List [ Pubkey ], epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetInflationRewardResp : \"\"\"Returns the inflation / staking reward for a list of addresses for an epoch. Args: pubkeys: An array of addresses to query, as base-58 encoded strings epoch: (optional) An epoch for which the reward occurs. If omitted, the previous epoch will be used commitment: Bank state to query. It can be either \"finalized\" or \"confirmed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_reward()).value.amount # doctest: +SKIP 2500 \"\"\" body = self . _get_inflation_reward_body ( pubkeys , epoch , commitment ) return await self . _provider . make_request ( body , GetInflationRewardResp )","title":"get_inflation_reward()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_largest_accounts","text":"Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_largest_accounts ()) . value [ 0 ] . lamports 500000000000000000 Source code in solana/rpc/async_api.py async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_largest_accounts()).value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return await self . _provider . make_request ( body , GetLargestAccountsResp )","title":"get_largest_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_latest_blockhash","text":"Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_latest_blockhash ()) . value RpcBlockhash { blockhash : Hash ( 4 TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT , ), last_valid_block_height : 158286487 , } Source code in solana/rpc/async_api.py async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_latest_blockhash()).value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return await self . _provider . make_request ( body , GetLatestBlockhashResp )","title":"get_latest_blockhash()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_leader_schedule","text":"Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> resp = await solana_client . get_leader_schedule () >>> list ( resp . value . items ())[ 0 ] ( Pubkey ( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr , ), [ 346448 , 346449 , 346450 , 346451 , 369140 , 369141 , 369142 , 369143 , 384204 , 384205 , 384206 , 384207 ]) Source code in solana/rpc/async_api.py async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> resp = await solana_client.get_leader_schedule() # doctest: +SKIP >>> list(resp.value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return await self . _provider . make_request ( body , GetLeaderScheduleResp )","title":"get_leader_schedule()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_minimum_balance_for_rent_exemption","text":"Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_minimum_balance_for_rent_exemption ( 50 )) . value 1238880 Source code in solana/rpc/async_api.py async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_balance_for_rent_exemption(50)).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return await self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp )","title":"get_minimum_balance_for_rent_exemption()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_minimum_ledger_slot","text":"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_minimum_ledger_slot ()) . value 1234 Source code in solana/rpc/async_api.py async def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_ledger_slot()).value # doctest: +SKIP 1234 \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp )","title":"get_minimum_ledger_slot()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_multiple_accounts","text":"Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> ( await solana_client . get_multiple_accounts ( pubkeys )) . value [ 0 ] . lamports 1 Source code in solana/rpc/async_api.py async def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> (await solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp )","title":"get_multiple_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_multiple_accounts_json_parsed","text":"Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> asyncio . run ( solana_client . get_multiple_accounts ( pubkeys )) . value [ 0 ] . lamports 1 Source code in solana/rpc/async_api.py async def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return await self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp )","title":"get_multiple_accounts_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_program_accounts","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding Optional[str] (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from typing import List , Union >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , types . MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> ( await solana_client . get_program_accounts ( pubkey , filters = filters )) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/async_api.py async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsResp )","title":"get_program_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_program_accounts_json_parsed","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from typing import List , Union >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , types . MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> ( await solana_client . get_program_accounts ( pubkey , filters = filters )) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/async_api.py async def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp )","title":"get_program_accounts_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_recent_performance_samples","text":"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_recent_performance_samples ( 1 )) . value [ 0 ] RpcPerfSample ( RpcPerfSample { slot : 168036172 , num_transactions : 7159 , num_slots : 158 , sample_period_secs : 60 , }, ) Source code in solana/rpc/async_api.py async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_recent_performance_samples(1)).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return await self . _provider . make_request ( body , GetRecentPerformanceSamplesResp )","title":"get_recent_performance_samples()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_signature_statuses","text":"Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[solders.signature.Signature] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> sigs = [ Signature . from_string ( sig ) for sig in raw_sigs ] >>> ( await solana_client . get_signature_statuses ( sigs )) . value [ 0 ] . confirmations 10 Source code in solana/rpc/async_api.py async def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> (await solana_client.get_signature_statuses(sigs)).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return await self . _provider . make_request ( body , GetSignatureStatusesResp )","title":"get_signature_statuses()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_signatures_for_address","text":"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Pubkey Account to be queried. required before Optional[solders.signature.Signature] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[solders.signature.Signature] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey . from_string ( \"Vote111111111111111111111111111111111111111\" ) >>> ( await solana_client . get_signatures_for_address ( pubkey , limit = 1 )) . value [ 0 ] . signature Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> (await solana_client.get_signatures_for_address(pubkey, limit=1)).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return await self . _provider . make_request ( body , GetSignaturesForAddressResp )","title":"get_signatures_for_address()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_slot","text":"Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_slot ()) . value 7515 Source code in solana/rpc/async_api.py async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot()).value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return await self . _provider . make_request ( body , GetSlotResp )","title":"get_slot()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_slot_leader","text":"Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_slot_leader ()) . value Pubkey ( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV , ) Source code in solana/rpc/async_api.py async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot_leader()).value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return await self . _provider . make_request ( body , GetSlotLeaderResp )","title":"get_slot_leader()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_slot_leaders","text":"Returns the list of slot leaders for the provided start slot and limit. Parameters: Name Type Description Default start int The start slot to get the slot leaders from. required limit int The number of slot leaders to return. required Returns: Type Description GetSlotLeadersResp A list of slot leaders. Source code in solana/rpc/async_api.py async def get_slot_leaders ( self , start : int , limit : int ) -> GetSlotLeadersResp : \"\"\"Returns the list of slot leaders for the provided start slot and limit. Args: start: The start slot to get the slot leaders from. limit: The number of slot leaders to return. Returns: A list of slot leaders. \"\"\" body = self . _get_slot_leaders_body ( start , limit ) return await self . _provider . make_request ( body , GetSlotLeadersResp )","title":"get_slot_leaders()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_supply","text":"Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_supply ()) . value . circulating 683635192454157660 Source code in solana/rpc/async_api.py async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_supply()).value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return await self . _provider . make_request ( body , GetSupplyResp )","title":"get_supply()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_account_balance","text":"Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Pubkey Pubkey of Token account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkey = Pubkey . from_string ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) >>> ( await solana_client . get_token_account_balance ( pubkey )) . value . amount # noqa: E501 '9864' Source code in solana/rpc/async_api.py async def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> (await solana_client.get_token_account_balance(pubkey)).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenAccountBalanceResp )","title":"get_token_account_balance()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_delegate","text":"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateResp )","title":"get_token_accounts_by_delegate()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_delegate_json_parsed","text":"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp )","title":"get_token_accounts_by_delegate_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_owner","text":"Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerResp )","title":"get_token_accounts_by_owner()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_owner_json_parsed","text":"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp )","title":"get_token_accounts_by_owner_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_largest_accounts","text":"Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/async_api.py async def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenLargestAccountsResp )","title":"get_token_largest_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_supply","text":"Returns the total supply of an SPL Token type. Source code in solana/rpc/async_api.py async def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenSupplyResp )","title":"get_token_supply()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_transaction","text":"Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig Signature Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> from solders.signature import Signature >>> sig = Signature . from_string ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) >>> ( await solana_client . get_transaction ( sig )) . value . block_time 1234 Source code in solana/rpc/async_api.py async def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> (await solana_client.get_transaction(sig)).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetTransactionResp )","title":"get_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_transaction_count","text":"Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_transaction_count ()) . value 4554 Source code in solana/rpc/async_api.py async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_transaction_count()).value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return await self . _provider . make_request ( body , GetTransactionCountResp )","title":"get_transaction_count()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_version","text":"Returns the current solana versions running on the node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_version ()) . value . solana_core '1.13.2' Source code in solana/rpc/async_api.py async def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_version()).value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return await self . _provider . make_request ( self . _get_version , GetVersionResp )","title":"get_version()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_vote_accounts","text":"Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default vote_pubkey Optional[solders.pubkey.Pubkey] Only return results for this validator vote address. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None keep_unstaked_delinquents Optional[bool] Filter out delinquent validators with no stake. None delinquent_slot_distance Optional[int] Specify the number of slots behind the tip that the validator must fall to be considered delinquent. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_vote_accounts ()) . value . current [ 0 ] . commission 100 Source code in solana/rpc/async_api.py async def get_vote_accounts ( self , vote_pubkey : Optional [ Pubkey ] = None , commitment : Optional [ Commitment ] = None , keep_unstaked_delinquents : Optional [ bool ] = None , delinquent_slot_distance : Optional [ int ] = None , ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: vote_pubkey: Only return results for this validator vote address. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". keep_unstaked_delinquents: Filter out delinquent validators with no stake. delinquent_slot_distance: Specify the number of slots behind the tip that the validator must fall to be considered delinquent. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_vote_accounts()).value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( vote_pubkey , commitment , keep_unstaked_delinquents , delinquent_slot_distance ) return await self . _provider . make_request ( body , GetVoteAccountsResp )","title":"get_vote_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.is_connected","text":"Health check. solana_client = AsyncClient(\"http://localhost:8899\") asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/async_api.py async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" body = self . _get_health_body () response = await self . _provider . make_request ( body , GetHealthResp ) return response . value == \"ok\"","title":"is_connected()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.request_airdrop","text":"Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amount of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . request_airdrop ( Pubkey ([ 0 ] * 31 + [ 1 ]), 10000 )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return await self . _provider . make_request ( body , RequestAirdropResp )","title":"request_airdrop()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.send_raw_transaction","text":"Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn bytes Transaction bytes. required opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> ( await solana_client . send_raw_transaction ( bytes . fromhex ( full_signed_tx_hex ))) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> (await solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex))).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = await self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args )","title":"send_raw_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.send_transaction","text":"Send a transaction. Parameters: Name Type Description Default txn Union[solders.transaction.VersionedTransaction, solders.transaction.Transaction] transaction object. required opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solders.message import Message >>> from solders.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> ixns = [ transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))] >>> msg = Message ( ixns , sender . pubkey ()) >>> client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await client . send_transaction ( Transaction ([ sender ], msg , ( await client . get_latest_blockhash ()) . value . blockhash ))) Source code in solana/rpc/async_api.py async def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], opts : Optional [ types . TxOpts ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. opts: (optional) Transaction options. Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solders.message import Message >>> from solders.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> ixns = [transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))] >>> msg = Message(ixns, sender.pubkey()) >>> client = AsyncClient(\"http://localhost:8899\") >>> (await client.send_transaction(Transaction([sender], msg, (await client.get_latest_blockhash()).value.blockhash))) # doctest: +SKIP \"\"\" # noqa: E501 return await self . send_raw_transaction ( bytes ( txn ), opts = opts )","title":"send_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.simulate_transaction","text":"Simulate sending a transaction. Parameters: Name Type Description Default txn Union[solders.transaction.Transaction, solders.transaction.VersionedTransaction] A transaction object. required sig_verify bool If True the transaction signatures will be verified (conflicts with replace_recent_blockhash ). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None replace_recent_blockhash bool If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with sig_verify ). False min_context_slot Optional[int] The minimum slot that the request can be evaluated at. None inner_instructions bool If true the response will include inner instructions. These inner instructions will be jsonParsed where possible, otherwise json. False accounts_addresses Optional[List[solders.pubkey.Pubkey]] An array of accounts to return, as base-58 encoded strings None accounts_encoding str Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. 'base64' Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction . from_bytes ( bytes . fromhex ( full_signed_tx_hex )) >>> ( await solana_client . simulate_transaction ( tx )) . value . logs [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ] Source code in solana/rpc/async_api.py async def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , replace_recent_blockhash : bool = False , min_context_slot : Optional [ int ] = None , inner_instructions : bool = False , accounts_addresses : Optional [ List [ Pubkey ]] = None , accounts_encoding : str = \"base64\" , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. sig_verify: If True the transaction signatures will be verified (conflicts with ``replace_recent_blockhash``). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". replace_recent_blockhash: If True the transaction recent blockhash will be replaced with the most recent blockhash (conflicts with ``sig_verify``). min_context_slot: The minimum slot that the request can be evaluated at. inner_instructions: If true the response will include inner instructions. These inner instructions will be `jsonParsed` where possible, otherwise json. accounts_addresses: An array of accounts to return, as base-58 encoded strings accounts_encoding: Encoding for returned Account data. Note: jsonParsed encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the returned accounts field is type string. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.from_bytes(bytes.fromhex(full_signed_tx_hex)) >>> (await solana_client.simulate_transaction(tx)).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment , replace_recent_blockhash , min_context_slot , inner_instructions , accounts_addresses , accounts_encoding , ) return await self . _provider . make_request ( body , SimulateTransactionResp )","title":"simulate_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.validator_exit","text":"Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . validator_exit ()) . value True Source code in solana/rpc/async_api.py async def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.validator_exit()).value # doctest: +SKIP True \"\"\" return await self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) # type: ignore","title":"validator_exit()"},{"location":"rpc/commitment/","text":"Commitment Commitment options. Solana nodes choose which bank state to query based on a commitment requirement set by the client. In descending order of commitment (most finalized to least finalized), clients may specify: Commitment Type for commitment. Confirmed The node will query the most recent block that has been voted on by supermajority of the cluster. It incorporates votes from gossip and replay. It does not count votes on descendants of a block, only direct votes on that block. This confirmation level also upholds \"optimistic confirmation\" guarantees in release 1.3 and onwards. Finalized The node will query the most recent block confirmed by supermajority of the cluster as having reached maximum lockout, meaning the cluster has recognized this block as finalized. Max Deprecated Processed The node will query its most recent block. Note that the block may not be complete. Recent Deprecated Root Deprecated Single Deprecated","title":"Commitment"},{"location":"rpc/commitment/#commitment","text":"Commitment options. Solana nodes choose which bank state to query based on a commitment requirement set by the client. In descending order of commitment (most finalized to least finalized), clients may specify:","title":"Commitment"},{"location":"rpc/commitment/#solana.rpc.commitment.Commitment","text":"Type for commitment.","title":"Commitment"},{"location":"rpc/commitment/#solana.rpc.commitment.Confirmed","text":"The node will query the most recent block that has been voted on by supermajority of the cluster. It incorporates votes from gossip and replay. It does not count votes on descendants of a block, only direct votes on that block. This confirmation level also upholds \"optimistic confirmation\" guarantees in release 1.3 and onwards.","title":"Confirmed"},{"location":"rpc/commitment/#solana.rpc.commitment.Finalized","text":"The node will query the most recent block confirmed by supermajority of the cluster as having reached maximum lockout, meaning the cluster has recognized this block as finalized.","title":"Finalized"},{"location":"rpc/commitment/#solana.rpc.commitment.Max","text":"Deprecated","title":"Max"},{"location":"rpc/commitment/#solana.rpc.commitment.Processed","text":"The node will query its most recent block. Note that the block may not be complete.","title":"Processed"},{"location":"rpc/commitment/#solana.rpc.commitment.Recent","text":"Deprecated","title":"Recent"},{"location":"rpc/commitment/#solana.rpc.commitment.Root","text":"Deprecated","title":"Root"},{"location":"rpc/commitment/#solana.rpc.commitment.Single","text":"Deprecated","title":"Single"},{"location":"rpc/providers/","text":"RPC Providers RPC Providers. async_base Async base RPC Provider. AsyncBaseProvider Base class for async RPC providers to implement. Source code in solana/rpc/providers/async_base.py class AsyncBaseProvider : \"\"\"Base class for async RPC providers to implement.\"\"\" async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) make_request ( self , body , parser ) async Make a request ot the rpc endpoint. Source code in solana/rpc/providers/async_base.py async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) async_http Async HTTP RPC Provider. AsyncHTTPProvider ( AsyncBaseProvider , _HTTPProviderCore ) Async HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/async_http.py class AsyncHTTPProvider ( AsyncBaseProvider , _HTTPProviderCore ): \"\"\"Async HTTP provider to interact with the http rpc endpoint.\"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , proxy : Optional [ str ] = None , ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . AsyncClient ( timeout = timeout , proxy = proxy ) def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"Async HTTP RPC connection { self . endpoint_uri } \" @handle_async_exceptions ( SolanaRpcException , httpx . HTTPError ) async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" raw = await self . make_request_unparsed ( body ) return _parse_raw ( raw , parser = parser ) async def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) async def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) @overload async def make_batch_request ( self , reqs : _BodiesTup , parsers : _Tup ) -> _RespTup : ... @overload async def make_batch_request ( self , reqs : _BodiesTup1 , parsers : _Tup1 ) -> _RespTup1 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup2 , parsers : _Tup2 ) -> _RespTup2 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup3 , parsers : _Tup3 ) -> _RespTup3 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup4 , parsers : _Tup4 ) -> _RespTup4 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup5 , parsers : _Tup5 ) -> _RespTup5 : ... async def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make an async HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> await provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = await self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) async def __aenter__ ( self ) -> \"AsyncHTTPProvider\" : \"\"\"Use as a context manager.\"\"\" await self . session . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose () __aenter__ ( self ) async special Use as a context manager. Source code in solana/rpc/providers/async_http.py async def __aenter__ ( self ) -> \"AsyncHTTPProvider\" : \"\"\"Use as a context manager.\"\"\" await self . session . __aenter__ () return self __aexit__ ( self , _exc_type , _exc , _tb ) async special Exits the context manager. Source code in solana/rpc/providers/async_http.py async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () __init__ ( self , endpoint = None , extra_headers = None , timeout = 10 , proxy = None ) special Init AsyncHTTPProvider. Source code in solana/rpc/providers/async_http.py def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , proxy : Optional [ str ] = None , ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . AsyncClient ( timeout = timeout , proxy = proxy ) __str__ ( self ) special String definition for HTTPProvider. Source code in solana/rpc/providers/async_http.py def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"Async HTTP RPC connection { self . endpoint_uri } \" close ( self ) async Close session. Source code in solana/rpc/providers/async_http.py async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose () make_batch_request ( self , reqs , parsers ) async Make an async HTTP batch request to an http rpc endpoint. Parameters: Name Type Description Default reqs Tuple[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe], ...] A tuple of request objects from solders.rpc.requests . required parsers Union[Tuple[Type[~T]], Tuple[Type[~T], Type[~_T1]], Tuple[Type[~T], Type[~_T1], Type[~_T2]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4], Type[~_T5]]] A tuple of response classes from solders.rpc.responses . Note: parsers should line up with reqs . required Examples: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight , GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp , GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider ( \"https://api.devnet.solana.com\" ) >>> reqs = ( GetBlockHeight (), GetFirstAvailableBlock ()) >>> parsers = ( GetBlockHeightResp , GetFirstAvailableBlockResp ) >>> await provider . make_batch_request ( reqs , parsers ) ( GetBlockHeightResp ( 158613909 , ), GetFirstAvailableBlockResp ( 86753592 , )) Source code in solana/rpc/providers/async_http.py async def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make an async HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> await provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = await self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) make_batch_request_unparsed ( self , reqs ) async Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/async_http.py async def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) make_request_unparsed ( self , body ) async Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/async_http.py async def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) base Base RPC Provider. BaseProvider Base class for RPC providers to implement. Source code in solana/rpc/providers/base.py class BaseProvider : \"\"\"Base class for RPC providers to implement.\"\"\" def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request to the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) make_request ( self , body , parser ) Make a request to the rpc endpoint. Source code in solana/rpc/providers/base.py def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request to the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) core Helper code for HTTP provider classes. get_default_endpoint () Get the default http rpc endpoint. Source code in solana/rpc/providers/core.py def get_default_endpoint () -> URI : \"\"\"Get the default http rpc endpoint.\"\"\" return URI ( os . environ . get ( \"SOLANARPC_HTTP_URI\" , \"http://localhost:8899\" )) http HTTP RPC Provider. HTTPProvider ( BaseProvider , _HTTPProviderCore ) HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/http.py class HTTPProvider ( BaseProvider , _HTTPProviderCore ): \"\"\"HTTP provider to interact with the http rpc endpoint.\"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , proxy : Optional [ str ] = None , ): \"\"\"Init HTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . Client ( timeout = timeout , proxy = proxy ) def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"HTTP RPC connection { self . endpoint_uri } \" @handle_exceptions ( SolanaRpcException , httpx . HTTPError ) def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make an HTTP request to an http rpc endpoint.\"\"\" raw = self . make_request_unparsed ( body ) return _parse_raw ( raw , parser = parser ) def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) @overload def make_batch_request ( self , reqs : _BodiesTup , parsers : _Tup ) -> _RespTup : ... @overload def make_batch_request ( self , reqs : _BodiesTup1 , parsers : _Tup1 ) -> _RespTup1 : ... @overload def make_batch_request ( self , reqs : _BodiesTup2 , parsers : _Tup2 ) -> _RespTup2 : ... @overload def make_batch_request ( self , reqs : _BodiesTup3 , parsers : _Tup3 ) -> _RespTup3 : ... @overload def make_batch_request ( self , reqs : _BodiesTup4 , parsers : _Tup4 ) -> _RespTup4 : ... @overload def make_batch_request ( self , reqs : _BodiesTup5 , parsers : _Tup5 ) -> _RespTup5 : ... def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make a HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = HTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) __init__ ( self , endpoint = None , extra_headers = None , timeout = 10 , proxy = None ) special Init HTTPProvider. Source code in solana/rpc/providers/http.py def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , proxy : Optional [ str ] = None , ): \"\"\"Init HTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . Client ( timeout = timeout , proxy = proxy ) __str__ ( self ) special String definition for HTTPProvider. Source code in solana/rpc/providers/http.py def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"HTTP RPC connection { self . endpoint_uri } \" make_batch_request ( self , reqs , parsers ) Make a HTTP batch request to an http rpc endpoint. Parameters: Name Type Description Default reqs Tuple[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe], ...] A tuple of request objects from solders.rpc.requests . required parsers Union[Tuple[Type[~T]], Tuple[Type[~T], Type[~_T1]], Tuple[Type[~T], Type[~_T1], Type[~_T2]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4], Type[~_T5]]] A tuple of response classes from solders.rpc.responses . Note: parsers should line up with reqs . required Examples: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight , GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp , GetFirstAvailableBlockResp >>> provider = HTTPProvider ( \"https://api.devnet.solana.com\" ) >>> reqs = ( GetBlockHeight (), GetFirstAvailableBlock ()) >>> parsers = ( GetBlockHeightResp , GetFirstAvailableBlockResp ) >>> provider . make_batch_request ( reqs , parsers ) ( GetBlockHeightResp ( 158613909 , ), GetFirstAvailableBlockResp ( 86753592 , )) Source code in solana/rpc/providers/http.py def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make a HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = HTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) make_batch_request_unparsed ( self , reqs ) Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/http.py def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) make_request_unparsed ( self , body ) Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/http.py def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"RPC Providers"},{"location":"rpc/providers/#rpc-providers","text":"RPC Providers.","title":"RPC Providers"},{"location":"rpc/providers/#solana.rpc.providers.async_base","text":"Async base RPC Provider.","title":"async_base"},{"location":"rpc/providers/#solana.rpc.providers.async_base.AsyncBaseProvider","text":"Base class for async RPC providers to implement. Source code in solana/rpc/providers/async_base.py class AsyncBaseProvider : \"\"\"Base class for async RPC providers to implement.\"\"\" async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"AsyncBaseProvider"},{"location":"rpc/providers/#solana.rpc.providers.async_base.AsyncBaseProvider.make_request","text":"Make a request ot the rpc endpoint. Source code in solana/rpc/providers/async_base.py async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"make_request()"},{"location":"rpc/providers/#solana.rpc.providers.async_http","text":"Async HTTP RPC Provider.","title":"async_http"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider","text":"Async HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/async_http.py class AsyncHTTPProvider ( AsyncBaseProvider , _HTTPProviderCore ): \"\"\"Async HTTP provider to interact with the http rpc endpoint.\"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , proxy : Optional [ str ] = None , ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . AsyncClient ( timeout = timeout , proxy = proxy ) def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"Async HTTP RPC connection { self . endpoint_uri } \" @handle_async_exceptions ( SolanaRpcException , httpx . HTTPError ) async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" raw = await self . make_request_unparsed ( body ) return _parse_raw ( raw , parser = parser ) async def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) async def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) @overload async def make_batch_request ( self , reqs : _BodiesTup , parsers : _Tup ) -> _RespTup : ... @overload async def make_batch_request ( self , reqs : _BodiesTup1 , parsers : _Tup1 ) -> _RespTup1 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup2 , parsers : _Tup2 ) -> _RespTup2 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup3 , parsers : _Tup3 ) -> _RespTup3 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup4 , parsers : _Tup4 ) -> _RespTup4 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup5 , parsers : _Tup5 ) -> _RespTup5 : ... async def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make an async HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> await provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = await self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) async def __aenter__ ( self ) -> \"AsyncHTTPProvider\" : \"\"\"Use as a context manager.\"\"\" await self . session . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose ()","title":"AsyncHTTPProvider"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.__aenter__","text":"Use as a context manager. Source code in solana/rpc/providers/async_http.py async def __aenter__ ( self ) -> \"AsyncHTTPProvider\" : \"\"\"Use as a context manager.\"\"\" await self . session . __aenter__ () return self","title":"__aenter__()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.__aexit__","text":"Exits the context manager. Source code in solana/rpc/providers/async_http.py async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close ()","title":"__aexit__()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.__init__","text":"Init AsyncHTTPProvider. Source code in solana/rpc/providers/async_http.py def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , proxy : Optional [ str ] = None , ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . AsyncClient ( timeout = timeout , proxy = proxy )","title":"__init__()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.__str__","text":"String definition for HTTPProvider. Source code in solana/rpc/providers/async_http.py def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"Async HTTP RPC connection { self . endpoint_uri } \"","title":"__str__()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.close","text":"Close session. Source code in solana/rpc/providers/async_http.py async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose ()","title":"close()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.make_batch_request","text":"Make an async HTTP batch request to an http rpc endpoint. Parameters: Name Type Description Default reqs Tuple[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe], ...] A tuple of request objects from solders.rpc.requests . required parsers Union[Tuple[Type[~T]], Tuple[Type[~T], Type[~_T1]], Tuple[Type[~T], Type[~_T1], Type[~_T2]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4], Type[~_T5]]] A tuple of response classes from solders.rpc.responses . Note: parsers should line up with reqs . required Examples: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight , GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp , GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider ( \"https://api.devnet.solana.com\" ) >>> reqs = ( GetBlockHeight (), GetFirstAvailableBlock ()) >>> parsers = ( GetBlockHeightResp , GetFirstAvailableBlockResp ) >>> await provider . make_batch_request ( reqs , parsers ) ( GetBlockHeightResp ( 158613909 , ), GetFirstAvailableBlockResp ( 86753592 , )) Source code in solana/rpc/providers/async_http.py async def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make an async HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> await provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = await self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers )","title":"make_batch_request()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.make_batch_request_unparsed","text":"Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/async_http.py async def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"make_batch_request_unparsed()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.make_request_unparsed","text":"Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/async_http.py async def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"make_request_unparsed()"},{"location":"rpc/providers/#solana.rpc.providers.base","text":"Base RPC Provider.","title":"base"},{"location":"rpc/providers/#solana.rpc.providers.base.BaseProvider","text":"Base class for RPC providers to implement. Source code in solana/rpc/providers/base.py class BaseProvider : \"\"\"Base class for RPC providers to implement.\"\"\" def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request to the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"BaseProvider"},{"location":"rpc/providers/#solana.rpc.providers.base.BaseProvider.make_request","text":"Make a request to the rpc endpoint. Source code in solana/rpc/providers/base.py def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request to the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"make_request()"},{"location":"rpc/providers/#solana.rpc.providers.core","text":"Helper code for HTTP provider classes.","title":"core"},{"location":"rpc/providers/#solana.rpc.providers.core.get_default_endpoint","text":"Get the default http rpc endpoint. Source code in solana/rpc/providers/core.py def get_default_endpoint () -> URI : \"\"\"Get the default http rpc endpoint.\"\"\" return URI ( os . environ . get ( \"SOLANARPC_HTTP_URI\" , \"http://localhost:8899\" ))","title":"get_default_endpoint()"},{"location":"rpc/providers/#solana.rpc.providers.http","text":"HTTP RPC Provider.","title":"http"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider","text":"HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/http.py class HTTPProvider ( BaseProvider , _HTTPProviderCore ): \"\"\"HTTP provider to interact with the http rpc endpoint.\"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , proxy : Optional [ str ] = None , ): \"\"\"Init HTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . Client ( timeout = timeout , proxy = proxy ) def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"HTTP RPC connection { self . endpoint_uri } \" @handle_exceptions ( SolanaRpcException , httpx . HTTPError ) def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make an HTTP request to an http rpc endpoint.\"\"\" raw = self . make_request_unparsed ( body ) return _parse_raw ( raw , parser = parser ) def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) @overload def make_batch_request ( self , reqs : _BodiesTup , parsers : _Tup ) -> _RespTup : ... @overload def make_batch_request ( self , reqs : _BodiesTup1 , parsers : _Tup1 ) -> _RespTup1 : ... @overload def make_batch_request ( self , reqs : _BodiesTup2 , parsers : _Tup2 ) -> _RespTup2 : ... @overload def make_batch_request ( self , reqs : _BodiesTup3 , parsers : _Tup3 ) -> _RespTup3 : ... @overload def make_batch_request ( self , reqs : _BodiesTup4 , parsers : _Tup4 ) -> _RespTup4 : ... @overload def make_batch_request ( self , reqs : _BodiesTup5 , parsers : _Tup5 ) -> _RespTup5 : ... def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make a HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = HTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers )","title":"HTTPProvider"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.__init__","text":"Init HTTPProvider. Source code in solana/rpc/providers/http.py def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , proxy : Optional [ str ] = None , ): \"\"\"Init HTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . Client ( timeout = timeout , proxy = proxy )","title":"__init__()"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.__str__","text":"String definition for HTTPProvider. Source code in solana/rpc/providers/http.py def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"HTTP RPC connection { self . endpoint_uri } \"","title":"__str__()"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.make_batch_request","text":"Make a HTTP batch request to an http rpc endpoint. Parameters: Name Type Description Default reqs Tuple[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe], ...] A tuple of request objects from solders.rpc.requests . required parsers Union[Tuple[Type[~T]], Tuple[Type[~T], Type[~_T1]], Tuple[Type[~T], Type[~_T1], Type[~_T2]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4], Type[~_T5]]] A tuple of response classes from solders.rpc.responses . Note: parsers should line up with reqs . required Examples: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight , GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp , GetFirstAvailableBlockResp >>> provider = HTTPProvider ( \"https://api.devnet.solana.com\" ) >>> reqs = ( GetBlockHeight (), GetFirstAvailableBlock ()) >>> parsers = ( GetBlockHeightResp , GetFirstAvailableBlockResp ) >>> provider . make_batch_request ( reqs , parsers ) ( GetBlockHeightResp ( 158613909 , ), GetFirstAvailableBlockResp ( 86753592 , )) Source code in solana/rpc/providers/http.py def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make a HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = HTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers )","title":"make_batch_request()"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.make_batch_request_unparsed","text":"Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/http.py def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"make_batch_request_unparsed()"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.make_request_unparsed","text":"Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/http.py def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"make_request_unparsed()"},{"location":"rpc/types/","text":"RPC Types RPC types. RPCMethod Type for RPC method. URI Type for endpoint URI. DataSliceOpts ( tuple ) Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. Source code in solana/rpc/types.py class DataSliceOpts ( NamedTuple ): \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" offset : int \"\"\"Limit the returned account data using the provided offset: <usize>.\"\"\" length : int \"\"\"Limit the returned account data using the provided length: <usize>.\"\"\" length : int Limit the returned account data using the provided length: . offset : int Limit the returned account data using the provided offset: . __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in solana/rpc/types.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , offset , length ) special staticmethod Create new instance of DataSliceOpts(offset, length) __repr__ ( self ) special Return a nicely formatted representation string Source code in solana/rpc/types.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self MemcmpOpts ( tuple ) Option to compare a provided series of bytes with program account data at a particular offset. Source code in solana/rpc/types.py class MemcmpOpts ( NamedTuple ): \"\"\"Option to compare a provided series of bytes with program account data at a particular offset.\"\"\" offset : int \"\"\"Offset into program account data to start comparison: <usize>.\"\"\" bytes : str \"\"\"Data to match, as base-58 encoded string: <string>.\"\"\" bytes : str Data to match, as base-58 encoded string: . offset : int Offset into program account data to start comparison: . __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in solana/rpc/types.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , offset , bytes ) special staticmethod Create new instance of MemcmpOpts(offset, bytes) __repr__ ( self ) special Return a nicely formatted representation string Source code in solana/rpc/types.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self RPCError ( dict ) RPC error. Source code in solana/rpc/types.py class RPCError ( TypedDict ): \"\"\"RPC error.\"\"\" code : int \"\"\"HTTP status code.\"\"\" message : str \"\"\"Error message.\"\"\" TokenAccountOpts ( tuple ) Options when querying token accounts. Provide one of mint or program_id. Source code in solana/rpc/types.py class TokenAccountOpts ( NamedTuple ): \"\"\"Options when querying token accounts. Provide one of mint or program_id. \"\"\" mint : Optional [ Pubkey ] = None \"\"\"Public key of the specific token Mint to limit accounts to.\"\"\" program_id : Optional [ Pubkey ] = None \"\"\"Public key of the Token program ID that owns the accounts.\"\"\" encoding : str = \"base64\" \"\"\"Encoding for Account data, either \"base58\" (slow) or \"base64\".\"\"\" data_slice : Optional [ DataSliceOpts ] = None \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" data_slice : Optional [ solana . rpc . types . DataSliceOpts ] Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. encoding : str Encoding for Account data, either \"base58\" (slow) or \"base64\". mint : Optional [ solders . pubkey . Pubkey ] Public key of the specific token Mint to limit accounts to. program_id : Optional [ solders . pubkey . Pubkey ] Public key of the Token program ID that owns the accounts. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in solana/rpc/types.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , mint = None , program_id = None , encoding = 'base64' , data_slice = None ) special staticmethod Create new instance of TokenAccountOpts(mint, program_id, encoding, data_slice) __repr__ ( self ) special Return a nicely formatted representation string Source code in solana/rpc/types.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self TxOpts ( tuple ) Options to specify when broadcasting a transaction. Source code in solana/rpc/types.py class TxOpts ( NamedTuple ): \"\"\"Options to specify when broadcasting a transaction.\"\"\" skip_confirmation : bool = True \"\"\"If false, `send_transaction` will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, `send_transaction` will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. \"\"\" skip_preflight : bool = False \"\"\"If true, skip the preflight transaction checks.\"\"\" preflight_commitment : Commitment = Finalized \"\"\"Commitment level to use for preflight.\"\"\" max_retries : Optional [ int ] = None \"\"\"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. \"\"\" last_valid_block_height : Optional [ int ] = None \"\"\"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. \"\"\" last_valid_block_height : Optional [ int ] Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. max_retries : Optional [ int ] Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. preflight_commitment : < function NewType .< locals >. new_type at 0x7fe95e2f4160 > Commitment level to use for preflight. skip_confirmation : bool If false, send_transaction will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, send_transaction will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. skip_preflight : bool If true, skip the preflight transaction checks. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in solana/rpc/types.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , skip_confirmation = True , skip_preflight = False , preflight_commitment = 'finalized' , max_retries = None , last_valid_block_height = None ) special staticmethod Create new instance of TxOpts(skip_confirmation, skip_preflight, preflight_commitment, max_retries, last_valid_block_height) __repr__ ( self ) special Return a nicely formatted representation string Source code in solana/rpc/types.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"RPC Types"},{"location":"rpc/types/#rpc-types","text":"RPC types.","title":"RPC Types"},{"location":"rpc/types/#solana.rpc.types.RPCMethod","text":"Type for RPC method.","title":"RPCMethod"},{"location":"rpc/types/#solana.rpc.types.URI","text":"Type for endpoint URI.","title":"URI"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts","text":"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. Source code in solana/rpc/types.py class DataSliceOpts ( NamedTuple ): \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" offset : int \"\"\"Limit the returned account data using the provided offset: <usize>.\"\"\" length : int \"\"\"Limit the returned account data using the provided length: <usize>.\"\"\"","title":"DataSliceOpts"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.length","text":"Limit the returned account data using the provided length: .","title":"length"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.offset","text":"Limit the returned account data using the provided offset: .","title":"offset"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in solana/rpc/types.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.__new__","text":"Create new instance of DataSliceOpts(offset, length)","title":"__new__()"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.__repr__","text":"Return a nicely formatted representation string Source code in solana/rpc/types.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts","text":"Option to compare a provided series of bytes with program account data at a particular offset. Source code in solana/rpc/types.py class MemcmpOpts ( NamedTuple ): \"\"\"Option to compare a provided series of bytes with program account data at a particular offset.\"\"\" offset : int \"\"\"Offset into program account data to start comparison: <usize>.\"\"\" bytes : str \"\"\"Data to match, as base-58 encoded string: <string>.\"\"\"","title":"MemcmpOpts"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.bytes","text":"Data to match, as base-58 encoded string: .","title":"bytes"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.offset","text":"Offset into program account data to start comparison: .","title":"offset"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in solana/rpc/types.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.__new__","text":"Create new instance of MemcmpOpts(offset, bytes)","title":"__new__()"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.__repr__","text":"Return a nicely formatted representation string Source code in solana/rpc/types.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"rpc/types/#solana.rpc.types.RPCError","text":"RPC error. Source code in solana/rpc/types.py class RPCError ( TypedDict ): \"\"\"RPC error.\"\"\" code : int \"\"\"HTTP status code.\"\"\" message : str \"\"\"Error message.\"\"\"","title":"RPCError"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts","text":"Options when querying token accounts. Provide one of mint or program_id. Source code in solana/rpc/types.py class TokenAccountOpts ( NamedTuple ): \"\"\"Options when querying token accounts. Provide one of mint or program_id. \"\"\" mint : Optional [ Pubkey ] = None \"\"\"Public key of the specific token Mint to limit accounts to.\"\"\" program_id : Optional [ Pubkey ] = None \"\"\"Public key of the Token program ID that owns the accounts.\"\"\" encoding : str = \"base64\" \"\"\"Encoding for Account data, either \"base58\" (slow) or \"base64\".\"\"\" data_slice : Optional [ DataSliceOpts ] = None \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\"","title":"TokenAccountOpts"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.data_slice","text":"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.","title":"data_slice"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.encoding","text":"Encoding for Account data, either \"base58\" (slow) or \"base64\".","title":"encoding"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.mint","text":"Public key of the specific token Mint to limit accounts to.","title":"mint"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.program_id","text":"Public key of the Token program ID that owns the accounts.","title":"program_id"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in solana/rpc/types.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.__new__","text":"Create new instance of TokenAccountOpts(mint, program_id, encoding, data_slice)","title":"__new__()"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.__repr__","text":"Return a nicely formatted representation string Source code in solana/rpc/types.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"rpc/types/#solana.rpc.types.TxOpts","text":"Options to specify when broadcasting a transaction. Source code in solana/rpc/types.py class TxOpts ( NamedTuple ): \"\"\"Options to specify when broadcasting a transaction.\"\"\" skip_confirmation : bool = True \"\"\"If false, `send_transaction` will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, `send_transaction` will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. \"\"\" skip_preflight : bool = False \"\"\"If true, skip the preflight transaction checks.\"\"\" preflight_commitment : Commitment = Finalized \"\"\"Commitment level to use for preflight.\"\"\" max_retries : Optional [ int ] = None \"\"\"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. \"\"\" last_valid_block_height : Optional [ int ] = None \"\"\"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. \"\"\"","title":"TxOpts"},{"location":"rpc/types/#solana.rpc.types.TxOpts.last_valid_block_height","text":"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False.","title":"last_valid_block_height"},{"location":"rpc/types/#solana.rpc.types.TxOpts.max_retries","text":"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires.","title":"max_retries"},{"location":"rpc/types/#solana.rpc.types.TxOpts.preflight_commitment","text":"Commitment level to use for preflight.","title":"preflight_commitment"},{"location":"rpc/types/#solana.rpc.types.TxOpts.skip_confirmation","text":"If false, send_transaction will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, send_transaction will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous.","title":"skip_confirmation"},{"location":"rpc/types/#solana.rpc.types.TxOpts.skip_preflight","text":"If true, skip the preflight transaction checks.","title":"skip_preflight"},{"location":"rpc/types/#solana.rpc.types.TxOpts.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in solana/rpc/types.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"rpc/types/#solana.rpc.types.TxOpts.__new__","text":"Create new instance of TxOpts(skip_confirmation, skip_preflight, preflight_commitment, max_retries, last_valid_block_height)","title":"__new__()"},{"location":"rpc/types/#solana.rpc.types.TxOpts.__repr__","text":"Return a nicely formatted representation string Source code in solana/rpc/types.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"rpc/websocket/","text":"Websocket Client This module contains code for interacting with the RPC Websocket endpoint. SolanaWsClientProtocol ( WebSocketClientProtocol ) Subclass of websockets.WebSocketClientProtocol tailored for Solana RPC websockets. Source code in solana/rpc/websocket_api.py class SolanaWsClientProtocol ( WebSocketClientProtocol ): \"\"\"Subclass of `websockets.WebSocketClientProtocol` tailored for Solana RPC websockets.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions : Dict [ int , Body ] = {} self . sent_subscriptions : Dict [ int , Body ] = {} self . failed_subscriptions = {} self . request_counter = itertools . count () def increment_counter_and_get_id ( self ) -> int : \"\"\"Increment self.request_counter and return the latest id.\"\"\" return next ( self . request_counter ) + 1 async def send_data ( self , message : Union [ Body , List [ Body ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" if isinstance ( message , list ): to_send = batch_to_json ( message ) for req in message : self . sent_subscriptions [ req . id ] = req else : to_send = message . to_json () self . sent_subscriptions [ message . id ] = message await super () . send ( to_send ) # type: ignore async def recv ( # type: ignore self , ) -> List [ Union [ Notification , SubscriptionResult ]]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () return self . _process_rpc_response ( cast ( str , data )) async def account_subscribe ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] config = ( None if commitment_to_use is None and encoding_to_use is None else RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use ) ) req = AccountSubscribe ( pubkey , config , req_id ) await self . send_data ( req ) async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = AccountUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def logs_subscribe ( self , filter_ : Union [ RpcTransactionLogsFilter , RpcTransactionLogsFilterMentions ] = RpcTransactionLogsFilter . All , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. commitment: The commitment level to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = RpcTransactionLogsConfig ( commitment_to_use ) req = LogsSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = LogsUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def block_subscribe ( self , filter_ : Union [ RpcBlockSubscribeFilter , RpcBlockSubscribeFilterMentions ] = RpcBlockSubscribeFilter . All , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , transaction_details : Union [ TransactionDetails , None ] = None , show_rewards : Optional [ bool ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> None : \"\"\"Subscribe to blocks. Args: filter_: filter criteria for the blocks. commitment: The commitment level to use. encoding: Encoding to use. transaction_details: level of transaction detail to return. show_rewards: whether to populate the rewards array. max_supported_transaction_version: the max transaction version to return in responses. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _TX_ENCODING_TO_SOLDERS [ encoding ] config = RpcBlockSubscribeConfig ( commitment = commitment_to_use , encoding = encoding_to_use , transaction_details = transaction_details , show_rewards = show_rewards , max_supported_transaction_version = max_supported_transaction_version , ) req = BlockSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) async def block_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from blocks. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = BlockUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" # noqa: E501 # pylint: disable=line-too-long req_id = self . increment_counter_and_get_id () if commitment is None and encoding is None and data_slice is None and filters is None : config = None else : encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] data_slice_to_use = ( None if data_slice is None else UiDataSliceConfig ( offset = data_slice . offset , length = data_slice . length ) ) account_config = RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use , data_slice = data_slice_to_use , ) filters_to_use : Optional [ List [ Union [ int , Memcmp ]]] = ( None if filters is None else [ x if isinstance ( x , int ) else Memcmp ( * x ) for x in filters ] ) config = RpcProgramAccountsConfig ( account_config , filters_to_use ) req = ProgramSubscribe ( program_id , config , req_id ) await self . send_data ( req ) async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = ProgramUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def signature_subscribe ( self , signature : Signature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = None if commitment_to_use is None else RpcSignatureSubscribeConfig ( commitment = commitment_to_use ) req = SignatureSubscribe ( signature , config , req_id ) await self . send_data ( req ) async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SignatureUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotSubscribe ( req_id ) await self . send_data ( req ) async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesSubscribe ( req_id ) await self . send_data ( req ) async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = RootSubscribe ( req_id ) await self . send_data ( req ) async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = RootUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req_id = self . increment_counter_and_get_id () req = VoteSubscribe ( req_id ) await self . send_data ( req ) async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = VoteUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] def _process_rpc_response ( self , raw : str ) -> List [ Union [ Notification , SubscriptionResult ]]: parsed = parse_websocket_message ( raw ) for item in parsed : if isinstance ( item , SoldersSubscriptionError ): subscription = self . sent_subscriptions [ item . id ] self . failed_subscriptions [ item . id ] = subscription raise SubscriptionError ( item , subscription ) if isinstance ( item , SubscriptionResult ): self . subscriptions [ item . result ] = self . sent_subscriptions [ item . id ] return cast ( List [ Union [ Notification , SubscriptionResult ]], parsed ) __init__ ( self , * args , ** kwargs ) special Init. Args and kwargs are passed to websockets.WebSocketClientProtocol . Source code in solana/rpc/websocket_api.py def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions : Dict [ int , Body ] = {} self . sent_subscriptions : Dict [ int , Body ] = {} self . failed_subscriptions = {} self . request_counter = itertools . count () account_subscribe ( self , pubkey , commitment = None , encoding = None ) async Subscribe to an account to receive notifications when the lamports or data change. Parameters: Name Type Description Default pubkey Pubkey Account pubkey. required commitment Optional[Commitment] Commitment level. None encoding Optional[str] Encoding to use. None Source code in solana/rpc/websocket_api.py async def account_subscribe ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] config = ( None if commitment_to_use is None and encoding_to_use is None else RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use ) ) req = AccountSubscribe ( pubkey , config , req_id ) await self . send_data ( req ) account_unsubscribe ( self , subscription ) async Unsubscribe from account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = AccountUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] block_subscribe ( self , filter_ = RpcBlockSubscribeFilter . All , commitment = None , encoding = None , transaction_details = None , show_rewards = None , max_supported_transaction_version = None ) async Subscribe to blocks. Parameters: Name Type Description Default filter_ Union[solders.rpc.config.RpcBlockSubscribeFilter, solders.rpc.config.RpcBlockSubscribeFilterMentions] filter criteria for the blocks. RpcBlockSubscribeFilter.All commitment Optional[Commitment] The commitment level to use. None encoding Optional[str] Encoding to use. None transaction_details Optional[solders.transaction_status.TransactionDetails] level of transaction detail to return. None show_rewards Optional[bool] whether to populate the rewards array. None max_supported_transaction_version Optional[int] the max transaction version to return in responses. None Source code in solana/rpc/websocket_api.py async def block_subscribe ( self , filter_ : Union [ RpcBlockSubscribeFilter , RpcBlockSubscribeFilterMentions ] = RpcBlockSubscribeFilter . All , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , transaction_details : Union [ TransactionDetails , None ] = None , show_rewards : Optional [ bool ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> None : \"\"\"Subscribe to blocks. Args: filter_: filter criteria for the blocks. commitment: The commitment level to use. encoding: Encoding to use. transaction_details: level of transaction detail to return. show_rewards: whether to populate the rewards array. max_supported_transaction_version: the max transaction version to return in responses. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _TX_ENCODING_TO_SOLDERS [ encoding ] config = RpcBlockSubscribeConfig ( commitment = commitment_to_use , encoding = encoding_to_use , transaction_details = transaction_details , show_rewards = show_rewards , max_supported_transaction_version = max_supported_transaction_version , ) req = BlockSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) block_unsubscribe ( self , subscription ) async Unsubscribe from blocks. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def block_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from blocks. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = BlockUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] increment_counter_and_get_id ( self ) Increment self.request_counter and return the latest id. Source code in solana/rpc/websocket_api.py def increment_counter_and_get_id ( self ) -> int : \"\"\"Increment self.request_counter and return the latest id.\"\"\" return next ( self . request_counter ) + 1 logs_subscribe ( self , filter_ = RpcTransactionLogsFilter . All , commitment = None ) async Subscribe to transaction logging. Parameters: Name Type Description Default filter_ Union[solders.rpc.config.RpcTransactionLogsFilter, solders.rpc.config.RpcTransactionLogsFilterMentions] filter criteria for the logs. RpcTransactionLogsFilter.All commitment Optional[Commitment] The commitment level to use. None Source code in solana/rpc/websocket_api.py async def logs_subscribe ( self , filter_ : Union [ RpcTransactionLogsFilter , RpcTransactionLogsFilterMentions ] = RpcTransactionLogsFilter . All , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. commitment: The commitment level to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = RpcTransactionLogsConfig ( commitment_to_use ) req = LogsSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) logs_unsubscribe ( self , subscription ) async Unsubscribe from transaction logging. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = LogsUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] program_subscribe ( self , program_id , commitment = None , encoding = None , data_slice = None , filters = None ) async Receive notifications when the lamports or data for a given account owned by the program changes. Parameters: Name Type Description Default program_id Pubkey The program ID. required commitment Optional[Commitment] Commitment level to use. None encoding Optional[str] Encoding to use. None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Source code in solana/rpc/websocket_api.py async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" # noqa: E501 # pylint: disable=line-too-long req_id = self . increment_counter_and_get_id () if commitment is None and encoding is None and data_slice is None and filters is None : config = None else : encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] data_slice_to_use = ( None if data_slice is None else UiDataSliceConfig ( offset = data_slice . offset , length = data_slice . length ) ) account_config = RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use , data_slice = data_slice_to_use , ) filters_to_use : Optional [ List [ Union [ int , Memcmp ]]] = ( None if filters is None else [ x if isinstance ( x , int ) else Memcmp ( * x ) for x in filters ] ) config = RpcProgramAccountsConfig ( account_config , filters_to_use ) req = ProgramSubscribe ( program_id , config , req_id ) await self . send_data ( req ) program_unsubscribe ( self , subscription ) async Unsubscribe from program account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = ProgramUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] recv ( self ) async Receive the next message. Basically .recv from websockets with extra parsing. Source code in solana/rpc/websocket_api.py async def recv ( # type: ignore self , ) -> List [ Union [ Notification , SubscriptionResult ]]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () return self . _process_rpc_response ( cast ( str , data )) root_subscribe ( self ) async Subscribe to receive notification anytime a new root is set by the validator. Source code in solana/rpc/websocket_api.py async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = RootSubscribe ( req_id ) await self . send_data ( req ) root_unsubscribe ( self , subscription ) async Unsubscribe from root notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = RootUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] send_data ( self , message ) async Send a subscribe/unsubscribe request or list of requests. Basically .send from websockets with extra parsing. Parameters: Name Type Description Default message Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe, List[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe]]] The request(s) to send. required Source code in solana/rpc/websocket_api.py async def send_data ( self , message : Union [ Body , List [ Body ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" if isinstance ( message , list ): to_send = batch_to_json ( message ) for req in message : self . sent_subscriptions [ req . id ] = req else : to_send = message . to_json () self . sent_subscriptions [ message . id ] = message await super () . send ( to_send ) # type: ignore signature_subscribe ( self , signature , commitment = None ) async Subscribe to a transaction signature to receive notification when the transaction is confirmed. Parameters: Name Type Description Default signature Signature The transaction signature to subscribe to. required commitment Optional[Commitment] Commitment level. None Source code in solana/rpc/websocket_api.py async def signature_subscribe ( self , signature : Signature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = None if commitment_to_use is None else RpcSignatureSubscribeConfig ( commitment = commitment_to_use ) req = SignatureSubscribe ( signature , config , req_id ) await self . send_data ( req ) signature_unsubscribe ( self , subscription ) async Unsubscribe from signature notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SignatureUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] slot_subscribe ( self ) async Subscribe to receive notification anytime a slot is processed by the validator. Source code in solana/rpc/websocket_api.py async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotSubscribe ( req_id ) await self . send_data ( req ) slot_unsubscribe ( self , subscription ) async Unsubscribe from slot notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] slots_updates_subscribe ( self ) async Subscribe to receive a notification from the validator on a variety of updates on every slot. Source code in solana/rpc/websocket_api.py async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesSubscribe ( req_id ) await self . send_data ( req ) slots_updates_unsubscribe ( self , subscription ) async Unsubscribe from slot update notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] vote_subscribe ( self ) async Subscribe to receive notification anytime a new vote is observed in gossip. Source code in solana/rpc/websocket_api.py async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req_id = self . increment_counter_and_get_id () req = VoteSubscribe ( req_id ) await self . send_data ( req ) vote_unsubscribe ( self , subscription ) async Unsubscribe from vote notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = VoteUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] SubscriptionError ( Exception ) Raise when subscribing to an RPC feed fails. Source code in solana/rpc/websocket_api.py class SubscriptionError ( Exception ): \"\"\"Raise when subscribing to an RPC feed fails.\"\"\" def __init__ ( self , err : SoldersSubscriptionError , subscription : Body ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . type = err . error . __class__ self . msg : str = err . error . message # type: ignore # TODO: narrow this union type self . subscription = subscription super () . __init__ ( f \" { self . type . __name__ } : { self . msg } \\n Caused by subscription: { subscription } \" ) __init__ ( self , err , subscription ) special Init. Parameters: Name Type Description Default err SubscriptionError The RPC error object. required subscription Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe] The subscription message that caused the error. required Source code in solana/rpc/websocket_api.py def __init__ ( self , err : SoldersSubscriptionError , subscription : Body ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . type = err . error . __class__ self . msg : str = err . error . message # type: ignore # TODO: narrow this union type self . subscription = subscription super () . __init__ ( f \" { self . type . __name__ } : { self . msg } \\n Caused by subscription: { subscription } \" ) connect ( Connect ) Solana RPC websocket connector. Source code in solana/rpc/websocket_api.py class connect ( ws_connect ): # pylint: disable=invalid-name,too-few-public-methods \"\"\"Solana RPC websocket connector.\"\"\" def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. **kwargs: Keyword arguments for ``websockets.legacy.client.connect`` \"\"\" # Ensure that create_protocol explicitly creates a SolanaWsClientProtocol kwargs . setdefault ( \"create_protocol\" , SolanaWsClientProtocol ) super () . __init__ ( uri , ** kwargs ) async def __aenter__ ( self ) -> SolanaWsClientProtocol : \"\"\"Overrides to specify the type of protocol explicitly.\"\"\" protocol = await super () . __aenter__ () return cast ( SolanaWsClientProtocol , protocol ) __aenter__ ( self ) async special Overrides to specify the type of protocol explicitly. Source code in solana/rpc/websocket_api.py async def __aenter__ ( self ) -> SolanaWsClientProtocol : \"\"\"Overrides to specify the type of protocol explicitly.\"\"\" protocol = await super () . __aenter__ () return cast ( SolanaWsClientProtocol , protocol ) __init__ ( self , uri = 'ws://localhost:8900' , ** kwargs ) special Init. Kwargs are passed to websockets.connect . Parameters: Name Type Description Default uri str The websocket endpoint. 'ws://localhost:8900' **kwargs Any Keyword arguments for websockets.legacy.client.connect {} Source code in solana/rpc/websocket_api.py def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. **kwargs: Keyword arguments for ``websockets.legacy.client.connect`` \"\"\" # Ensure that create_protocol explicitly creates a SolanaWsClientProtocol kwargs . setdefault ( \"create_protocol\" , SolanaWsClientProtocol ) super () . __init__ ( uri , ** kwargs )","title":"Websocket Client"},{"location":"rpc/websocket/#websocket-client","text":"This module contains code for interacting with the RPC Websocket endpoint.","title":"Websocket Client"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol","text":"Subclass of websockets.WebSocketClientProtocol tailored for Solana RPC websockets. Source code in solana/rpc/websocket_api.py class SolanaWsClientProtocol ( WebSocketClientProtocol ): \"\"\"Subclass of `websockets.WebSocketClientProtocol` tailored for Solana RPC websockets.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions : Dict [ int , Body ] = {} self . sent_subscriptions : Dict [ int , Body ] = {} self . failed_subscriptions = {} self . request_counter = itertools . count () def increment_counter_and_get_id ( self ) -> int : \"\"\"Increment self.request_counter and return the latest id.\"\"\" return next ( self . request_counter ) + 1 async def send_data ( self , message : Union [ Body , List [ Body ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" if isinstance ( message , list ): to_send = batch_to_json ( message ) for req in message : self . sent_subscriptions [ req . id ] = req else : to_send = message . to_json () self . sent_subscriptions [ message . id ] = message await super () . send ( to_send ) # type: ignore async def recv ( # type: ignore self , ) -> List [ Union [ Notification , SubscriptionResult ]]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () return self . _process_rpc_response ( cast ( str , data )) async def account_subscribe ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] config = ( None if commitment_to_use is None and encoding_to_use is None else RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use ) ) req = AccountSubscribe ( pubkey , config , req_id ) await self . send_data ( req ) async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = AccountUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def logs_subscribe ( self , filter_ : Union [ RpcTransactionLogsFilter , RpcTransactionLogsFilterMentions ] = RpcTransactionLogsFilter . All , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. commitment: The commitment level to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = RpcTransactionLogsConfig ( commitment_to_use ) req = LogsSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = LogsUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def block_subscribe ( self , filter_ : Union [ RpcBlockSubscribeFilter , RpcBlockSubscribeFilterMentions ] = RpcBlockSubscribeFilter . All , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , transaction_details : Union [ TransactionDetails , None ] = None , show_rewards : Optional [ bool ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> None : \"\"\"Subscribe to blocks. Args: filter_: filter criteria for the blocks. commitment: The commitment level to use. encoding: Encoding to use. transaction_details: level of transaction detail to return. show_rewards: whether to populate the rewards array. max_supported_transaction_version: the max transaction version to return in responses. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _TX_ENCODING_TO_SOLDERS [ encoding ] config = RpcBlockSubscribeConfig ( commitment = commitment_to_use , encoding = encoding_to_use , transaction_details = transaction_details , show_rewards = show_rewards , max_supported_transaction_version = max_supported_transaction_version , ) req = BlockSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) async def block_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from blocks. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = BlockUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" # noqa: E501 # pylint: disable=line-too-long req_id = self . increment_counter_and_get_id () if commitment is None and encoding is None and data_slice is None and filters is None : config = None else : encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] data_slice_to_use = ( None if data_slice is None else UiDataSliceConfig ( offset = data_slice . offset , length = data_slice . length ) ) account_config = RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use , data_slice = data_slice_to_use , ) filters_to_use : Optional [ List [ Union [ int , Memcmp ]]] = ( None if filters is None else [ x if isinstance ( x , int ) else Memcmp ( * x ) for x in filters ] ) config = RpcProgramAccountsConfig ( account_config , filters_to_use ) req = ProgramSubscribe ( program_id , config , req_id ) await self . send_data ( req ) async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = ProgramUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def signature_subscribe ( self , signature : Signature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = None if commitment_to_use is None else RpcSignatureSubscribeConfig ( commitment = commitment_to_use ) req = SignatureSubscribe ( signature , config , req_id ) await self . send_data ( req ) async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SignatureUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotSubscribe ( req_id ) await self . send_data ( req ) async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesSubscribe ( req_id ) await self . send_data ( req ) async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = RootSubscribe ( req_id ) await self . send_data ( req ) async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = RootUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req_id = self . increment_counter_and_get_id () req = VoteSubscribe ( req_id ) await self . send_data ( req ) async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = VoteUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] def _process_rpc_response ( self , raw : str ) -> List [ Union [ Notification , SubscriptionResult ]]: parsed = parse_websocket_message ( raw ) for item in parsed : if isinstance ( item , SoldersSubscriptionError ): subscription = self . sent_subscriptions [ item . id ] self . failed_subscriptions [ item . id ] = subscription raise SubscriptionError ( item , subscription ) if isinstance ( item , SubscriptionResult ): self . subscriptions [ item . result ] = self . sent_subscriptions [ item . id ] return cast ( List [ Union [ Notification , SubscriptionResult ]], parsed )","title":"SolanaWsClientProtocol"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.__init__","text":"Init. Args and kwargs are passed to websockets.WebSocketClientProtocol . Source code in solana/rpc/websocket_api.py def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions : Dict [ int , Body ] = {} self . sent_subscriptions : Dict [ int , Body ] = {} self . failed_subscriptions = {} self . request_counter = itertools . count ()","title":"__init__()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.account_subscribe","text":"Subscribe to an account to receive notifications when the lamports or data change. Parameters: Name Type Description Default pubkey Pubkey Account pubkey. required commitment Optional[Commitment] Commitment level. None encoding Optional[str] Encoding to use. None Source code in solana/rpc/websocket_api.py async def account_subscribe ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] config = ( None if commitment_to_use is None and encoding_to_use is None else RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use ) ) req = AccountSubscribe ( pubkey , config , req_id ) await self . send_data ( req )","title":"account_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.account_unsubscribe","text":"Unsubscribe from account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = AccountUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"account_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.block_subscribe","text":"Subscribe to blocks. Parameters: Name Type Description Default filter_ Union[solders.rpc.config.RpcBlockSubscribeFilter, solders.rpc.config.RpcBlockSubscribeFilterMentions] filter criteria for the blocks. RpcBlockSubscribeFilter.All commitment Optional[Commitment] The commitment level to use. None encoding Optional[str] Encoding to use. None transaction_details Optional[solders.transaction_status.TransactionDetails] level of transaction detail to return. None show_rewards Optional[bool] whether to populate the rewards array. None max_supported_transaction_version Optional[int] the max transaction version to return in responses. None Source code in solana/rpc/websocket_api.py async def block_subscribe ( self , filter_ : Union [ RpcBlockSubscribeFilter , RpcBlockSubscribeFilterMentions ] = RpcBlockSubscribeFilter . All , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , transaction_details : Union [ TransactionDetails , None ] = None , show_rewards : Optional [ bool ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> None : \"\"\"Subscribe to blocks. Args: filter_: filter criteria for the blocks. commitment: The commitment level to use. encoding: Encoding to use. transaction_details: level of transaction detail to return. show_rewards: whether to populate the rewards array. max_supported_transaction_version: the max transaction version to return in responses. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _TX_ENCODING_TO_SOLDERS [ encoding ] config = RpcBlockSubscribeConfig ( commitment = commitment_to_use , encoding = encoding_to_use , transaction_details = transaction_details , show_rewards = show_rewards , max_supported_transaction_version = max_supported_transaction_version , ) req = BlockSubscribe ( filter_ , config , req_id ) await self . send_data ( req )","title":"block_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.block_unsubscribe","text":"Unsubscribe from blocks. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def block_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from blocks. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = BlockUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"block_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.increment_counter_and_get_id","text":"Increment self.request_counter and return the latest id. Source code in solana/rpc/websocket_api.py def increment_counter_and_get_id ( self ) -> int : \"\"\"Increment self.request_counter and return the latest id.\"\"\" return next ( self . request_counter ) + 1","title":"increment_counter_and_get_id()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.logs_subscribe","text":"Subscribe to transaction logging. Parameters: Name Type Description Default filter_ Union[solders.rpc.config.RpcTransactionLogsFilter, solders.rpc.config.RpcTransactionLogsFilterMentions] filter criteria for the logs. RpcTransactionLogsFilter.All commitment Optional[Commitment] The commitment level to use. None Source code in solana/rpc/websocket_api.py async def logs_subscribe ( self , filter_ : Union [ RpcTransactionLogsFilter , RpcTransactionLogsFilterMentions ] = RpcTransactionLogsFilter . All , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. commitment: The commitment level to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = RpcTransactionLogsConfig ( commitment_to_use ) req = LogsSubscribe ( filter_ , config , req_id ) await self . send_data ( req )","title":"logs_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.logs_unsubscribe","text":"Unsubscribe from transaction logging. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = LogsUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"logs_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.program_subscribe","text":"Receive notifications when the lamports or data for a given account owned by the program changes. Parameters: Name Type Description Default program_id Pubkey The program ID. required commitment Optional[Commitment] Commitment level to use. None encoding Optional[str] Encoding to use. None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Source code in solana/rpc/websocket_api.py async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" # noqa: E501 # pylint: disable=line-too-long req_id = self . increment_counter_and_get_id () if commitment is None and encoding is None and data_slice is None and filters is None : config = None else : encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] data_slice_to_use = ( None if data_slice is None else UiDataSliceConfig ( offset = data_slice . offset , length = data_slice . length ) ) account_config = RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use , data_slice = data_slice_to_use , ) filters_to_use : Optional [ List [ Union [ int , Memcmp ]]] = ( None if filters is None else [ x if isinstance ( x , int ) else Memcmp ( * x ) for x in filters ] ) config = RpcProgramAccountsConfig ( account_config , filters_to_use ) req = ProgramSubscribe ( program_id , config , req_id ) await self . send_data ( req )","title":"program_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.program_unsubscribe","text":"Unsubscribe from program account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = ProgramUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"program_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.recv","text":"Receive the next message. Basically .recv from websockets with extra parsing. Source code in solana/rpc/websocket_api.py async def recv ( # type: ignore self , ) -> List [ Union [ Notification , SubscriptionResult ]]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () return self . _process_rpc_response ( cast ( str , data ))","title":"recv()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.root_subscribe","text":"Subscribe to receive notification anytime a new root is set by the validator. Source code in solana/rpc/websocket_api.py async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = RootSubscribe ( req_id ) await self . send_data ( req )","title":"root_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.root_unsubscribe","text":"Unsubscribe from root notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = RootUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"root_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.send_data","text":"Send a subscribe/unsubscribe request or list of requests. Basically .send from websockets with extra parsing. Parameters: Name Type Description Default message Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe, List[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe]]] The request(s) to send. required Source code in solana/rpc/websocket_api.py async def send_data ( self , message : Union [ Body , List [ Body ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" if isinstance ( message , list ): to_send = batch_to_json ( message ) for req in message : self . sent_subscriptions [ req . id ] = req else : to_send = message . to_json () self . sent_subscriptions [ message . id ] = message await super () . send ( to_send ) # type: ignore","title":"send_data()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.signature_subscribe","text":"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Parameters: Name Type Description Default signature Signature The transaction signature to subscribe to. required commitment Optional[Commitment] Commitment level. None Source code in solana/rpc/websocket_api.py async def signature_subscribe ( self , signature : Signature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = None if commitment_to_use is None else RpcSignatureSubscribeConfig ( commitment = commitment_to_use ) req = SignatureSubscribe ( signature , config , req_id ) await self . send_data ( req )","title":"signature_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.signature_unsubscribe","text":"Unsubscribe from signature notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SignatureUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"signature_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slot_subscribe","text":"Subscribe to receive notification anytime a slot is processed by the validator. Source code in solana/rpc/websocket_api.py async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotSubscribe ( req_id ) await self . send_data ( req )","title":"slot_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slot_unsubscribe","text":"Unsubscribe from slot notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"slot_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slots_updates_subscribe","text":"Subscribe to receive a notification from the validator on a variety of updates on every slot. Source code in solana/rpc/websocket_api.py async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesSubscribe ( req_id ) await self . send_data ( req )","title":"slots_updates_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slots_updates_unsubscribe","text":"Unsubscribe from slot update notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"slots_updates_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.vote_subscribe","text":"Subscribe to receive notification anytime a new vote is observed in gossip. Source code in solana/rpc/websocket_api.py async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req_id = self . increment_counter_and_get_id () req = VoteSubscribe ( req_id ) await self . send_data ( req )","title":"vote_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.vote_unsubscribe","text":"Unsubscribe from vote notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = VoteUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"vote_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SubscriptionError","text":"Raise when subscribing to an RPC feed fails. Source code in solana/rpc/websocket_api.py class SubscriptionError ( Exception ): \"\"\"Raise when subscribing to an RPC feed fails.\"\"\" def __init__ ( self , err : SoldersSubscriptionError , subscription : Body ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . type = err . error . __class__ self . msg : str = err . error . message # type: ignore # TODO: narrow this union type self . subscription = subscription super () . __init__ ( f \" { self . type . __name__ } : { self . msg } \\n Caused by subscription: { subscription } \" )","title":"SubscriptionError"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SubscriptionError.__init__","text":"Init. Parameters: Name Type Description Default err SubscriptionError The RPC error object. required subscription Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendVersionedTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SimulateVersionedTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe] The subscription message that caused the error. required Source code in solana/rpc/websocket_api.py def __init__ ( self , err : SoldersSubscriptionError , subscription : Body ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . type = err . error . __class__ self . msg : str = err . error . message # type: ignore # TODO: narrow this union type self . subscription = subscription super () . __init__ ( f \" { self . type . __name__ } : { self . msg } \\n Caused by subscription: { subscription } \" )","title":"__init__()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.connect","text":"Solana RPC websocket connector. Source code in solana/rpc/websocket_api.py class connect ( ws_connect ): # pylint: disable=invalid-name,too-few-public-methods \"\"\"Solana RPC websocket connector.\"\"\" def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. **kwargs: Keyword arguments for ``websockets.legacy.client.connect`` \"\"\" # Ensure that create_protocol explicitly creates a SolanaWsClientProtocol kwargs . setdefault ( \"create_protocol\" , SolanaWsClientProtocol ) super () . __init__ ( uri , ** kwargs ) async def __aenter__ ( self ) -> SolanaWsClientProtocol : \"\"\"Overrides to specify the type of protocol explicitly.\"\"\" protocol = await super () . __aenter__ () return cast ( SolanaWsClientProtocol , protocol )","title":"connect"},{"location":"rpc/websocket/#solana.rpc.websocket_api.connect.__aenter__","text":"Overrides to specify the type of protocol explicitly. Source code in solana/rpc/websocket_api.py async def __aenter__ ( self ) -> SolanaWsClientProtocol : \"\"\"Overrides to specify the type of protocol explicitly.\"\"\" protocol = await super () . __aenter__ () return cast ( SolanaWsClientProtocol , protocol )","title":"__aenter__()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.connect.__init__","text":"Init. Kwargs are passed to websockets.connect . Parameters: Name Type Description Default uri str The websocket endpoint. 'ws://localhost:8900' **kwargs Any Keyword arguments for websockets.legacy.client.connect {} Source code in solana/rpc/websocket_api.py def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. **kwargs: Keyword arguments for ``websockets.legacy.client.connect`` \"\"\" # Ensure that create_protocol explicitly creates a SolanaWsClientProtocol kwargs . setdefault ( \"create_protocol\" , SolanaWsClientProtocol ) super () . __init__ ( uri , ** kwargs )","title":"__init__()"},{"location":"spl/intro/","text":"Solana Program Library (SPL) The Solana Program Library (SPL) is a collection of on-chain programs targeting the Sealevel parallel runtime . These programs are tested against Solana's implementation of Sealevel, solana-runtime, and deployed to its mainnet. Note The Python SPL library is separate from the main Python Solana library, so you import it with import spl instead of import solana . You don't install it separately though: it gets installed when you run pip install solana .","title":"Solana Program Library (SPL)"},{"location":"spl/intro/#solana-program-library-spl","text":"The Solana Program Library (SPL) is a collection of on-chain programs targeting the Sealevel parallel runtime . These programs are tested against Solana's implementation of Sealevel, solana-runtime, and deployed to its mainnet. Note The Python SPL library is separate from the main Python Solana library, so you import it with import spl instead of import solana . You don't install it separately though: it gets installed when you run pip install solana .","title":"Solana Program Library (SPL)"},{"location":"spl/memo/constants/","text":"Constants Memo program constants. MEMO_PROGRAM_ID : Pubkey Public key that identifies the Memo program.","title":"Constants"},{"location":"spl/memo/constants/#constants","text":"Memo program constants.","title":"Constants"},{"location":"spl/memo/constants/#spl.memo.constants.MEMO_PROGRAM_ID","text":"Public key that identifies the Memo program.","title":"MEMO_PROGRAM_ID"},{"location":"spl/memo/instructions/","text":"Memo Program Memo program instructions. MemoParams ( tuple ) Create memo transaction params. Source code in spl/memo/instructions.py class MemoParams ( NamedTuple ): \"\"\"Create memo transaction params.\"\"\" program_id : Pubkey \"\"\"Memo program account.\"\"\" signer : Pubkey \"\"\"Signing account.\"\"\" message : bytes \"\"\"Memo message in bytes.\"\"\" message : bytes Memo message in bytes. program_id : Pubkey Memo program account. signer : Pubkey Signing account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/memo/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , signer , message ) special staticmethod Create new instance of MemoParams(program_id, signer, message) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/memo/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self create_memo ( params ) Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Examples: >>> from solders.pubkey import Pubkey >>> leading_zeros = [ 0 ] * 31 >>> signer , memo_program = Pubkey ( leading_zeros + [ 1 ]), Pubkey ( leading_zeros + [ 2 ]) >>> message = bytes ( \"test\" , encoding = \"utf8\" ) >>> params = MemoParams ( ... program_id = memo_program , ... message = message , ... signer = signer ... ) >>> type ( create_memo ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to create a memo. Source code in spl/memo/instructions.py def create_memo ( params : MemoParams ) -> Instruction : \"\"\"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Example: >>> from solders.pubkey import Pubkey >>> leading_zeros = [0] * 31 >>> signer, memo_program = Pubkey(leading_zeros + [1]), Pubkey(leading_zeros + [2]) >>> message = bytes(\"test\", encoding=\"utf8\") >>> params = MemoParams( ... program_id=memo_program, ... message=message, ... signer=signer ... ) >>> type(create_memo(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to create a memo. \"\"\" keys = [ AccountMeta ( pubkey = params . signer , is_signer = True , is_writable = True ), ] return Instruction ( accounts = keys , program_id = params . program_id , data = params . message , ) decode_create_memo ( instruction ) Decode a create_memo_instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MemoParams The decoded instruction. Source code in spl/memo/instructions.py def decode_create_memo ( instruction : Instruction ) -> MemoParams : \"\"\"Decode a create_memo_instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return MemoParams ( signer = instruction . accounts [ 0 ] . pubkey , message = instruction . data , program_id = instruction . program_id , )","title":"Memo Program"},{"location":"spl/memo/instructions/#memo-program","text":"Memo program instructions.","title":"Memo Program"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams","text":"Create memo transaction params. Source code in spl/memo/instructions.py class MemoParams ( NamedTuple ): \"\"\"Create memo transaction params.\"\"\" program_id : Pubkey \"\"\"Memo program account.\"\"\" signer : Pubkey \"\"\"Signing account.\"\"\" message : bytes \"\"\"Memo message in bytes.\"\"\"","title":"MemoParams"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.message","text":"Memo message in bytes.","title":"message"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.program_id","text":"Memo program account.","title":"program_id"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.signer","text":"Signing account.","title":"signer"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/memo/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.__new__","text":"Create new instance of MemoParams(program_id, signer, message)","title":"__new__()"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/memo/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/memo/instructions/#spl.memo.instructions.create_memo","text":"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Examples: >>> from solders.pubkey import Pubkey >>> leading_zeros = [ 0 ] * 31 >>> signer , memo_program = Pubkey ( leading_zeros + [ 1 ]), Pubkey ( leading_zeros + [ 2 ]) >>> message = bytes ( \"test\" , encoding = \"utf8\" ) >>> params = MemoParams ( ... program_id = memo_program , ... message = message , ... signer = signer ... ) >>> type ( create_memo ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to create a memo. Source code in spl/memo/instructions.py def create_memo ( params : MemoParams ) -> Instruction : \"\"\"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Example: >>> from solders.pubkey import Pubkey >>> leading_zeros = [0] * 31 >>> signer, memo_program = Pubkey(leading_zeros + [1]), Pubkey(leading_zeros + [2]) >>> message = bytes(\"test\", encoding=\"utf8\") >>> params = MemoParams( ... program_id=memo_program, ... message=message, ... signer=signer ... ) >>> type(create_memo(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to create a memo. \"\"\" keys = [ AccountMeta ( pubkey = params . signer , is_signer = True , is_writable = True ), ] return Instruction ( accounts = keys , program_id = params . program_id , data = params . message , )","title":"create_memo()"},{"location":"spl/memo/instructions/#spl.memo.instructions.decode_create_memo","text":"Decode a create_memo_instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MemoParams The decoded instruction. Source code in spl/memo/instructions.py def decode_create_memo ( instruction : Instruction ) -> MemoParams : \"\"\"Decode a create_memo_instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return MemoParams ( signer = instruction . accounts [ 0 ] . pubkey , message = instruction . data , program_id = instruction . program_id , )","title":"decode_create_memo()"},{"location":"spl/memo/intro/","text":"Intro The Memo program is a simple program that validates a string of UTF-8 encoded characters and verifies that any accounts provided are signers of the transaction. The program also logs the memo, as well as any verified signer addresses, to the transaction log, so that anyone can easily observe memos and know they were approved by zero or more addresses by inspecting the transaction log from a trusted provider. Background Solana's programming model and the definitions of the Solana terms used in this document are available at: https://docs.solana.com/apps https://docs.solana.com/terminology Source The Memo Program's source is available on github Interface The on-chain Memo Program is written in Rust and available on crates.io as spl-memo and docs.rs . The crate provides a build_memo() method to easily create a properly constructed Instruction. Operational Notes If zero accounts are provided to the signed-memo instruction, the program succeeds when the memo is valid UTF-8, and logs the memo to the transaction log. If one or more accounts are provided to the signed-memo instruction, all must be valid signers of the transaction for the instruction to succeed. Logs This section details expected log output for memo instructions. Logging begins with entry into the program: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1] The program will include a separate log for each verified signer: Program log: Signed by <BASE_58_ADDRESS> Then the program logs the memo length and UTF-8 text: Program log: Memo (len 4): \"\ud83d\udc06\" If UTF-8 parsing fails, the program will log the failure point: Program log: Invalid UTF-8, from byte 4 Logging ends with the status of the instruction, one of: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: missing required signature for instruction Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: invalid instruction data For more information about exposing program logs on a node, head to the developer docs Compute Limits Like all programs, the Memo Program is subject to the cluster's compute budget . In Memo, compute is used for parsing UTF-8, verifying signers, and logging, limiting the memo length and number of signers that can be processed successfully in a single instruction. The longer or more complex the UTF-8 memo, the fewer signers can be supported, and vice versa. As of v1.5.1, an unsigned instruction can support single-byte UTF-8 of up to 566 bytes. An instruction with a simple memo of 32 bytes can support up to 12 signers.","title":"Intro"},{"location":"spl/memo/intro/#intro","text":"The Memo program is a simple program that validates a string of UTF-8 encoded characters and verifies that any accounts provided are signers of the transaction. The program also logs the memo, as well as any verified signer addresses, to the transaction log, so that anyone can easily observe memos and know they were approved by zero or more addresses by inspecting the transaction log from a trusted provider.","title":"Intro"},{"location":"spl/memo/intro/#background","text":"Solana's programming model and the definitions of the Solana terms used in this document are available at: https://docs.solana.com/apps https://docs.solana.com/terminology","title":"Background"},{"location":"spl/memo/intro/#source","text":"The Memo Program's source is available on github","title":"Source"},{"location":"spl/memo/intro/#interface","text":"The on-chain Memo Program is written in Rust and available on crates.io as spl-memo and docs.rs . The crate provides a build_memo() method to easily create a properly constructed Instruction.","title":"Interface"},{"location":"spl/memo/intro/#operational-notes","text":"If zero accounts are provided to the signed-memo instruction, the program succeeds when the memo is valid UTF-8, and logs the memo to the transaction log. If one or more accounts are provided to the signed-memo instruction, all must be valid signers of the transaction for the instruction to succeed.","title":"Operational Notes"},{"location":"spl/memo/intro/#logs","text":"This section details expected log output for memo instructions. Logging begins with entry into the program: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1] The program will include a separate log for each verified signer: Program log: Signed by <BASE_58_ADDRESS> Then the program logs the memo length and UTF-8 text: Program log: Memo (len 4): \"\ud83d\udc06\" If UTF-8 parsing fails, the program will log the failure point: Program log: Invalid UTF-8, from byte 4 Logging ends with the status of the instruction, one of: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: missing required signature for instruction Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: invalid instruction data For more information about exposing program logs on a node, head to the developer docs","title":"Logs"},{"location":"spl/memo/intro/#compute-limits","text":"Like all programs, the Memo Program is subject to the cluster's compute budget . In Memo, compute is used for parsing UTF-8, verifying signers, and logging, limiting the memo length and number of signers that can be processed successfully in a single instruction. The longer or more complex the UTF-8 memo, the fewer signers can be supported, and vice versa. As of v1.5.1, an unsigned instruction can support single-byte UTF-8 of up to 566 bytes. An instruction with a simple memo of 32 bytes can support up to 12 signers.","title":"Compute Limits"},{"location":"spl/token/async_client/","text":"Async Client Async SPL Token program client. AsyncToken ( _TokenCore ) An ERC20-like Token. Source code in spl/token/async_client.py class AsyncToken ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : AsyncClient , pubkey : Pubkey , program_id : Pubkey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value async def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner ( * args ) async def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) async def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate ( * args ) async def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction recent_blockhash_to_use = ( ( await conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) token , txn , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , recent_blockhash_to_use , ) # Send the two instructions await conn . send_transaction ( txn , opts = opts ) return cast ( AsyncToken , token ) async def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) new_account_pk , txn , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment , recent_blockhash_to_use ) # Send the two instructions await self . _conn . send_transaction ( txn , opts = opts ) return new_account_pk async def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment , recent_blockhash_to_use , token_program_id = self . program_id ) await self . _conn . send_transaction ( txn , opts = opts ) return public_key @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) recent_blockhash_to_use = ( ( await conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) ( new_account_public_key , txn , payer , new_account , opts , ) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , recent_blockhash_to_use , ) await conn . send_transaction ( txn , opts = opts ) return new_account_public_key async def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed , recent_blockhash_to_use ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , opts = opts_to_use ) return multisig . pubkey () async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) async def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) async def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , recent_blockhash_to_use , ) return await self . _conn . send_transaction ( txn , opts = opts ) async def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def close_account ( self , account : Pubkey , dest : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def freeze_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def mint_to_checked ( self , dest : Pubkey , mint_authority : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def burn_checked ( self , account : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use , ) return await self . _conn . send_transaction ( txn , opts = opts ) approve ( self , source , delegate , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) approve_checked ( self , source , delegate , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) burn ( self , account , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Burn tokens. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) burn_checked ( self , account , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn_checked ( self , account : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use , ) return await self . _conn . send_transaction ( txn , opts = opts ) close_account ( self , account , dest , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account Pubkey Account to close. required dest Pubkey Account to receive the remaining balance of the closed account. required authority Pubkey Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def close_account ( self , account : Pubkey , dest : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) create_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) async Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner Pubkey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash optional A prefetched blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) new_account_pk , txn , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment , recent_blockhash_to_use ) # Send the two instructions await self . _conn . send_transaction ( txn , opts = opts ) return new_account_pk create_associated_token_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) async Create an associated token account. Parameters: Name Type Description Default owner Pubkey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash optional A prefetched blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment , recent_blockhash_to_use , token_program_id = self . program_id ) await self . _conn . send_transaction ( txn , opts = opts ) return public_key create_mint ( conn , payer , mint_authority , decimals , program_id , freeze_authority = None , skip_confirmation = False , recent_blockhash = None ) async classmethod Create and initialize a token. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority Pubkey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id Pubkey SPL Token program account. required freeze_authority Optional[Pubkey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description AsyncToken Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction recent_blockhash_to_use = ( ( await conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) token , txn , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , recent_blockhash_to_use , ) # Send the two instructions await conn . send_transaction ( txn , opts = opts ) return cast ( AsyncToken , token ) create_multisig ( self , m , multi_signers , opts = None , recent_blockhash = None ) async Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[Pubkey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new multisig account. Source code in spl/token/async_client.py async def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed , recent_blockhash_to_use ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , opts = opts_to_use ) return multisig . pubkey () create_wrapped_native_account ( conn , program_id , owner , payer , amount , skip_confirmation = False , recent_blockhash = None ) async staticmethod Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required program_id Pubkey SPL Token program account. required owner Pubkey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) recent_blockhash_to_use = ( ( await conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) ( new_account_public_key , txn , payer , new_account , opts , ) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , recent_blockhash_to_use , ) await conn . send_transaction ( txn , opts = opts ) return new_account_public_key freeze_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Freeze account. Parameters: Name Type Description Default account Pubkey Account to freeze. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def freeze_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) get_account_info ( self , account , commitment = None ) async Retrieve account information. Source code in spl/token/async_client.py async def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) get_accounts_by_delegate ( self , owner , commitment = None , encoding = 'base64' ) async Get token accounts of the provided delegate. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/async_client.py async def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate ( * args ) get_accounts_by_delegate_json_parsed ( self , owner , commitment = None , encoding = 'base64' ) async Get token accounts of the provided delegate, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) get_accounts_by_owner ( self , owner , commitment = None , encoding = 'base64' ) async Get token accounts of the provided owner. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/async_client.py async def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner ( * args ) get_accounts_by_owner_json_parsed ( self , owner , commitment = None ) async Get token accounts of the provided owner by the token's mint, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) get_balance ( self , pubkey , commitment = None ) async Get the balance of the provided token account. Parameters: Name Type Description Default pubkey Pubkey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/async_client.py async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) get_min_balance_rent_for_exempt_for_account ( conn ) async staticmethod Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value get_min_balance_rent_for_exempt_for_mint ( conn ) async staticmethod Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value get_min_balance_rent_for_exempt_for_multisig ( conn ) async staticmethod Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value get_mint_info ( self ) async Retrieve mint information. Source code in spl/token/async_client.py async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) mint_to ( self , dest , mint_authority , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Mint new tokens. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) mint_to_checked ( self , dest , mint_authority , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Pubkey Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def mint_to_checked ( self , dest : Pubkey , mint_authority : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) revoke ( self , account , owner , multi_signers = None , opts = None , recent_blockhash = None ) async Revoke transfer authority for a given account. Parameters: Name Type Description Default account Pubkey Source account for which transfer authority is being revoked. required owner Pubkey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) set_authority ( self , account , current_authority , authority_type , new_authority = None , multi_signers = None , opts = None , recent_blockhash = None ) async Assign a new authority to the account. Parameters: Name Type Description Default account Pubkey Public key of the token account. required current_authority Union[Keypair, Pubkey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[Pubkey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , recent_blockhash_to_use , ) return await self . _conn . send_transaction ( txn , opts = opts ) thaw_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Thaw account. Parameters: Name Type Description Default account Pubkey Account to thaw. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) transfer ( self , source , dest , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Transfer tokens to another account. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) transfer_checked ( self , source , dest , owner , amount , decimals , multi_signers , opts = None , recent_blockhash = None ) async Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Pubkey Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"Async Client"},{"location":"spl/token/async_client/#async-client","text":"Async SPL Token program client.","title":"Async Client"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken","text":"An ERC20-like Token. Source code in spl/token/async_client.py class AsyncToken ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : AsyncClient , pubkey : Pubkey , program_id : Pubkey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value async def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner ( * args ) async def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) async def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate ( * args ) async def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction recent_blockhash_to_use = ( ( await conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) token , txn , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , recent_blockhash_to_use , ) # Send the two instructions await conn . send_transaction ( txn , opts = opts ) return cast ( AsyncToken , token ) async def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) new_account_pk , txn , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment , recent_blockhash_to_use ) # Send the two instructions await self . _conn . send_transaction ( txn , opts = opts ) return new_account_pk async def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment , recent_blockhash_to_use , token_program_id = self . program_id ) await self . _conn . send_transaction ( txn , opts = opts ) return public_key @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) recent_blockhash_to_use = ( ( await conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) ( new_account_public_key , txn , payer , new_account , opts , ) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , recent_blockhash_to_use , ) await conn . send_transaction ( txn , opts = opts ) return new_account_public_key async def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed , recent_blockhash_to_use ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , opts = opts_to_use ) return multisig . pubkey () async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) async def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) async def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , recent_blockhash_to_use , ) return await self . _conn . send_transaction ( txn , opts = opts ) async def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def close_account ( self , account : Pubkey , dest : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def freeze_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def mint_to_checked ( self , dest : Pubkey , mint_authority : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts ) async def burn_checked ( self , account : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use , ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"AsyncToken"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.approve","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"approve()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.approve_checked","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"approve_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.burn","text":"Burn tokens. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"burn()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.burn_checked","text":"Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn_checked ( self , account : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use , ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"burn_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.close_account","text":"Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account Pubkey Account to close. required dest Pubkey Account to receive the remaining balance of the closed account. required authority Pubkey Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def close_account ( self , account : Pubkey , dest : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"close_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_account","text":"Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner Pubkey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash optional A prefetched blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) new_account_pk , txn , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment , recent_blockhash_to_use ) # Send the two instructions await self . _conn . send_transaction ( txn , opts = opts ) return new_account_pk","title":"create_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_associated_token_account","text":"Create an associated token account. Parameters: Name Type Description Default owner Pubkey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash optional A prefetched blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment , recent_blockhash_to_use , token_program_id = self . program_id ) await self . _conn . send_transaction ( txn , opts = opts ) return public_key","title":"create_associated_token_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_mint","text":"Create and initialize a token. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority Pubkey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id Pubkey SPL Token program account. required freeze_authority Optional[Pubkey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description AsyncToken Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction recent_blockhash_to_use = ( ( await conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) token , txn , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , recent_blockhash_to_use , ) # Send the two instructions await conn . send_transaction ( txn , opts = opts ) return cast ( AsyncToken , token )","title":"create_mint()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_multisig","text":"Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[Pubkey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new multisig account. Source code in spl/token/async_client.py async def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed , recent_blockhash_to_use ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , opts = opts_to_use ) return multisig . pubkey ()","title":"create_multisig()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_wrapped_native_account","text":"Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required program_id Pubkey SPL Token program account. required owner Pubkey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) recent_blockhash_to_use = ( ( await conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) ( new_account_public_key , txn , payer , new_account , opts , ) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , recent_blockhash_to_use , ) await conn . send_transaction ( txn , opts = opts ) return new_account_public_key","title":"create_wrapped_native_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.freeze_account","text":"Freeze account. Parameters: Name Type Description Default account Pubkey Account to freeze. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def freeze_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"freeze_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_account_info","text":"Retrieve account information. Source code in spl/token/async_client.py async def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info )","title":"get_account_info()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts_by_delegate","text":"Get token accounts of the provided delegate. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/async_client.py async def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate ( * args )","title":"get_accounts_by_delegate()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts_by_delegate_json_parsed","text":"Get token accounts of the provided delegate, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate_json_parsed ( * args )","title":"get_accounts_by_delegate_json_parsed()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts_by_owner","text":"Get token accounts of the provided owner. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/async_client.py async def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner ( * args )","title":"get_accounts_by_owner()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts_by_owner_json_parsed","text":"Get token accounts of the provided owner by the token's mint, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner_json_parsed ( * args )","title":"get_accounts_by_owner_json_parsed()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_balance","text":"Get the balance of the provided token account. Parameters: Name Type Description Default pubkey Pubkey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/async_client.py async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment )","title":"get_balance()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_account","text":"Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_mint","text":"Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_mint()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_multisig","text":"Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_multisig()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_mint_info","text":"Retrieve mint information. Source code in spl/token/async_client.py async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info )","title":"get_mint_info()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.mint_to","text":"Mint new tokens. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"mint_to()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.mint_to_checked","text":"Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Pubkey Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def mint_to_checked ( self , dest : Pubkey , mint_authority : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"mint_to_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.revoke","text":"Revoke transfer authority for a given account. Parameters: Name Type Description Default account Pubkey Source account for which transfer authority is being revoked. required owner Pubkey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"revoke()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.set_authority","text":"Assign a new authority to the account. Parameters: Name Type Description Default account Pubkey Public key of the token account. required current_authority Union[Keypair, Pubkey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[Pubkey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , recent_blockhash_to_use , ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"set_authority()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.thaw_account","text":"Thaw account. Parameters: Name Type Description Default account Pubkey Account to thaw. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"thaw_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.transfer","text":"Transfer tokens to another account. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"transfer()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.transfer_checked","text":"Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Pubkey Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( ( await self . _conn . get_latest_blockhash ()) . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return await self . _conn . send_transaction ( txn , opts = opts )","title":"transfer_checked()"},{"location":"spl/token/client/","text":"Client SPL Token program client. Token ( _TokenCore ) An ERC20-like Token. Source code in spl/token/client.py class Token ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : Client , pubkey : Pubkey , program_id : Pubkey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner ( * args ) def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate ( * args ) def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction recent_blockhash_to_use = ( conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) token , txn , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , recent_blockhash_to_use , ) # Send the two instructions conn . send_transaction ( txn , opts = opts ) return cast ( Token , token ) def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) new_account_pk , txn , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment , recent_blockhash_to_use ) # Send the two instructions self . _conn . send_transaction ( txn , opts = opts ) return new_account_pk def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment , recent_blockhash_to_use , token_program_id = self . program_id ) self . _conn . send_transaction ( txn , opts = opts ) return public_key @staticmethod def create_wrapped_native_account ( conn : Client , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) recent_blockhash_to_use = ( conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) ( new_account_public_key , txn , payer , new_account , opts , ) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , recent_blockhash_to_use , ) conn . send_transaction ( txn , opts = opts ) return new_account_public_key def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed , recent_blockhash_to_use ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , opts = opts_to_use ) return multisig . pubkey () def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , recent_blockhash_to_use , ) return self . _conn . send_transaction ( txn , opts = opts ) def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def close_account ( self , account : Pubkey , dest : Pubkey , authority : Union [ Keypair , Pubkey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def freeze_account ( self , account : Pubkey , authority : Union [ Pubkey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def mint_to_checked ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def burn_checked ( self , account : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) approve ( self , source , delegate , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) approve_checked ( self , source , delegate , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) burn ( self , account , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Burn tokens. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) burn_checked ( self , account , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Union[Keypair, Pubkey] Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn_checked ( self , account : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) close_account ( self , account , dest , authority , multi_signers = None , opts = None , recent_blockhash = None ) Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account Pubkey Account to close. required dest Pubkey Account to receive the remaining balance of the closed account. required authority Union[Keypair, Pubkey] Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def close_account ( self , account : Pubkey , dest : Pubkey , authority : Union [ Keypair , Pubkey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) create_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner Pubkey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) new_account_pk , txn , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment , recent_blockhash_to_use ) # Send the two instructions self . _conn . send_transaction ( txn , opts = opts ) return new_account_pk create_associated_token_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) Create an associated token account. Parameters: Name Type Description Default owner Pubkey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment , recent_blockhash_to_use , token_program_id = self . program_id ) self . _conn . send_transaction ( txn , opts = opts ) return public_key create_mint ( conn , payer , mint_authority , decimals , program_id , freeze_authority = None , skip_confirmation = False , recent_blockhash = None ) classmethod Create and initialize a token. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority Pubkey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id Pubkey SPL Token program account. required freeze_authority Optional[Pubkey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Token Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction recent_blockhash_to_use = ( conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) token , txn , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , recent_blockhash_to_use , ) # Send the two instructions conn . send_transaction ( txn , opts = opts ) return cast ( Token , token ) create_multisig ( self , m , multi_signers , opts = None , recent_blockhash = None ) Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[Pubkey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new multisig account. Source code in spl/token/client.py def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed , recent_blockhash_to_use ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , opts = opts_to_use ) return multisig . pubkey () create_wrapped_native_account ( conn , program_id , owner , payer , amount , skip_confirmation = False , recent_blockhash = None ) staticmethod Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required program_id Pubkey SPL Token program account. required owner Pubkey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @staticmethod def create_wrapped_native_account ( conn : Client , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) recent_blockhash_to_use = ( conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) ( new_account_public_key , txn , payer , new_account , opts , ) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , recent_blockhash_to_use , ) conn . send_transaction ( txn , opts = opts ) return new_account_public_key freeze_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) Freeze account. Parameters: Name Type Description Default account Pubkey Account to freeze. required authority Union[Pubkey, Keypair] The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def freeze_account ( self , account : Pubkey , authority : Union [ Pubkey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) get_account_info ( self , account , commitment = None ) Retrieve account information. Source code in spl/token/client.py def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) get_accounts_by_delegate ( self , owner , commitment = None , encoding = 'base64' ) Get token accounts of the provided delegate. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/client.py def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate ( * args ) get_accounts_by_delegate_json_parsed ( self , owner , commitment = None , encoding = 'base64' ) Get token accounts of the provided delegate, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) get_accounts_by_owner ( self , owner , commitment = None , encoding = 'base64' ) Get token accounts of the provided owner. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/client.py def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner ( * args ) get_accounts_by_owner_json_parsed ( self , owner , commitment = None ) Get token accounts of the provided owner by the token's mint, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) get_balance ( self , pubkey , commitment = None ) Get the balance of the provided token account. Parameters: Name Type Description Default pubkey Pubkey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/client.py def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) get_min_balance_rent_for_exempt_for_account ( conn ) staticmethod Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value get_min_balance_rent_for_exempt_for_mint ( conn ) staticmethod Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value get_min_balance_rent_for_exempt_for_multisig ( conn ) staticmethod Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value get_mint_info ( self ) Retrieve mint information. Source code in spl/token/client.py def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) mint_to ( self , dest , mint_authority , amount , multi_signers = None , opts = None , recent_blockhash = None ) Mint new tokens. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) mint_to_checked ( self , dest , mint_authority , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def mint_to_checked ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) revoke ( self , account , owner , multi_signers = None , opts = None , recent_blockhash = None ) Revoke transfer authority for a given account. Parameters: Name Type Description Default account Pubkey Source account for which transfer authority is being revoked. required owner Pubkey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) set_authority ( self , account , current_authority , authority_type , new_authority = None , multi_signers = None , opts = None , recent_blockhash = None ) Assign a new authority to the account. Parameters: Name Type Description Default account Pubkey Public key of the token account. required current_authority Union[Keypair, Pubkey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[Pubkey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , recent_blockhash_to_use , ) return self . _conn . send_transaction ( txn , opts = opts ) thaw_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) Thaw account. Parameters: Name Type Description Default account Pubkey Account to thaw. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) transfer ( self , source , dest , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Transfer tokens to another account. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) transfer_checked ( self , source , dest , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"Client"},{"location":"spl/token/client/#client","text":"SPL Token program client.","title":"Client"},{"location":"spl/token/client/#spl.token.client.Token","text":"An ERC20-like Token. Source code in spl/token/client.py class Token ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : Client , pubkey : Pubkey , program_id : Pubkey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner ( * args ) def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate ( * args ) def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction recent_blockhash_to_use = ( conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) token , txn , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , recent_blockhash_to_use , ) # Send the two instructions conn . send_transaction ( txn , opts = opts ) return cast ( Token , token ) def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) new_account_pk , txn , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment , recent_blockhash_to_use ) # Send the two instructions self . _conn . send_transaction ( txn , opts = opts ) return new_account_pk def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment , recent_blockhash_to_use , token_program_id = self . program_id ) self . _conn . send_transaction ( txn , opts = opts ) return public_key @staticmethod def create_wrapped_native_account ( conn : Client , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) recent_blockhash_to_use = ( conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) ( new_account_public_key , txn , payer , new_account , opts , ) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , recent_blockhash_to_use , ) conn . send_transaction ( txn , opts = opts ) return new_account_public_key def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed , recent_blockhash_to_use ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , opts = opts_to_use ) return multisig . pubkey () def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , recent_blockhash_to_use , ) return self . _conn . send_transaction ( txn , opts = opts ) def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def close_account ( self , account : Pubkey , dest : Pubkey , authority : Union [ Keypair , Pubkey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def freeze_account ( self , account : Pubkey , authority : Union [ Pubkey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def mint_to_checked ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts ) def burn_checked ( self , account : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"Token"},{"location":"spl/token/client/#spl.token.client.Token.approve","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"approve()"},{"location":"spl/token/client/#spl.token.client.Token.approve_checked","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"approve_checked()"},{"location":"spl/token/client/#spl.token.client.Token.burn","text":"Burn tokens. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"burn()"},{"location":"spl/token/client/#spl.token.client.Token.burn_checked","text":"Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Union[Keypair, Pubkey] Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn_checked ( self , account : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"burn_checked()"},{"location":"spl/token/client/#spl.token.client.Token.close_account","text":"Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account Pubkey Account to close. required dest Pubkey Account to receive the remaining balance of the closed account. required authority Union[Keypair, Pubkey] Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def close_account ( self , account : Pubkey , dest : Pubkey , authority : Union [ Keypair , Pubkey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"close_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_account","text":"Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner Pubkey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) new_account_pk , txn , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment , recent_blockhash_to_use ) # Send the two instructions self . _conn . send_transaction ( txn , opts = opts ) return new_account_pk","title":"create_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_associated_token_account","text":"Create an associated token account. Parameters: Name Type Description Default owner Pubkey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment , recent_blockhash_to_use , token_program_id = self . program_id ) self . _conn . send_transaction ( txn , opts = opts ) return public_key","title":"create_associated_token_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_mint","text":"Create and initialize a token. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority Pubkey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id Pubkey SPL Token program account. required freeze_authority Optional[Pubkey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Token Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction recent_blockhash_to_use = ( conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) token , txn , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , recent_blockhash_to_use , ) # Send the two instructions conn . send_transaction ( txn , opts = opts ) return cast ( Token , token )","title":"create_mint()"},{"location":"spl/token/client/#spl.token.client.Token.create_multisig","text":"Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[Pubkey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new multisig account. Source code in spl/token/client.py def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed , recent_blockhash_to_use ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , opts = opts_to_use ) return multisig . pubkey ()","title":"create_multisig()"},{"location":"spl/token/client/#spl.token.client.Token.create_wrapped_native_account","text":"Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required program_id Pubkey SPL Token program account. required owner Pubkey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @staticmethod def create_wrapped_native_account ( conn : Client , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) recent_blockhash_to_use = ( conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) ( new_account_public_key , txn , payer , new_account , opts , ) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , recent_blockhash_to_use , ) conn . send_transaction ( txn , opts = opts ) return new_account_public_key","title":"create_wrapped_native_account()"},{"location":"spl/token/client/#spl.token.client.Token.freeze_account","text":"Freeze account. Parameters: Name Type Description Default account Pubkey Account to freeze. required authority Union[Pubkey, Keypair] The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def freeze_account ( self , account : Pubkey , authority : Union [ Pubkey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"freeze_account()"},{"location":"spl/token/client/#spl.token.client.Token.get_account_info","text":"Retrieve account information. Source code in spl/token/client.py def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info )","title":"get_account_info()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts_by_delegate","text":"Get token accounts of the provided delegate. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/client.py def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate ( * args )","title":"get_accounts_by_delegate()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts_by_delegate_json_parsed","text":"Get token accounts of the provided delegate, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate_json_parsed ( * args )","title":"get_accounts_by_delegate_json_parsed()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts_by_owner","text":"Get token accounts of the provided owner. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/client.py def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner ( * args )","title":"get_accounts_by_owner()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts_by_owner_json_parsed","text":"Get token accounts of the provided owner by the token's mint, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner_json_parsed ( * args )","title":"get_accounts_by_owner_json_parsed()"},{"location":"spl/token/client/#spl.token.client.Token.get_balance","text":"Get the balance of the provided token account. Parameters: Name Type Description Default pubkey Pubkey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/client.py def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment )","title":"get_balance()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_account","text":"Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_account()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_mint","text":"Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_mint()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_multisig","text":"Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_multisig()"},{"location":"spl/token/client/#spl.token.client.Token.get_mint_info","text":"Retrieve mint information. Source code in spl/token/client.py def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info )","title":"get_mint_info()"},{"location":"spl/token/client/#spl.token.client.Token.mint_to","text":"Mint new tokens. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"mint_to()"},{"location":"spl/token/client/#spl.token.client.Token.mint_to_checked","text":"Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def mint_to_checked ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"mint_to_checked()"},{"location":"spl/token/client/#spl.token.client.Token.revoke","text":"Revoke transfer authority for a given account. Parameters: Name Type Description Default account Pubkey Source account for which transfer authority is being revoked. required owner Pubkey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"revoke()"},{"location":"spl/token/client/#spl.token.client.Token.set_authority","text":"Assign a new authority to the account. Parameters: Name Type Description Default account Pubkey Public key of the token account. required current_authority Union[Keypair, Pubkey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[Pubkey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , recent_blockhash_to_use , ) return self . _conn . send_transaction ( txn , opts = opts )","title":"set_authority()"},{"location":"spl/token/client/#spl.token.client.Token.thaw_account","text":"Thaw account. Parameters: Name Type Description Default account Pubkey Account to thaw. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"thaw_account()"},{"location":"spl/token/client/#spl.token.client.Token.transfer","text":"Transfer tokens to another account. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"transfer()"},{"location":"spl/token/client/#spl.token.client.Token.transfer_checked","text":"Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts recent_blockhash_to_use = ( self . _conn . get_latest_blockhash () . value . blockhash if recent_blockhash is None else recent_blockhash ) txn , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use , recent_blockhash_to_use ) return self . _conn . send_transaction ( txn , opts = opts )","title":"transfer_checked()"},{"location":"spl/token/constants/","text":"Constants SPL token constants. ACCOUNT_LEN : int Data length of a token account. ASSOCIATED_TOKEN_PROGRAM_ID Program ID for the associated token account program. MINT_LEN : int Data length of a token mint account. MULTISIG_LEN : int Data length of a multisig token account. NATIVE_DECIMALS : int Number of decimals for SOL and the Wrapped SOL mint. TOKEN_2022_PROGRAM_ID : Pubkey Public key that identifies the SPL token 2022 program. TOKEN_PROGRAM_ID : Pubkey Public key that identifies the SPL token program. WRAPPED_SOL_MINT : Pubkey Public key of the \"Native Mint\" for wrapping SOL to SPL token. The Token Program can be used to wrap native SOL. Doing so allows native SOL to be treated like any other Token program token type and can be useful when being called from other programs that interact with the Token Program's interface.","title":"Constants"},{"location":"spl/token/constants/#constants","text":"SPL token constants.","title":"Constants"},{"location":"spl/token/constants/#spl.token.constants.ACCOUNT_LEN","text":"Data length of a token account.","title":"ACCOUNT_LEN"},{"location":"spl/token/constants/#spl.token.constants.ASSOCIATED_TOKEN_PROGRAM_ID","text":"Program ID for the associated token account program.","title":"ASSOCIATED_TOKEN_PROGRAM_ID"},{"location":"spl/token/constants/#spl.token.constants.MINT_LEN","text":"Data length of a token mint account.","title":"MINT_LEN"},{"location":"spl/token/constants/#spl.token.constants.MULTISIG_LEN","text":"Data length of a multisig token account.","title":"MULTISIG_LEN"},{"location":"spl/token/constants/#spl.token.constants.NATIVE_DECIMALS","text":"Number of decimals for SOL and the Wrapped SOL mint.","title":"NATIVE_DECIMALS"},{"location":"spl/token/constants/#spl.token.constants.TOKEN_2022_PROGRAM_ID","text":"Public key that identifies the SPL token 2022 program.","title":"TOKEN_2022_PROGRAM_ID"},{"location":"spl/token/constants/#spl.token.constants.TOKEN_PROGRAM_ID","text":"Public key that identifies the SPL token program.","title":"TOKEN_PROGRAM_ID"},{"location":"spl/token/constants/#spl.token.constants.WRAPPED_SOL_MINT","text":"Public key of the \"Native Mint\" for wrapping SOL to SPL token. The Token Program can be used to wrap native SOL. Doing so allows native SOL to be treated like any other Token program token type and can be useful when being called from other programs that interact with the Token Program's interface.","title":"WRAPPED_SOL_MINT"},{"location":"spl/token/core/","text":"Core Helper code for client.py and async_client.py. AccountInfo ( tuple ) Information about an account. Source code in spl/token/core.py class AccountInfo ( NamedTuple ): \"\"\"Information about an account.\"\"\" mint : Pubkey \"\"\"The mint associated with this account.\"\"\" owner : Pubkey \"\"\"Owner of this account.\"\"\" amount : int \"\"\"Amount of tokens this account holds.\"\"\" delegate : Optional [ Pubkey ] \"\"\"The delegate for this account.\"\"\" delegated_amount : int \"\"\"The amount of tokens the delegate authorized to the delegate.\"\"\" is_initialized : bool \"\"\" Is this account initialized.\"\"\" is_frozen : bool \"\"\"Is this account frozen.\"\"\" is_native : bool \"\"\"Is this a native token account.\"\"\" rent_exempt_reserve : Optional [ int ] \"\"\"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. \"\"\" close_authority : Optional [ Pubkey ] \"\"\"Optional authority to close the account.\"\"\" amount : int Amount of tokens this account holds. close_authority : Optional [ solders . pubkey . Pubkey ] Optional authority to close the account. delegate : Optional [ solders . pubkey . Pubkey ] The delegate for this account. delegated_amount : int The amount of tokens the delegate authorized to the delegate. is_frozen : bool Is this account frozen. is_initialized : bool Is this account initialized. is_native : bool Is this a native token account. mint : Pubkey The mint associated with this account. owner : Pubkey Owner of this account. rent_exempt_reserve : Optional [ int ] If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/core.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , mint , owner , amount , delegate , delegated_amount , is_initialized , is_frozen , is_native , rent_exempt_reserve , close_authority ) special staticmethod Create new instance of AccountInfo(mint, owner, amount, delegate, delegated_amount, is_initialized, is_frozen, is_native, rent_exempt_reserve, close_authority) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/core.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self MintInfo ( tuple ) Information about the mint. Source code in spl/token/core.py class MintInfo ( NamedTuple ): \"\"\"Information about the mint.\"\"\" mint_authority : Optional [ Pubkey ] \"\"\"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. \"\"\" supply : int \"\"\"Total supply of tokens.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" is_initialized : bool \"\"\"Is this mint initialized.\"\"\" freeze_authority : Optional [ Pubkey ] \"\"\" Optional authority to freeze token accounts.\"\"\" decimals : int Number of base 10 digits to the right of the decimal place. freeze_authority : Optional [ solders . pubkey . Pubkey ] Optional authority to freeze token accounts. is_initialized : bool Is this mint initialized. mint_authority : Optional [ solders . pubkey . Pubkey ] \"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. supply : int Total supply of tokens. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/core.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , mint_authority , supply , decimals , is_initialized , freeze_authority ) special staticmethod Create new instance of MintInfo(mint_authority, supply, decimals, is_initialized, freeze_authority) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/core.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"Core"},{"location":"spl/token/core/#core","text":"Helper code for client.py and async_client.py.","title":"Core"},{"location":"spl/token/core/#spl.token.core.AccountInfo","text":"Information about an account. Source code in spl/token/core.py class AccountInfo ( NamedTuple ): \"\"\"Information about an account.\"\"\" mint : Pubkey \"\"\"The mint associated with this account.\"\"\" owner : Pubkey \"\"\"Owner of this account.\"\"\" amount : int \"\"\"Amount of tokens this account holds.\"\"\" delegate : Optional [ Pubkey ] \"\"\"The delegate for this account.\"\"\" delegated_amount : int \"\"\"The amount of tokens the delegate authorized to the delegate.\"\"\" is_initialized : bool \"\"\" Is this account initialized.\"\"\" is_frozen : bool \"\"\"Is this account frozen.\"\"\" is_native : bool \"\"\"Is this a native token account.\"\"\" rent_exempt_reserve : Optional [ int ] \"\"\"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. \"\"\" close_authority : Optional [ Pubkey ] \"\"\"Optional authority to close the account.\"\"\"","title":"AccountInfo"},{"location":"spl/token/core/#spl.token.core.AccountInfo.amount","text":"Amount of tokens this account holds.","title":"amount"},{"location":"spl/token/core/#spl.token.core.AccountInfo.close_authority","text":"Optional authority to close the account.","title":"close_authority"},{"location":"spl/token/core/#spl.token.core.AccountInfo.delegate","text":"The delegate for this account.","title":"delegate"},{"location":"spl/token/core/#spl.token.core.AccountInfo.delegated_amount","text":"The amount of tokens the delegate authorized to the delegate.","title":"delegated_amount"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_frozen","text":"Is this account frozen.","title":"is_frozen"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_initialized","text":"Is this account initialized.","title":"is_initialized"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_native","text":"Is this a native token account.","title":"is_native"},{"location":"spl/token/core/#spl.token.core.AccountInfo.mint","text":"The mint associated with this account.","title":"mint"},{"location":"spl/token/core/#spl.token.core.AccountInfo.owner","text":"Owner of this account.","title":"owner"},{"location":"spl/token/core/#spl.token.core.AccountInfo.rent_exempt_reserve","text":"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed.","title":"rent_exempt_reserve"},{"location":"spl/token/core/#spl.token.core.AccountInfo.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/core.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/core/#spl.token.core.AccountInfo.__new__","text":"Create new instance of AccountInfo(mint, owner, amount, delegate, delegated_amount, is_initialized, is_frozen, is_native, rent_exempt_reserve, close_authority)","title":"__new__()"},{"location":"spl/token/core/#spl.token.core.AccountInfo.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/core.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/core/#spl.token.core.MintInfo","text":"Information about the mint. Source code in spl/token/core.py class MintInfo ( NamedTuple ): \"\"\"Information about the mint.\"\"\" mint_authority : Optional [ Pubkey ] \"\"\"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. \"\"\" supply : int \"\"\"Total supply of tokens.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" is_initialized : bool \"\"\"Is this mint initialized.\"\"\" freeze_authority : Optional [ Pubkey ] \"\"\" Optional authority to freeze token accounts.\"\"\"","title":"MintInfo"},{"location":"spl/token/core/#spl.token.core.MintInfo.decimals","text":"Number of base 10 digits to the right of the decimal place.","title":"decimals"},{"location":"spl/token/core/#spl.token.core.MintInfo.freeze_authority","text":"Optional authority to freeze token accounts.","title":"freeze_authority"},{"location":"spl/token/core/#spl.token.core.MintInfo.is_initialized","text":"Is this mint initialized.","title":"is_initialized"},{"location":"spl/token/core/#spl.token.core.MintInfo.mint_authority","text":"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.","title":"mint_authority"},{"location":"spl/token/core/#spl.token.core.MintInfo.supply","text":"Total supply of tokens.","title":"supply"},{"location":"spl/token/core/#spl.token.core.MintInfo.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/core.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/core/#spl.token.core.MintInfo.__new__","text":"Create new instance of MintInfo(mint_authority, supply, decimals, is_initialized, freeze_authority)","title":"__new__()"},{"location":"spl/token/core/#spl.token.core.MintInfo.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/core.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/","text":"Instructions SPL token instructions. ApproveCheckedParams ( tuple ) ApproveChecked token transaction params. Source code in spl/token/instructions.py class ApproveCheckedParams ( NamedTuple ): \"\"\"ApproveChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" delegate : Pubkey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Maximum number of tokens the delegate may transfer. decimals : int Amount decimals. delegate : Pubkey Delegate account authorized to perform a transfer of tokens from the source account. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. source : Pubkey Source account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , source , mint , delegate , owner , amount , decimals , signers = []) special staticmethod Create new instance of ApproveCheckedParams(program_id, source, mint, delegate, owner, amount, decimals, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self ApproveParams ( tuple ) Approve token transaction params. Source code in spl/token/instructions.py class ApproveParams ( NamedTuple ): \"\"\"Approve token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" delegate : Pubkey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Maximum number of tokens the delegate may transfer. delegate : Pubkey Delegate account authorized to perform a transfer of tokens from the source account. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. source : Pubkey Source account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , source , delegate , owner , amount , signers = []) special staticmethod Create new instance of ApproveParams(program_id, source, delegate, owner, amount, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self AuthorityType ( IntEnum ) Specifies the authority type for SetAuthority instructions. Source code in spl/token/instructions.py class AuthorityType ( IntEnum ): \"\"\"Specifies the authority type for SetAuthority instructions.\"\"\" MINT_TOKENS = 0 \"\"\"\"Authority to mint new tokens.\"\"\" FREEZE_ACCOUNT = 1 \"\"\"Authority to freeze any account associated with the Mint.\"\"\" ACCOUNT_OWNER = 2 \"\"\"Owner of a given token account.\"\"\" CLOSE_ACCOUNT = 3 \"\"\"Authority to close a token account.\"\"\" ACCOUNT_OWNER Owner of a given token account. CLOSE_ACCOUNT Authority to close a token account. FREEZE_ACCOUNT Authority to freeze any account associated with the Mint. MINT_TOKENS \"Authority to mint new tokens. BurnCheckedParams ( tuple ) BurnChecked token transaction params. Source code in spl/token/instructions.py class BurnCheckedParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" account : Pubkey \"\"\"Account to burn tokens from.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : Pubkey Account to burn tokens from. amount : int Amount to burn. decimals : int Amount decimals. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , mint , account , owner , amount , decimals , signers = []) special staticmethod Create new instance of BurnCheckedParams(program_id, mint, account, owner, amount, decimals, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self BurnParams ( tuple ) Burn token transaction params. Source code in spl/token/instructions.py class BurnParams ( NamedTuple ): \"\"\"Burn token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to burn tokens from.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : Pubkey Account to burn tokens from. amount : int Amount to burn. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , account , mint , owner , amount , signers = []) special staticmethod Create new instance of BurnParams(program_id, account, mint, owner, amount, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self CloseAccountParams ( tuple ) Close token account transaction params. Source code in spl/token/instructions.py class CloseAccountParams ( NamedTuple ): \"\"\"Close token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Address of account to close.\"\"\" dest : Pubkey \"\"\"Address of account to receive the remaining balance of the closed account.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : Pubkey Address of account to close. dest : Pubkey Address of account to receive the remaining balance of the closed account. owner : Pubkey Owner of the account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , account , dest , owner , signers = []) special staticmethod Create new instance of CloseAccountParams(program_id, account, dest, owner, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self FreezeAccountParams ( tuple ) Freeze token account transaction params. Source code in spl/token/instructions.py class FreezeAccountParams ( NamedTuple ): \"\"\"Freeze token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to freeze.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" authority : Pubkey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\" account : Pubkey Account to freeze. authority : Pubkey Mint freeze authority mint : Pubkey Public key of the minter account. multi_signers : List [ solders . pubkey . Pubkey ] Signing accounts if authority is a multiSig program_id : Pubkey SPL Token program account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , account , mint , authority , multi_signers = []) special staticmethod Create new instance of FreezeAccountParams(program_id, account, mint, authority, multi_signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self InitializeAccountParams ( tuple ) Initialize token account transaction params. Source code in spl/token/instructions.py class InitializeAccountParams ( NamedTuple ): \"\"\"Initialize token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Public key of the new account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" owner : Pubkey \"\"\"Owner of the new account.\"\"\" account : Pubkey Public key of the new account. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the new account. program_id : Pubkey SPL Token program account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , account , mint , owner ) special staticmethod Create new instance of InitializeAccountParams(program_id, account, mint, owner) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self InitializeMintParams ( tuple ) Initialize token mint transaction params. Source code in spl/token/instructions.py class InitializeMintParams ( NamedTuple ): \"\"\"Initialize token mint transaction params.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" mint_authority : Pubkey \"\"\"The authority/multisignature to mint tokens.\"\"\" freeze_authority : Optional [ Pubkey ] = None \"\"\"The freeze authority/multisignature of the mint.\"\"\" decimals : int Number of base 10 digits to the right of the decimal place. freeze_authority : Optional [ solders . pubkey . Pubkey ] The freeze authority/multisignature of the mint. mint : Pubkey Public key of the minter account. mint_authority : Pubkey The authority/multisignature to mint tokens. program_id : Pubkey SPL Token program account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , decimals , program_id , mint , mint_authority , freeze_authority = None ) special staticmethod Create new instance of InitializeMintParams(decimals, program_id, mint, mint_authority, freeze_authority) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self InitializeMultisigParams ( tuple ) Initialize multisig token account transaction params. Source code in spl/token/instructions.py class InitializeMultisigParams ( NamedTuple ): \"\"\"Initialize multisig token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" multisig : Pubkey \"\"\"New multisig account address.\"\"\" m : int \"\"\"The number of signers (M) required to validate this multisignature account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Addresses of multisig signers.\"\"\" m : int The number of signers (M) required to validate this multisignature account. multisig : Pubkey New multisig account address. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Addresses of multisig signers. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , multisig , m , signers = []) special staticmethod Create new instance of InitializeMultisigParams(program_id, multisig, m, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self MintToCheckedParams ( tuple ) MintToChecked token transaction params. Source code in spl/token/instructions.py class MintToCheckedParams ( NamedTuple ): \"\"\"MintToChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : Pubkey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\" amount : int Amount to mint. decimals : int Amount decimals. dest : Pubkey Public key of the account to mint to. mint : Pubkey Public key of the minter account. mint_authority : Pubkey The mint authority. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if mint_authority is a multiSig. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , mint , dest , mint_authority , amount , decimals , signers = []) special staticmethod Create new instance of MintToCheckedParams(program_id, mint, dest, mint_authority, amount, decimals, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self MintToParams ( tuple ) Mint token transaction params. Source code in spl/token/instructions.py class MintToParams ( NamedTuple ): \"\"\"Mint token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : Pubkey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\" amount : int Amount to mint. dest : Pubkey Public key of the account to mint to. mint : Pubkey Public key of the minter account. mint_authority : Pubkey The mint authority. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if mint_authority is a multiSig. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , mint , dest , mint_authority , amount , signers = []) special staticmethod Create new instance of MintToParams(program_id, mint, dest, mint_authority, amount, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self RevokeParams ( tuple ) Revoke token transaction params. Source code in spl/token/instructions.py class RevokeParams ( NamedTuple ): \"\"\"Revoke token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Source account for which transfer authority is being revoked.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" account : Pubkey Source account for which transfer authority is being revoked. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , account , owner , signers = []) special staticmethod Create new instance of RevokeParams(program_id, account, owner, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self SetAuthorityParams ( tuple ) Set token authority transaction params. Source code in spl/token/instructions.py class SetAuthorityParams ( NamedTuple ): \"\"\"Set token authority transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Public key of the token account.\"\"\" authority : AuthorityType \"\"\"The type of authority to update.\"\"\" current_authority : Pubkey \"\"\"Current authority of the specified type.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `current_authority` is a multiSig.\"\"\" new_authority : Optional [ Pubkey ] = None \"\"\"New authority of the account.\"\"\" account : Pubkey Public key of the token account. authority : AuthorityType The type of authority to update. current_authority : Pubkey Current authority of the specified type. new_authority : Optional [ solders . pubkey . Pubkey ] New authority of the account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if current_authority is a multiSig. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , account , authority , current_authority , signers = [], new_authority = None ) special staticmethod Create new instance of SetAuthorityParams(program_id, account, authority, current_authority, signers, new_authority) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self SyncNativeParams ( tuple ) BurnChecked token transaction params. Source code in spl/token/instructions.py class SyncNativeParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to sync.\"\"\" account : Pubkey Account to sync. program_id : Pubkey SPL Token program account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , account ) special staticmethod Create new instance of SyncNativeParams(program_id, account) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self ThawAccountParams ( tuple ) Thaw token account transaction params. Source code in spl/token/instructions.py class ThawAccountParams ( NamedTuple ): \"\"\"Thaw token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to thaw.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" authority : Pubkey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\" account : Pubkey Account to thaw. authority : Pubkey Mint freeze authority mint : Pubkey Public key of the minter account. multi_signers : List [ solders . pubkey . Pubkey ] Signing accounts if authority is a multiSig program_id : Pubkey SPL Token program account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , account , mint , authority , multi_signers = []) special staticmethod Create new instance of ThawAccountParams(program_id, account, mint, authority, multi_signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self TransferCheckedParams ( tuple ) TransferChecked token transaction params. Source code in spl/token/instructions.py class TransferCheckedParams ( NamedTuple ): \"\"\"TransferChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Destination account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Number of tokens to transfer. decimals : int Amount decimals. dest : Pubkey Destination account. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. source : Pubkey Source account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , source , mint , dest , owner , amount , decimals , signers = []) special staticmethod Create new instance of TransferCheckedParams(program_id, source, mint, dest, owner, amount, decimals, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self TransferParams ( tuple ) Transfer token transaction params. Source code in spl/token/instructions.py class TransferParams ( NamedTuple ): \"\"\"Transfer token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" dest : Pubkey \"\"\"Destination account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Number of tokens to transfer. dest : Pubkey Destination account. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. source : Pubkey Source account. __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , program_id , source , dest , owner , amount , signers = []) special staticmethod Create new instance of TransferParams(program_id, source, dest, owner, amount, signers) __repr__ ( self ) special Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self approve ( params ) Creates a transaction instruction to approve a delegate. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> delegate , owner , source , token = pubkeys >>> params = ApproveParams ( ... amount = 123 , ... delegate = delegate , ... owner = owner , ... program_id = token , ... source = source ... ) >>> type ( approve ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The approve instruction. Source code in spl/token/instructions.py def approve ( params : ApproveParams ) -> Instruction : \"\"\"Creates a transaction instruction to approve a delegate. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> delegate, owner, source, token = pubkeys >>> params = ApproveParams( ... amount=123, ... delegate=delegate, ... owner=owner, ... program_id=token, ... source=source ... ) >>> type(approve(params)) <class 'solders.instruction.Instruction'> Returns: The approve instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . APPROVE , \"args\" : { \"amount\" : params . amount }}) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) approve_checked ( params ) This instruction differs from approve in that the token mint and decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 5 )] >>> delegate , mint , owner , source , token = pubkeys >>> params = ApproveCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... delegate = delegate , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( approve_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The approve-checked instruction. Source code in spl/token/instructions.py def approve_checked ( params : ApproveCheckedParams ) -> Instruction : \"\"\"This instruction differs from `approve` in that the token mint and decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(5)] >>> delegate, mint, owner, source, token = pubkeys >>> params = ApproveCheckedParams( ... amount=1000, ... decimals=6, ... delegate=delegate, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(approve_checked(params)) <class 'solders.instruction.Instruction'> Returns: The approve-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . APPROVE2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) burn ( params ) Creates a transaction instruction to burns tokens by removing them from an account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = BurnParams ( ... amount = 123 , account = account , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The burn instruction. Source code in spl/token/instructions.py def burn ( params : BurnParams ) -> Instruction : \"\"\"Creates a transaction instruction to burns tokens by removing them from an account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = BurnParams( ... amount=123, account=account, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn(params)) <class 'solders.instruction.Instruction'> Returns: The burn instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . BURN , \"args\" : { \"amount\" : params . amount }}) return __burn_instruction ( params , data ) burn_checked ( params ) This instruction differs from burn in that the decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = BurnCheckedParams ( ... amount = 123 , account = account , decimals = 6 , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The burn-checked instruction. Source code in spl/token/instructions.py def burn_checked ( params : BurnCheckedParams ) -> Instruction : \"\"\"This instruction differs from `burn` in that the decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = BurnCheckedParams( ... amount=123, account=account, decimals=6, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn_checked(params)) <class 'solders.instruction.Instruction'> Returns: The burn-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . BURN2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) return __burn_instruction ( params , data ) close_account ( params ) Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , dest , owner , token = pubkeys >>> params = CloseAccountParams ( ... account = account , dest = dest , owner = owner , program_id = token ) >>> type ( close_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The close-account instruction. Source code in spl/token/instructions.py def close_account ( params : CloseAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, dest, owner, token = pubkeys >>> params = CloseAccountParams( ... account=account, dest=dest, owner=owner, program_id=token) >>> type(close_account(params)) <class 'solders.instruction.Instruction'> Returns: The close-account instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . CLOSE_ACCOUNT , \"args\" : None }) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) create_associated_token_account ( payer , owner , mint , token_program_id = Pubkey ( TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA , )) Creates a transaction instruction to create an associated token account. Parameters: Name Type Description Default payer Pubkey Payer's wallet address. required owner Pubkey Owner's wallet address. required mint Pubkey The token mint address. required token_program_id Pubkey The token program ID. Must be either spl.token.constants.TOKEN_PROGRAM_ID or spl.token.constants.TOKEN_2022_PROGRAM_ID (default is TOKEN_PROGRAM_ID ). Pubkey( TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA, ) Returns: Type Description Instruction The instruction to create the associated token account. Exceptions: Type Description ValueError If an invalid token_program_id is provided. Source code in spl/token/instructions.py def create_associated_token_account ( payer : Pubkey , owner : Pubkey , mint : Pubkey , token_program_id : Pubkey = TOKEN_PROGRAM_ID ) -> Instruction : \"\"\"Creates a transaction instruction to create an associated token account. Args: payer (Pubkey): Payer's wallet address. owner (Pubkey): Owner's wallet address. mint (Pubkey): The token mint address. token_program_id (Pubkey, optional): The token program ID. Must be either `spl.token.constants.TOKEN_PROGRAM_ID` or `spl.token.constants.TOKEN_2022_PROGRAM_ID` (default is `TOKEN_PROGRAM_ID`). Returns: The instruction to create the associated token account. Raises: ValueError: If an invalid `token_program_id` is provided. \"\"\" if token_program_id not in [ TOKEN_PROGRAM_ID , TOKEN_2022_PROGRAM_ID ]: raise ValueError ( \"token_program_id must be one of TOKEN_PROGRAM_ID or TOKEN_2022_PROGRAM_ID.\" ) associated_token_address = get_associated_token_address ( owner , mint , token_program_id ) return Instruction ( accounts = [ AccountMeta ( pubkey = payer , is_signer = True , is_writable = True ), AccountMeta ( pubkey = associated_token_address , is_signer = False , is_writable = True ), AccountMeta ( pubkey = owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYS_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = token_program_id , is_signer = False , is_writable = False ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , data = bytes ( 0 ), ) create_idempotent_associated_token_account ( payer , owner , mint , token_program_id = Pubkey ( TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA , )) Creates an associated token account for the given address/token mint if it not exists. Returns: Type Description Instruction The instruction to create the associated token account. Source code in spl/token/instructions.py def create_idempotent_associated_token_account ( payer : Pubkey , owner : Pubkey , mint : Pubkey , token_program_id : Pubkey = TOKEN_PROGRAM_ID ) -> Instruction : \"\"\"Creates an associated token account for the given address/token mint if it not exists. Returns: The instruction to create the associated token account. \"\"\" if token_program_id not in [ TOKEN_PROGRAM_ID , TOKEN_2022_PROGRAM_ID ]: raise ValueError ( \"token_program_id must be one of TOKEN_PROGRAM_ID or TOKEN_2022_PROGRAM_ID.\" ) associated_token_address = get_associated_token_address ( owner , mint , token_program_id ) return Instruction ( accounts = [ AccountMeta ( pubkey = payer , is_signer = True , is_writable = True ), AccountMeta ( pubkey = associated_token_address , is_signer = False , is_writable = True ), AccountMeta ( pubkey = owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYS_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = token_program_id , is_signer = False , is_writable = False ), ], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , data = bytes ([ 1 ]), ) decode_approve ( instruction ) Decode a approve token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ApproveParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve ( instruction : Instruction ) -> ApproveParams : \"\"\"Decode a approve token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . APPROVE ) return ApproveParams ( program_id = instruction . program_id , source = instruction . accounts [ 0 ] . pubkey , delegate = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], amount = parsed_data . args . amount , ) decode_approve_checked ( instruction ) Decode a approve_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ApproveCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve_checked ( instruction : Instruction ) -> ApproveCheckedParams : \"\"\"Decode a approve_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . APPROVE2 ) return ApproveCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , delegate = instruction . accounts [ 2 ] . pubkey , owner = instruction . accounts [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 4 :]], ) decode_burn ( instruction ) Decode a burn token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description BurnParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn ( instruction : Instruction ) -> BurnParams : \"\"\"Decode a burn token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN ) return BurnParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_burn_checked ( instruction ) Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description BurnCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn_checked ( instruction : Instruction ) -> BurnCheckedParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN2 ) return BurnCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_close_account ( instruction ) Decode a close account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description CloseAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_close_account ( instruction : Instruction ) -> CloseAccountParams : \"\"\"Decode a close account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . CLOSE_ACCOUNT ) return CloseAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_freeze_account ( instruction ) Decode a freeze account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description FreezeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_freeze_account ( instruction : Instruction ) -> FreezeAccountParams : \"\"\"Decode a freeze account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . FREEZE_ACCOUNT ) return FreezeAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , authority = instruction . accounts [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_initialize_account ( instruction ) Decode an initialize account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_account ( instruction : Instruction ) -> InitializeAccountParams : \"\"\"Decode an initialize account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 4 , InstructionType . INITIALIZE_ACCOUNT ) return InitializeAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , ) decode_initialize_mint ( instruction ) Decode an initialize mint token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeMintParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_mint ( instruction : Instruction ) -> InitializeMintParams : \"\"\"Decode an initialize mint token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MINT ) return InitializeMintParams ( decimals = parsed_data . args . decimals , program_id = instruction . program_id , mint = instruction . accounts [ 0 ] . pubkey , mint_authority = Pubkey ( parsed_data . args . mint_authority ), freeze_authority = Pubkey ( parsed_data . args . freeze_authority ) if parsed_data . args . freeze_authority_option else None , ) decode_initialize_multisig ( instruction ) Decode an initialize multisig account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeMultisigParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_multisig ( instruction : Instruction ) -> InitializeMultisigParams : \"\"\"Decode an initialize multisig account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MULTISIG ) num_signers = parsed_data . args . m validate_instruction_keys ( instruction , 2 + num_signers ) return InitializeMultisigParams ( program_id = instruction . program_id , multisig = instruction . accounts [ 0 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ - num_signers :]], m = num_signers , ) decode_mint_to ( instruction ) Decode a mint to token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MintToParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to ( instruction : Instruction ) -> MintToParams : \"\"\"Decode a mint to token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO ) return MintToParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , mint = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , mint_authority = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_mint_to_checked ( instruction ) Decode a mintTo2 token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MintToCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to_checked ( instruction : Instruction ) -> MintToCheckedParams : \"\"\"Decode a mintTo2 token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO2 ) return MintToCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , mint = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , mint_authority = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_revoke ( instruction ) Decode a revoke token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description RevokeParams The decoded instruction. Source code in spl/token/instructions.py def decode_revoke ( instruction : Instruction ) -> RevokeParams : \"\"\"Decode a revoke token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 2 , InstructionType . REVOKE ) return RevokeParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , owner = instruction . accounts [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 2 :]], ) decode_set_authority ( instruction ) Decode a set authority token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description SetAuthorityParams The decoded instruction. Source code in spl/token/instructions.py def decode_set_authority ( instruction : Instruction ) -> SetAuthorityParams : \"\"\"Decode a set authority token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . SET_AUTHORITY ) return SetAuthorityParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , authority = AuthorityType ( parsed_data . args . authority_type ), new_authority = Pubkey ( parsed_data . args . new_authority ) if parsed_data . args . new_authority_option else None , current_authority = instruction . accounts [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 2 :]], ) decode_sync_native ( instruction ) Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description SyncNativeParams The decoded instruction. Source code in spl/token/instructions.py def decode_sync_native ( instruction : Instruction ) -> SyncNativeParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return SyncNativeParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , ) decode_thaw_account ( instruction ) Decode a thaw account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ThawAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_thaw_account ( instruction : Instruction ) -> ThawAccountParams : \"\"\"Decode a thaw account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . THAW_ACCOUNT ) return ThawAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , authority = instruction . accounts [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_transfer ( instruction ) Decode a transfer token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description TransferParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer ( instruction : Instruction ) -> TransferParams : \"\"\"Decode a transfer token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . TRANSFER ) return TransferParams ( program_id = instruction . program_id , source = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], amount = parsed_data . args . amount , ) decode_transfer_checked ( instruction ) Decode a transfer_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description TransferCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer_checked ( instruction : Instruction ) -> TransferCheckedParams : \"\"\"Decode a transfer_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . TRANSFER2 ) return TransferCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , dest = instruction . accounts [ 2 ] . pubkey , owner = instruction . accounts [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 4 :]], ) freeze_account ( params ) Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , authority , token = pubkeys >>> params = FreezeAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( freeze_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The freeze-account instruction. Source code in spl/token/instructions.py def freeze_account ( params : FreezeAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, authority, token = pubkeys >>> params = FreezeAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(freeze_account(params)) <class 'solders.instruction.Instruction'> Returns: The freeze-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . FREEZE_ACCOUNT ) get_associated_token_address ( owner , mint , token_program_id = Pubkey ( TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA , )) Derives the associated token address for the given wallet address and token mint. Parameters: Name Type Description Default owner Pubkey Owner's wallet address. required mint Pubkey The token mint address. required token_program_id Pubkey The token program ID. Must be either spl.token.constants.TOKEN_PROGRAM_ID or spl.token.constants.TOKEN_2022_PROGRAM_ID (default is TOKEN_PROGRAM_ID ). Pubkey( TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA, ) Returns: Type Description Pubkey The public key of the derived associated token address. Exceptions: Type Description ValueError If an invalid token_program_id is provided. Source code in spl/token/instructions.py def get_associated_token_address ( owner : Pubkey , mint : Pubkey , token_program_id : Pubkey = TOKEN_PROGRAM_ID ) -> Pubkey : \"\"\"Derives the associated token address for the given wallet address and token mint. Args: owner (Pubkey): Owner's wallet address. mint (Pubkey): The token mint address. token_program_id (Pubkey, optional): The token program ID. Must be either `spl.token.constants.TOKEN_PROGRAM_ID` or `spl.token.constants.TOKEN_2022_PROGRAM_ID` (default is `TOKEN_PROGRAM_ID`). Returns: The public key of the derived associated token address. Raises: ValueError: If an invalid `token_program_id` is provided. \"\"\" if token_program_id not in [ TOKEN_PROGRAM_ID , TOKEN_2022_PROGRAM_ID ]: raise ValueError ( \"token_program_id must be one of TOKEN_PROGRAM_ID or TOKEN_2022_PROGRAM_ID.\" ) key , _ = Pubkey . find_program_address ( seeds = [ bytes ( owner ), bytes ( token_program_id ), bytes ( mint )], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , ) return key initialize_account ( params ) Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = InitializeAccountParams ( ... account = account , ... mint = mint , ... owner = owner , ... program_id = token , ... ) >>> type ( initialize_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the account. Source code in spl/token/instructions.py def initialize_account ( params : InitializeAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = InitializeAccountParams( ... account=account, ... mint=mint, ... owner=owner, ... program_id=token, ... ) >>> type(initialize_account(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the account. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . INITIALIZE_ACCOUNT , \"args\" : None }) return Instruction ( accounts = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , ) initialize_mint ( params ) Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> from solders.pubkey import Pubkey >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> mint_account , mint_authority , freeze_authority , owner = pubkeys >>> params = InitializeMintParams ( ... decimals = 6 , ... freeze_authority = freeze_authority , ... mint = mint_account , ... mint_authority = mint_authority , ... program_id = TOKEN_PROGRAM_ID , ... ) >>> type ( initialize_mint ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the mint. Source code in spl/token/instructions.py def initialize_mint ( params : InitializeMintParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> from solders.pubkey import Pubkey >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i +1]) for i in range(4)] >>> mint_account, mint_authority, freeze_authority, owner = pubkeys >>> params = InitializeMintParams( ... decimals=6, ... freeze_authority=freeze_authority, ... mint=mint_account, ... mint_authority=mint_authority, ... program_id=TOKEN_PROGRAM_ID, ... ) >>> type(initialize_mint(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the mint. \"\"\" freeze_authority , opt = ( params . freeze_authority , 1 ) if params . freeze_authority else ( Pubkey ([ 0 ] * 31 + [ 0 ]), 0 ) data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . INITIALIZE_MINT , \"args\" : { \"decimals\" : params . decimals , \"mint_authority\" : bytes ( params . mint_authority ), \"freeze_authority_option\" : opt , \"freeze_authority\" : bytes ( freeze_authority ), }, } ) return Instruction ( accounts = [ AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = True ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , ) initialize_multisig ( params ) Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> m = 2 # Two signers >>> signers = [ Pubkey ([ 0 ] * 31 + [ i ]) for i in range ( m )] >>> leading_zeros = [ 0 ] * 31 >>> multisig_account , token = Pubkey ( leading_zeros + [ 1 ]), Pubkey ( leading_zeros + [ 2 ]) >>> params = InitializeMultisigParams ( ... m = m , ... multisig = multisig_account , ... signers = signers , ... program_id = token , ... ) >>> type ( initialize_multisig ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the multisig. Source code in spl/token/instructions.py def initialize_multisig ( params : InitializeMultisigParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> m = 2 # Two signers >>> signers = [Pubkey([0] * 31 + [i]) for i in range(m)] >>> leading_zeros = [0] * 31 >>> multisig_account, token = Pubkey(leading_zeros + [1]), Pubkey(leading_zeros + [2]) >>> params = InitializeMultisigParams( ... m=m, ... multisig=multisig_account, ... signers=signers, ... program_id=token, ... ) >>> type(initialize_multisig(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the multisig. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . INITIALIZE_MULTISIG , \"args\" : { \"m\" : params . m }, } ) keys = [ AccountMeta ( pubkey = params . multisig , is_signer = False , is_writable = True ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ] for signer in params . signers : keys . append ( AccountMeta ( pubkey = signer , is_signer = False , is_writable = False )) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) mint_to ( params ) Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , mint , mint_authority , token = pubkeys >>> params = MintToParams ( ... amount = 123 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The mint-to instruction. Source code in spl/token/instructions.py def mint_to ( params : MintToParams ) -> Instruction : \"\"\"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, mint, mint_authority, token = pubkeys >>> params = MintToParams( ... amount=123, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to(params)) <class 'solders.instruction.Instruction'> Returns: The mint-to instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . MINT_TO , \"args\" : { \"amount\" : params . amount }}) return __mint_to_instruction ( params , data ) mint_to_checked ( params ) This instruction differs from mint_to in that the decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , mint , mint_authority , token = pubkeys >>> params = MintToCheckedParams ( ... amount = 123 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The mint-to-checked instruction. Source code in spl/token/instructions.py def mint_to_checked ( params : MintToCheckedParams ) -> Instruction : \"\"\"This instruction differs from `mint_to` in that the decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, mint, mint_authority, token = pubkeys >>> params = MintToCheckedParams( ... amount=123, ... decimals=6, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to_checked(params)) <class 'solders.instruction.Instruction'> Returns: The mint-to-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . MINT_TO2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) return __mint_to_instruction ( params , data ) revoke ( params ) Creates a transaction instruction that revokes delegate authority for a given account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 3 )] >>> account , owner , token = pubkeys >>> params = RevokeParams ( ... account = account , owner = owner , program_id = token ... ) >>> type ( revoke ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The revoke instruction. Source code in spl/token/instructions.py def revoke ( params : RevokeParams ) -> Instruction : \"\"\"Creates a transaction instruction that revokes delegate authority for a given account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(3)] >>> account, owner, token = pubkeys >>> params = RevokeParams( ... account=account, owner=owner, program_id=token ... ) >>> type(revoke(params)) <class 'solders.instruction.Instruction'> Returns: The revoke instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . REVOKE , \"args\" : None }) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) set_authority ( params ) Creates a transaction instruction to sets a new authority of a mint or account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , current_authority , new_authority , token = pubkeys >>> params = SetAuthorityParams ( ... account = account , ... authority = AuthorityType . ACCOUNT_OWNER , ... current_authority = current_authority , ... new_authority = new_authority , ... program_id = token , ... ) >>> type ( set_authority ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The set authority instruction. Source code in spl/token/instructions.py def set_authority ( params : SetAuthorityParams ) -> Instruction : \"\"\"Creates a transaction instruction to sets a new authority of a mint or account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, current_authority, new_authority, token = pubkeys >>> params = SetAuthorityParams( ... account=account, ... authority=AuthorityType.ACCOUNT_OWNER, ... current_authority=current_authority, ... new_authority=new_authority, ... program_id=token, ... ) >>> type(set_authority(params)) <class 'solders.instruction.Instruction'> Returns: The set authority instruction. \"\"\" new_authority , opt = ( params . new_authority , 1 ) if params . new_authority else ( Pubkey ([ 0 ] * 31 + [ 0 ]), 0 ) data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . SET_AUTHORITY , \"args\" : { \"authority_type\" : params . authority , \"new_authority_option\" : opt , \"new_authority\" : bytes ( new_authority ), }, } ) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . current_authority , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) sync_native ( params ) Syncs the amount field with the number of lamports of the account. Examples: >>> account = Pubkey . default () >>> params = SyncNativeParams ( ... program_id = TOKEN_PROGRAM_ID , account = account , ... ) >>> type ( sync_native ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The sync-native instruction. Source code in spl/token/instructions.py def sync_native ( params : SyncNativeParams ) -> Instruction : \"\"\"Syncs the amount field with the number of lamports of the account. Example: >>> account = Pubkey.default() >>> params = SyncNativeParams( ... program_id=TOKEN_PROGRAM_ID, account=account, ... ) >>> type(sync_native(params)) <class 'solders.instruction.Instruction'> Returns: The sync-native instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . SYNC_NATIVE , \"args\" : {}, } ) return __sync_native_instruction ( params , data ) thaw_account ( params ) Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , authority , token = pubkeys >>> params = ThawAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( thaw_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The thaw-account instruction. Source code in spl/token/instructions.py def thaw_account ( params : ThawAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, authority, token = pubkeys >>> params = ThawAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(thaw_account(params)) <class 'solders.instruction.Instruction'> Returns: The thaw-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . THAW_ACCOUNT ) transfer ( params ) Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , owner , source , token = pubkeys >>> params = TransferParams ( ... amount = 1000 , ... dest = dest , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The transfer instruction. Source code in spl/token/instructions.py def transfer ( params : TransferParams ) -> Instruction : \"\"\"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, owner, source, token = pubkeys >>> params = TransferParams( ... amount=1000, ... dest=dest, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer(params)) <class 'solders.instruction.Instruction'> Returns: The transfer instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . TRANSFER , \"args\" : { \"amount\" : params . amount }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) transfer_checked ( params ) This instruction differs from transfer in that the token mint and decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 5 )] >>> dest , mint , owner , source , token = pubkeys >>> params = TransferCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The transfer-checked instruction. Source code in spl/token/instructions.py def transfer_checked ( params : TransferCheckedParams ) -> Instruction : \"\"\"This instruction differs from `transfer` in that the token mint and decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(5)] >>> dest, mint, owner, source, token = pubkeys >>> params = TransferCheckedParams( ... amount=1000, ... decimals=6, ... dest=dest, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer_checked(params)) <class 'solders.instruction.Instruction'> Returns: The transfer-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . TRANSFER2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"Instructions"},{"location":"spl/token/instructions/#instructions","text":"SPL token instructions.","title":"Instructions"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams","text":"ApproveChecked token transaction params. Source code in spl/token/instructions.py class ApproveCheckedParams ( NamedTuple ): \"\"\"ApproveChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" delegate : Pubkey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"ApproveCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.amount","text":"Maximum number of tokens the delegate may transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.delegate","text":"Delegate account authorized to perform a transfer of tokens from the source account.","title":"delegate"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.__new__","text":"Create new instance of ApproveCheckedParams(program_id, source, mint, delegate, owner, amount, decimals, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams","text":"Approve token transaction params. Source code in spl/token/instructions.py class ApproveParams ( NamedTuple ): \"\"\"Approve token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" delegate : Pubkey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"ApproveParams"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.amount","text":"Maximum number of tokens the delegate may transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.delegate","text":"Delegate account authorized to perform a transfer of tokens from the source account.","title":"delegate"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.__new__","text":"Create new instance of ApproveParams(program_id, source, delegate, owner, amount, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType","text":"Specifies the authority type for SetAuthority instructions. Source code in spl/token/instructions.py class AuthorityType ( IntEnum ): \"\"\"Specifies the authority type for SetAuthority instructions.\"\"\" MINT_TOKENS = 0 \"\"\"\"Authority to mint new tokens.\"\"\" FREEZE_ACCOUNT = 1 \"\"\"Authority to freeze any account associated with the Mint.\"\"\" ACCOUNT_OWNER = 2 \"\"\"Owner of a given token account.\"\"\" CLOSE_ACCOUNT = 3 \"\"\"Authority to close a token account.\"\"\"","title":"AuthorityType"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.ACCOUNT_OWNER","text":"Owner of a given token account.","title":"ACCOUNT_OWNER"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.CLOSE_ACCOUNT","text":"Authority to close a token account.","title":"CLOSE_ACCOUNT"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.FREEZE_ACCOUNT","text":"Authority to freeze any account associated with the Mint.","title":"FREEZE_ACCOUNT"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.MINT_TOKENS","text":"\"Authority to mint new tokens.","title":"MINT_TOKENS"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams","text":"BurnChecked token transaction params. Source code in spl/token/instructions.py class BurnCheckedParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" account : Pubkey \"\"\"Account to burn tokens from.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"BurnCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.account","text":"Account to burn tokens from.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.amount","text":"Amount to burn.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.__new__","text":"Create new instance of BurnCheckedParams(program_id, mint, account, owner, amount, decimals, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams","text":"Burn token transaction params. Source code in spl/token/instructions.py class BurnParams ( NamedTuple ): \"\"\"Burn token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to burn tokens from.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"BurnParams"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.account","text":"Account to burn tokens from.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.amount","text":"Amount to burn.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.__new__","text":"Create new instance of BurnParams(program_id, account, mint, owner, amount, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams","text":"Close token account transaction params. Source code in spl/token/instructions.py class CloseAccountParams ( NamedTuple ): \"\"\"Close token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Address of account to close.\"\"\" dest : Pubkey \"\"\"Address of account to receive the remaining balance of the closed account.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"CloseAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.account","text":"Address of account to close.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.dest","text":"Address of account to receive the remaining balance of the closed account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.__new__","text":"Create new instance of CloseAccountParams(program_id, account, dest, owner, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams","text":"Freeze token account transaction params. Source code in spl/token/instructions.py class FreezeAccountParams ( NamedTuple ): \"\"\"Freeze token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to freeze.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" authority : Pubkey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\"","title":"FreezeAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.account","text":"Account to freeze.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.authority","text":"Mint freeze authority","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.multi_signers","text":"Signing accounts if authority is a multiSig","title":"multi_signers"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.__new__","text":"Create new instance of FreezeAccountParams(program_id, account, mint, authority, multi_signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams","text":"Initialize token account transaction params. Source code in spl/token/instructions.py class InitializeAccountParams ( NamedTuple ): \"\"\"Initialize token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Public key of the new account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" owner : Pubkey \"\"\"Owner of the new account.\"\"\"","title":"InitializeAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.account","text":"Public key of the new account.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.owner","text":"Owner of the new account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.__new__","text":"Create new instance of InitializeAccountParams(program_id, account, mint, owner)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams","text":"Initialize token mint transaction params. Source code in spl/token/instructions.py class InitializeMintParams ( NamedTuple ): \"\"\"Initialize token mint transaction params.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" mint_authority : Pubkey \"\"\"The authority/multisignature to mint tokens.\"\"\" freeze_authority : Optional [ Pubkey ] = None \"\"\"The freeze authority/multisignature of the mint.\"\"\"","title":"InitializeMintParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.decimals","text":"Number of base 10 digits to the right of the decimal place.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.freeze_authority","text":"The freeze authority/multisignature of the mint.","title":"freeze_authority"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.mint_authority","text":"The authority/multisignature to mint tokens.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.__new__","text":"Create new instance of InitializeMintParams(decimals, program_id, mint, mint_authority, freeze_authority)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams","text":"Initialize multisig token account transaction params. Source code in spl/token/instructions.py class InitializeMultisigParams ( NamedTuple ): \"\"\"Initialize multisig token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" multisig : Pubkey \"\"\"New multisig account address.\"\"\" m : int \"\"\"The number of signers (M) required to validate this multisignature account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Addresses of multisig signers.\"\"\"","title":"InitializeMultisigParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.m","text":"The number of signers (M) required to validate this multisignature account.","title":"m"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.multisig","text":"New multisig account address.","title":"multisig"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.signers","text":"Addresses of multisig signers.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.__new__","text":"Create new instance of InitializeMultisigParams(program_id, multisig, m, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams","text":"MintToChecked token transaction params. Source code in spl/token/instructions.py class MintToCheckedParams ( NamedTuple ): \"\"\"MintToChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : Pubkey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\"","title":"MintToCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.amount","text":"Amount to mint.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.dest","text":"Public key of the account to mint to.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.mint_authority","text":"The mint authority.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.signers","text":"Signing accounts if mint_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.__new__","text":"Create new instance of MintToCheckedParams(program_id, mint, dest, mint_authority, amount, decimals, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams","text":"Mint token transaction params. Source code in spl/token/instructions.py class MintToParams ( NamedTuple ): \"\"\"Mint token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : Pubkey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\"","title":"MintToParams"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.amount","text":"Amount to mint.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.dest","text":"Public key of the account to mint to.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.mint_authority","text":"The mint authority.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.signers","text":"Signing accounts if mint_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.__new__","text":"Create new instance of MintToParams(program_id, mint, dest, mint_authority, amount, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams","text":"Revoke token transaction params. Source code in spl/token/instructions.py class RevokeParams ( NamedTuple ): \"\"\"Revoke token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Source account for which transfer authority is being revoked.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"RevokeParams"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.account","text":"Source account for which transfer authority is being revoked.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.__new__","text":"Create new instance of RevokeParams(program_id, account, owner, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams","text":"Set token authority transaction params. Source code in spl/token/instructions.py class SetAuthorityParams ( NamedTuple ): \"\"\"Set token authority transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Public key of the token account.\"\"\" authority : AuthorityType \"\"\"The type of authority to update.\"\"\" current_authority : Pubkey \"\"\"Current authority of the specified type.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `current_authority` is a multiSig.\"\"\" new_authority : Optional [ Pubkey ] = None \"\"\"New authority of the account.\"\"\"","title":"SetAuthorityParams"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.account","text":"Public key of the token account.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.authority","text":"The type of authority to update.","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.current_authority","text":"Current authority of the specified type.","title":"current_authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.new_authority","text":"New authority of the account.","title":"new_authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.signers","text":"Signing accounts if current_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.__new__","text":"Create new instance of SetAuthorityParams(program_id, account, authority, current_authority, signers, new_authority)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams","text":"BurnChecked token transaction params. Source code in spl/token/instructions.py class SyncNativeParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to sync.\"\"\"","title":"SyncNativeParams"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams.account","text":"Account to sync.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams.__new__","text":"Create new instance of SyncNativeParams(program_id, account)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams","text":"Thaw token account transaction params. Source code in spl/token/instructions.py class ThawAccountParams ( NamedTuple ): \"\"\"Thaw token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to thaw.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" authority : Pubkey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\"","title":"ThawAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.account","text":"Account to thaw.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.authority","text":"Mint freeze authority","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.multi_signers","text":"Signing accounts if authority is a multiSig","title":"multi_signers"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.__new__","text":"Create new instance of ThawAccountParams(program_id, account, mint, authority, multi_signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams","text":"TransferChecked token transaction params. Source code in spl/token/instructions.py class TransferCheckedParams ( NamedTuple ): \"\"\"TransferChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Destination account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"TransferCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.amount","text":"Number of tokens to transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.dest","text":"Destination account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.__new__","text":"Create new instance of TransferCheckedParams(program_id, source, mint, dest, owner, amount, decimals, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams","text":"Transfer token transaction params. Source code in spl/token/instructions.py class TransferParams ( NamedTuple ): \"\"\"Transfer token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" dest : Pubkey \"\"\"Destination account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"TransferParams"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.amount","text":"Number of tokens to transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.dest","text":"Destination account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in spl/token/instructions.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.__new__","text":"Create new instance of TransferParams(program_id, source, dest, owner, amount, signers)","title":"__new__()"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.__repr__","text":"Return a nicely formatted representation string Source code in spl/token/instructions.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"spl/token/instructions/#spl.token.instructions.approve","text":"Creates a transaction instruction to approve a delegate. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> delegate , owner , source , token = pubkeys >>> params = ApproveParams ( ... amount = 123 , ... delegate = delegate , ... owner = owner , ... program_id = token , ... source = source ... ) >>> type ( approve ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The approve instruction. Source code in spl/token/instructions.py def approve ( params : ApproveParams ) -> Instruction : \"\"\"Creates a transaction instruction to approve a delegate. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> delegate, owner, source, token = pubkeys >>> params = ApproveParams( ... amount=123, ... delegate=delegate, ... owner=owner, ... program_id=token, ... source=source ... ) >>> type(approve(params)) <class 'solders.instruction.Instruction'> Returns: The approve instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . APPROVE , \"args\" : { \"amount\" : params . amount }}) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"approve()"},{"location":"spl/token/instructions/#spl.token.instructions.approve_checked","text":"This instruction differs from approve in that the token mint and decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 5 )] >>> delegate , mint , owner , source , token = pubkeys >>> params = ApproveCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... delegate = delegate , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( approve_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The approve-checked instruction. Source code in spl/token/instructions.py def approve_checked ( params : ApproveCheckedParams ) -> Instruction : \"\"\"This instruction differs from `approve` in that the token mint and decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(5)] >>> delegate, mint, owner, source, token = pubkeys >>> params = ApproveCheckedParams( ... amount=1000, ... decimals=6, ... delegate=delegate, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(approve_checked(params)) <class 'solders.instruction.Instruction'> Returns: The approve-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . APPROVE2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"approve_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.burn","text":"Creates a transaction instruction to burns tokens by removing them from an account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = BurnParams ( ... amount = 123 , account = account , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The burn instruction. Source code in spl/token/instructions.py def burn ( params : BurnParams ) -> Instruction : \"\"\"Creates a transaction instruction to burns tokens by removing them from an account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = BurnParams( ... amount=123, account=account, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn(params)) <class 'solders.instruction.Instruction'> Returns: The burn instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . BURN , \"args\" : { \"amount\" : params . amount }}) return __burn_instruction ( params , data )","title":"burn()"},{"location":"spl/token/instructions/#spl.token.instructions.burn_checked","text":"This instruction differs from burn in that the decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = BurnCheckedParams ( ... amount = 123 , account = account , decimals = 6 , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The burn-checked instruction. Source code in spl/token/instructions.py def burn_checked ( params : BurnCheckedParams ) -> Instruction : \"\"\"This instruction differs from `burn` in that the decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = BurnCheckedParams( ... amount=123, account=account, decimals=6, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn_checked(params)) <class 'solders.instruction.Instruction'> Returns: The burn-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . BURN2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) return __burn_instruction ( params , data )","title":"burn_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.close_account","text":"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , dest , owner , token = pubkeys >>> params = CloseAccountParams ( ... account = account , dest = dest , owner = owner , program_id = token ) >>> type ( close_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The close-account instruction. Source code in spl/token/instructions.py def close_account ( params : CloseAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, dest, owner, token = pubkeys >>> params = CloseAccountParams( ... account=account, dest=dest, owner=owner, program_id=token) >>> type(close_account(params)) <class 'solders.instruction.Instruction'> Returns: The close-account instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . CLOSE_ACCOUNT , \"args\" : None }) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"close_account()"},{"location":"spl/token/instructions/#spl.token.instructions.create_associated_token_account","text":"Creates a transaction instruction to create an associated token account. Parameters: Name Type Description Default payer Pubkey Payer's wallet address. required owner Pubkey Owner's wallet address. required mint Pubkey The token mint address. required token_program_id Pubkey The token program ID. Must be either spl.token.constants.TOKEN_PROGRAM_ID or spl.token.constants.TOKEN_2022_PROGRAM_ID (default is TOKEN_PROGRAM_ID ). Pubkey( TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA, ) Returns: Type Description Instruction The instruction to create the associated token account. Exceptions: Type Description ValueError If an invalid token_program_id is provided. Source code in spl/token/instructions.py def create_associated_token_account ( payer : Pubkey , owner : Pubkey , mint : Pubkey , token_program_id : Pubkey = TOKEN_PROGRAM_ID ) -> Instruction : \"\"\"Creates a transaction instruction to create an associated token account. Args: payer (Pubkey): Payer's wallet address. owner (Pubkey): Owner's wallet address. mint (Pubkey): The token mint address. token_program_id (Pubkey, optional): The token program ID. Must be either `spl.token.constants.TOKEN_PROGRAM_ID` or `spl.token.constants.TOKEN_2022_PROGRAM_ID` (default is `TOKEN_PROGRAM_ID`). Returns: The instruction to create the associated token account. Raises: ValueError: If an invalid `token_program_id` is provided. \"\"\" if token_program_id not in [ TOKEN_PROGRAM_ID , TOKEN_2022_PROGRAM_ID ]: raise ValueError ( \"token_program_id must be one of TOKEN_PROGRAM_ID or TOKEN_2022_PROGRAM_ID.\" ) associated_token_address = get_associated_token_address ( owner , mint , token_program_id ) return Instruction ( accounts = [ AccountMeta ( pubkey = payer , is_signer = True , is_writable = True ), AccountMeta ( pubkey = associated_token_address , is_signer = False , is_writable = True ), AccountMeta ( pubkey = owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYS_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = token_program_id , is_signer = False , is_writable = False ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , data = bytes ( 0 ), )","title":"create_associated_token_account()"},{"location":"spl/token/instructions/#spl.token.instructions.create_idempotent_associated_token_account","text":"Creates an associated token account for the given address/token mint if it not exists. Returns: Type Description Instruction The instruction to create the associated token account. Source code in spl/token/instructions.py def create_idempotent_associated_token_account ( payer : Pubkey , owner : Pubkey , mint : Pubkey , token_program_id : Pubkey = TOKEN_PROGRAM_ID ) -> Instruction : \"\"\"Creates an associated token account for the given address/token mint if it not exists. Returns: The instruction to create the associated token account. \"\"\" if token_program_id not in [ TOKEN_PROGRAM_ID , TOKEN_2022_PROGRAM_ID ]: raise ValueError ( \"token_program_id must be one of TOKEN_PROGRAM_ID or TOKEN_2022_PROGRAM_ID.\" ) associated_token_address = get_associated_token_address ( owner , mint , token_program_id ) return Instruction ( accounts = [ AccountMeta ( pubkey = payer , is_signer = True , is_writable = True ), AccountMeta ( pubkey = associated_token_address , is_signer = False , is_writable = True ), AccountMeta ( pubkey = owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYS_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = token_program_id , is_signer = False , is_writable = False ), ], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , data = bytes ([ 1 ]), )","title":"create_idempotent_associated_token_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_approve","text":"Decode a approve token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ApproveParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve ( instruction : Instruction ) -> ApproveParams : \"\"\"Decode a approve token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . APPROVE ) return ApproveParams ( program_id = instruction . program_id , source = instruction . accounts [ 0 ] . pubkey , delegate = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], amount = parsed_data . args . amount , )","title":"decode_approve()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_approve_checked","text":"Decode a approve_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ApproveCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve_checked ( instruction : Instruction ) -> ApproveCheckedParams : \"\"\"Decode a approve_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . APPROVE2 ) return ApproveCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , delegate = instruction . accounts [ 2 ] . pubkey , owner = instruction . accounts [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 4 :]], )","title":"decode_approve_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_burn","text":"Decode a burn token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description BurnParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn ( instruction : Instruction ) -> BurnParams : \"\"\"Decode a burn token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN ) return BurnParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_burn()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_burn_checked","text":"Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description BurnCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn_checked ( instruction : Instruction ) -> BurnCheckedParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN2 ) return BurnCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_burn_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_close_account","text":"Decode a close account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description CloseAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_close_account ( instruction : Instruction ) -> CloseAccountParams : \"\"\"Decode a close account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . CLOSE_ACCOUNT ) return CloseAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_close_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_freeze_account","text":"Decode a freeze account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description FreezeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_freeze_account ( instruction : Instruction ) -> FreezeAccountParams : \"\"\"Decode a freeze account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . FREEZE_ACCOUNT ) return FreezeAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , authority = instruction . accounts [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_freeze_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_account","text":"Decode an initialize account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_account ( instruction : Instruction ) -> InitializeAccountParams : \"\"\"Decode an initialize account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 4 , InstructionType . INITIALIZE_ACCOUNT ) return InitializeAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , )","title":"decode_initialize_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_mint","text":"Decode an initialize mint token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeMintParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_mint ( instruction : Instruction ) -> InitializeMintParams : \"\"\"Decode an initialize mint token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MINT ) return InitializeMintParams ( decimals = parsed_data . args . decimals , program_id = instruction . program_id , mint = instruction . accounts [ 0 ] . pubkey , mint_authority = Pubkey ( parsed_data . args . mint_authority ), freeze_authority = Pubkey ( parsed_data . args . freeze_authority ) if parsed_data . args . freeze_authority_option else None , )","title":"decode_initialize_mint()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_multisig","text":"Decode an initialize multisig account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeMultisigParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_multisig ( instruction : Instruction ) -> InitializeMultisigParams : \"\"\"Decode an initialize multisig account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MULTISIG ) num_signers = parsed_data . args . m validate_instruction_keys ( instruction , 2 + num_signers ) return InitializeMultisigParams ( program_id = instruction . program_id , multisig = instruction . accounts [ 0 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ - num_signers :]], m = num_signers , )","title":"decode_initialize_multisig()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_mint_to","text":"Decode a mint to token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MintToParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to ( instruction : Instruction ) -> MintToParams : \"\"\"Decode a mint to token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO ) return MintToParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , mint = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , mint_authority = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_mint_to()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_mint_to_checked","text":"Decode a mintTo2 token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MintToCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to_checked ( instruction : Instruction ) -> MintToCheckedParams : \"\"\"Decode a mintTo2 token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO2 ) return MintToCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , mint = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , mint_authority = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_mint_to_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_revoke","text":"Decode a revoke token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description RevokeParams The decoded instruction. Source code in spl/token/instructions.py def decode_revoke ( instruction : Instruction ) -> RevokeParams : \"\"\"Decode a revoke token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 2 , InstructionType . REVOKE ) return RevokeParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , owner = instruction . accounts [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 2 :]], )","title":"decode_revoke()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_set_authority","text":"Decode a set authority token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description SetAuthorityParams The decoded instruction. Source code in spl/token/instructions.py def decode_set_authority ( instruction : Instruction ) -> SetAuthorityParams : \"\"\"Decode a set authority token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . SET_AUTHORITY ) return SetAuthorityParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , authority = AuthorityType ( parsed_data . args . authority_type ), new_authority = Pubkey ( parsed_data . args . new_authority ) if parsed_data . args . new_authority_option else None , current_authority = instruction . accounts [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 2 :]], )","title":"decode_set_authority()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_sync_native","text":"Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description SyncNativeParams The decoded instruction. Source code in spl/token/instructions.py def decode_sync_native ( instruction : Instruction ) -> SyncNativeParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return SyncNativeParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , )","title":"decode_sync_native()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_thaw_account","text":"Decode a thaw account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ThawAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_thaw_account ( instruction : Instruction ) -> ThawAccountParams : \"\"\"Decode a thaw account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . THAW_ACCOUNT ) return ThawAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , authority = instruction . accounts [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_thaw_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_transfer","text":"Decode a transfer token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description TransferParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer ( instruction : Instruction ) -> TransferParams : \"\"\"Decode a transfer token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . TRANSFER ) return TransferParams ( program_id = instruction . program_id , source = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], amount = parsed_data . args . amount , )","title":"decode_transfer()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_transfer_checked","text":"Decode a transfer_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description TransferCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer_checked ( instruction : Instruction ) -> TransferCheckedParams : \"\"\"Decode a transfer_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . TRANSFER2 ) return TransferCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , dest = instruction . accounts [ 2 ] . pubkey , owner = instruction . accounts [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 4 :]], )","title":"decode_transfer_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.freeze_account","text":"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , authority , token = pubkeys >>> params = FreezeAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( freeze_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The freeze-account instruction. Source code in spl/token/instructions.py def freeze_account ( params : FreezeAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, authority, token = pubkeys >>> params = FreezeAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(freeze_account(params)) <class 'solders.instruction.Instruction'> Returns: The freeze-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . FREEZE_ACCOUNT )","title":"freeze_account()"},{"location":"spl/token/instructions/#spl.token.instructions.get_associated_token_address","text":"Derives the associated token address for the given wallet address and token mint. Parameters: Name Type Description Default owner Pubkey Owner's wallet address. required mint Pubkey The token mint address. required token_program_id Pubkey The token program ID. Must be either spl.token.constants.TOKEN_PROGRAM_ID or spl.token.constants.TOKEN_2022_PROGRAM_ID (default is TOKEN_PROGRAM_ID ). Pubkey( TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA, ) Returns: Type Description Pubkey The public key of the derived associated token address. Exceptions: Type Description ValueError If an invalid token_program_id is provided. Source code in spl/token/instructions.py def get_associated_token_address ( owner : Pubkey , mint : Pubkey , token_program_id : Pubkey = TOKEN_PROGRAM_ID ) -> Pubkey : \"\"\"Derives the associated token address for the given wallet address and token mint. Args: owner (Pubkey): Owner's wallet address. mint (Pubkey): The token mint address. token_program_id (Pubkey, optional): The token program ID. Must be either `spl.token.constants.TOKEN_PROGRAM_ID` or `spl.token.constants.TOKEN_2022_PROGRAM_ID` (default is `TOKEN_PROGRAM_ID`). Returns: The public key of the derived associated token address. Raises: ValueError: If an invalid `token_program_id` is provided. \"\"\" if token_program_id not in [ TOKEN_PROGRAM_ID , TOKEN_2022_PROGRAM_ID ]: raise ValueError ( \"token_program_id must be one of TOKEN_PROGRAM_ID or TOKEN_2022_PROGRAM_ID.\" ) key , _ = Pubkey . find_program_address ( seeds = [ bytes ( owner ), bytes ( token_program_id ), bytes ( mint )], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , ) return key","title":"get_associated_token_address()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_account","text":"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = InitializeAccountParams ( ... account = account , ... mint = mint , ... owner = owner , ... program_id = token , ... ) >>> type ( initialize_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the account. Source code in spl/token/instructions.py def initialize_account ( params : InitializeAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = InitializeAccountParams( ... account=account, ... mint=mint, ... owner=owner, ... program_id=token, ... ) >>> type(initialize_account(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the account. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . INITIALIZE_ACCOUNT , \"args\" : None }) return Instruction ( accounts = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , )","title":"initialize_account()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_mint","text":"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> from solders.pubkey import Pubkey >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> mint_account , mint_authority , freeze_authority , owner = pubkeys >>> params = InitializeMintParams ( ... decimals = 6 , ... freeze_authority = freeze_authority , ... mint = mint_account , ... mint_authority = mint_authority , ... program_id = TOKEN_PROGRAM_ID , ... ) >>> type ( initialize_mint ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the mint. Source code in spl/token/instructions.py def initialize_mint ( params : InitializeMintParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> from solders.pubkey import Pubkey >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i +1]) for i in range(4)] >>> mint_account, mint_authority, freeze_authority, owner = pubkeys >>> params = InitializeMintParams( ... decimals=6, ... freeze_authority=freeze_authority, ... mint=mint_account, ... mint_authority=mint_authority, ... program_id=TOKEN_PROGRAM_ID, ... ) >>> type(initialize_mint(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the mint. \"\"\" freeze_authority , opt = ( params . freeze_authority , 1 ) if params . freeze_authority else ( Pubkey ([ 0 ] * 31 + [ 0 ]), 0 ) data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . INITIALIZE_MINT , \"args\" : { \"decimals\" : params . decimals , \"mint_authority\" : bytes ( params . mint_authority ), \"freeze_authority_option\" : opt , \"freeze_authority\" : bytes ( freeze_authority ), }, } ) return Instruction ( accounts = [ AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = True ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , )","title":"initialize_mint()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_multisig","text":"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> m = 2 # Two signers >>> signers = [ Pubkey ([ 0 ] * 31 + [ i ]) for i in range ( m )] >>> leading_zeros = [ 0 ] * 31 >>> multisig_account , token = Pubkey ( leading_zeros + [ 1 ]), Pubkey ( leading_zeros + [ 2 ]) >>> params = InitializeMultisigParams ( ... m = m , ... multisig = multisig_account , ... signers = signers , ... program_id = token , ... ) >>> type ( initialize_multisig ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the multisig. Source code in spl/token/instructions.py def initialize_multisig ( params : InitializeMultisigParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> m = 2 # Two signers >>> signers = [Pubkey([0] * 31 + [i]) for i in range(m)] >>> leading_zeros = [0] * 31 >>> multisig_account, token = Pubkey(leading_zeros + [1]), Pubkey(leading_zeros + [2]) >>> params = InitializeMultisigParams( ... m=m, ... multisig=multisig_account, ... signers=signers, ... program_id=token, ... ) >>> type(initialize_multisig(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the multisig. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . INITIALIZE_MULTISIG , \"args\" : { \"m\" : params . m }, } ) keys = [ AccountMeta ( pubkey = params . multisig , is_signer = False , is_writable = True ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ] for signer in params . signers : keys . append ( AccountMeta ( pubkey = signer , is_signer = False , is_writable = False )) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"initialize_multisig()"},{"location":"spl/token/instructions/#spl.token.instructions.mint_to","text":"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , mint , mint_authority , token = pubkeys >>> params = MintToParams ( ... amount = 123 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The mint-to instruction. Source code in spl/token/instructions.py def mint_to ( params : MintToParams ) -> Instruction : \"\"\"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, mint, mint_authority, token = pubkeys >>> params = MintToParams( ... amount=123, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to(params)) <class 'solders.instruction.Instruction'> Returns: The mint-to instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . MINT_TO , \"args\" : { \"amount\" : params . amount }}) return __mint_to_instruction ( params , data )","title":"mint_to()"},{"location":"spl/token/instructions/#spl.token.instructions.mint_to_checked","text":"This instruction differs from mint_to in that the decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , mint , mint_authority , token = pubkeys >>> params = MintToCheckedParams ( ... amount = 123 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The mint-to-checked instruction. Source code in spl/token/instructions.py def mint_to_checked ( params : MintToCheckedParams ) -> Instruction : \"\"\"This instruction differs from `mint_to` in that the decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, mint, mint_authority, token = pubkeys >>> params = MintToCheckedParams( ... amount=123, ... decimals=6, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to_checked(params)) <class 'solders.instruction.Instruction'> Returns: The mint-to-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . MINT_TO2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) return __mint_to_instruction ( params , data )","title":"mint_to_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.revoke","text":"Creates a transaction instruction that revokes delegate authority for a given account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 3 )] >>> account , owner , token = pubkeys >>> params = RevokeParams ( ... account = account , owner = owner , program_id = token ... ) >>> type ( revoke ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The revoke instruction. Source code in spl/token/instructions.py def revoke ( params : RevokeParams ) -> Instruction : \"\"\"Creates a transaction instruction that revokes delegate authority for a given account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(3)] >>> account, owner, token = pubkeys >>> params = RevokeParams( ... account=account, owner=owner, program_id=token ... ) >>> type(revoke(params)) <class 'solders.instruction.Instruction'> Returns: The revoke instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . REVOKE , \"args\" : None }) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"revoke()"},{"location":"spl/token/instructions/#spl.token.instructions.set_authority","text":"Creates a transaction instruction to sets a new authority of a mint or account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , current_authority , new_authority , token = pubkeys >>> params = SetAuthorityParams ( ... account = account , ... authority = AuthorityType . ACCOUNT_OWNER , ... current_authority = current_authority , ... new_authority = new_authority , ... program_id = token , ... ) >>> type ( set_authority ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The set authority instruction. Source code in spl/token/instructions.py def set_authority ( params : SetAuthorityParams ) -> Instruction : \"\"\"Creates a transaction instruction to sets a new authority of a mint or account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, current_authority, new_authority, token = pubkeys >>> params = SetAuthorityParams( ... account=account, ... authority=AuthorityType.ACCOUNT_OWNER, ... current_authority=current_authority, ... new_authority=new_authority, ... program_id=token, ... ) >>> type(set_authority(params)) <class 'solders.instruction.Instruction'> Returns: The set authority instruction. \"\"\" new_authority , opt = ( params . new_authority , 1 ) if params . new_authority else ( Pubkey ([ 0 ] * 31 + [ 0 ]), 0 ) data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . SET_AUTHORITY , \"args\" : { \"authority_type\" : params . authority , \"new_authority_option\" : opt , \"new_authority\" : bytes ( new_authority ), }, } ) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . current_authority , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"set_authority()"},{"location":"spl/token/instructions/#spl.token.instructions.sync_native","text":"Syncs the amount field with the number of lamports of the account. Examples: >>> account = Pubkey . default () >>> params = SyncNativeParams ( ... program_id = TOKEN_PROGRAM_ID , account = account , ... ) >>> type ( sync_native ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The sync-native instruction. Source code in spl/token/instructions.py def sync_native ( params : SyncNativeParams ) -> Instruction : \"\"\"Syncs the amount field with the number of lamports of the account. Example: >>> account = Pubkey.default() >>> params = SyncNativeParams( ... program_id=TOKEN_PROGRAM_ID, account=account, ... ) >>> type(sync_native(params)) <class 'solders.instruction.Instruction'> Returns: The sync-native instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . SYNC_NATIVE , \"args\" : {}, } ) return __sync_native_instruction ( params , data )","title":"sync_native()"},{"location":"spl/token/instructions/#spl.token.instructions.thaw_account","text":"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , authority , token = pubkeys >>> params = ThawAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( thaw_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The thaw-account instruction. Source code in spl/token/instructions.py def thaw_account ( params : ThawAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, authority, token = pubkeys >>> params = ThawAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(thaw_account(params)) <class 'solders.instruction.Instruction'> Returns: The thaw-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . THAW_ACCOUNT )","title":"thaw_account()"},{"location":"spl/token/instructions/#spl.token.instructions.transfer","text":"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , owner , source , token = pubkeys >>> params = TransferParams ( ... amount = 1000 , ... dest = dest , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The transfer instruction. Source code in spl/token/instructions.py def transfer ( params : TransferParams ) -> Instruction : \"\"\"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, owner, source, token = pubkeys >>> params = TransferParams( ... amount=1000, ... dest=dest, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer(params)) <class 'solders.instruction.Instruction'> Returns: The transfer instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . TRANSFER , \"args\" : { \"amount\" : params . amount }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"transfer()"},{"location":"spl/token/instructions/#spl.token.instructions.transfer_checked","text":"This instruction differs from transfer in that the token mint and decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 5 )] >>> dest , mint , owner , source , token = pubkeys >>> params = TransferCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The transfer-checked instruction. Source code in spl/token/instructions.py def transfer_checked ( params : TransferCheckedParams ) -> Instruction : \"\"\"This instruction differs from `transfer` in that the token mint and decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(5)] >>> dest, mint, owner, source, token = pubkeys >>> params = TransferCheckedParams( ... amount=1000, ... decimals=6, ... dest=dest, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer_checked(params)) <class 'solders.instruction.Instruction'> Returns: The transfer-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . TRANSFER2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"transfer_checked()"}]}